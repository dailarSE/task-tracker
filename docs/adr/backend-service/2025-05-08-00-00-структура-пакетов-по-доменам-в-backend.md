# ADR-0007: Использование структуры пакетов по доменам (фичам) в Backend сервисе

**Статус:** Accepted

**Дата:** 2025-05-08

## Контекст

По мере развития бэкенд-сервиса `task-tracker-backend` и добавления новой функциональности (управление пользователями, задачами, уведомлениями и т.д.), необходимо выбрать стратегию организации Java-пакетов. Структура пакетов должна способствовать пониманию кодовой базы, упрощать навигацию, поддерживать модульность и облегчать масштабирование проекта.

Существуют два основных подхода: организация по слоям (техническим типам компонентов) и организация по доменам (бизнес-фичам).

## Принятое Решение

Использовать **организацию пакетов по доменам (фичам)** для бэкенд-сервиса `task-tracker-backend`.

Это означает, что пакеты верхнего уровня будут соответствовать основным бизнес-областям или функциональным возможностям системы. Например:
- `com.example.tasktracker.backend.user` (для всего, что связано с пользователями и аутентификацией)
- `com.example.tasktracker.backend.task` (для управления задачами)
- `com.example.tasktracker.backend.notification` (для отправки уведомлений)

Внутри каждого пакета домена компоненты могут быть сгруппированы по техническим слоям (например, `controller`, `service`, `entity`, `repository`, `dto`), но основной принцип группировки — принадлежность к фиче.

Также будут существовать общие пакеты на верхнем уровне для конфигураций и переиспользуемых компонентов, не относящихся к конкретному домену, например:
- `com.example.tasktracker.backend.config` (общие конфигурации Spring)
- `com.example.tasktracker.backend.common` (общие утилиты, исключения, модели)

## Рассмотренные Альтернативы

1.  **Организация по слоям (Layer-based packaging):**
    *   **Описание:** Создание пакетов верхнего уровня для каждого технического слоя, например: `com.example.tasktracker.backend.controller`, `com.example.tasktracker.backend.service`, `com.example.tasktracker.backend.entity`, `com.example.tasktracker.backend.repository`.
    *   **Плюсы:** Привычно для многих разработчиков, легко найти все компоненты одного типа (например, все контроллеры).
    *   **Минусы:**
        *   **Слабая связность фич (Low Cohesion):** Код, относящийся к одной бизнес-фиче, разбросан по множеству пакетов. Например, для фичи "управление пользователями" ее контроллер, сервис, DTO, сущность и репозиторий будут находиться в разных пакетах верхнего уровня.
        *   **Высокая зацепленность (High Coupling) между пакетами слоев:** Пакеты слоев становятся сильно зависимыми друг от друга по всем фичам.
        *   **Плохая масштабируемость:** С ростом количества фич, каждый пакет слоя (особенно `service` и `controller`) становится очень большим и трудно управляемым.
        *   **Сложность навигации по фиче:** Чтобы понять или изменить одну фичу, нужно перемещаться между многими пакетами.
    *   **Причина отклонения:** Менее предпочтительна для проектов, стремящихся к модульности и масштабируемости, особенно в контексте микросервисной архитектуры, где фичи часто являются кандидатами на выделение в отдельные сервисы.

## Последствия

*   **Положительные:**
    *   **Высокая связность (High Cohesion) внутри фичи:** Весь код, относящийся к одной бизнес-области, находится в одном месте (в пакете домена).
    *   **Низкая зацепленность (Low Coupling) между фичами:** Фичи более независимы друг от друга. Изменения в одной фиче с меньшей вероятностью затронут другие.
    *   **Улучшенная модульность:** Легче понять, разрабатывать и тестировать отдельные фичи. Упрощается выделение фичи в отдельный модуль или микросервис в будущем.
    *   **Упрощенная навигация:** Разработчику, работающему над конкретной фичей, легче ориентироваться в коде.
    *   **Лучшая масштабируемость:** Добавление новых фич сводится к созданию нового пакета домена, не "засоряя" существующие.
*   **Отрицательные/Затраты:**
    *   Может потребоваться более четкое определение границ доменов/фич на начальном этапе.
    *   Необходимость в создании общего пакета (`common`) для переиспользуемых компонентов, чтобы избежать дублирования между доменами.
    *   Может быть менее привычно для разработчиков, имеющих большой опыт только со слоевой структурой.
*   **Необходимые действия:**
    *   Придерживаться выбранной структуры при создании новых классов.
    *   Провести рефакторинг существующего кода (например, `User` Entity и `UserRepository` уже были перемещены в пакет `com.example.tasktracker.backend.user.*`).
# ADR-0018: Требования и Процесс Аутентификации Пользователя

*   **Статус:** Утвержден
*   **Дата:** 2025-05-10
*   **Связанные ADR:**
    *   ADR-0017: Спецификация JWT и Обоснование Выбора (Описывает токен, который выдается в результате успешной аутентификации)
*   **Контекст:**
    *   Системе "Task Tracker" необходим процесс, позволяющий пользователям подтвердить свою личность и получить JWT (согласно ADR-0017) для доступа к защищенным ресурсам.
    *   Ответы об ошибках API должны соответствовать RFC 9457 (Problem Details for HTTP APIs), используя Content-Type `application/problem+json`.

*   **Принятое решение:**

    1.  **Регистрация Нового Пользователя:**
        *   **Эндпоинт:** `POST /user` (публично доступен).
        *   **Входные данные (Request Body):** JSON-объект, содержащий `email`, `password`, `repeatPassword`.
        *   **Проверки (Валидация):**
            *   Валидность формата email.
            *   Совпадение `password` и `repeatPassword`.
            *   Уникальность email в системе.
            *   *Требования к сложности и минимальной длине пароля на данном этапе не определены. При необходимости будут введены и задокументированы позже; может потребоваться механизм для обновления существующих паролей пользователей.*
        *   **Действия при успехе (HTTP 201 Created):**
            *   Создание новой записи пользователя в базе данных. Пароль должен храниться в хешированном виде с использованием сильного, общепринятого алгоритма (например, BCrypt, предоставляемый стандартными реализациями `PasswordEncoder` из Spring Security).
            *   **Автоматическая аутентификация:** Пользователь считается аутентифицированным немедленно после успешной регистрации.
            *   Генерация Access Token (согласно ADR-0017).
            *   Возврат JSON-ответа, содержащего Access Token. Рекомендуемая структура ответа:
                ```json
                {
                  "access_token": "your_jwt_token_here",
                  "token_type": "Bearer",
                  "expires_in": 3600 // Время жизни токена в секундах, информационно
                }
                ```
            *   В HTTP-ответе также **ДОЛЖЕН** присутствовать заголовок `Location` с URI созданного ресурса пользователя (например, `/user/me` или `/users/{userId}`).
            *   Отправка приветственного email пользователю (асинхронно, например, через Kafka).
        *   **Действия при ошибке:**
            *   При ошибках валидации входных данных (неверный формат email, несовпадение паролей): HTTP **400 Bad Request**.
            *   Если email уже занят: HTTP **409 Conflict**.
            *   Тело ответа во всех случаях ошибки должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
                *   `type`: URI, идентифицирующий тип проблемы (например, `https://task-tracker.example.com/probs/validation-error`, `https://task-tracker.example.com/probs/email-already-taken`). Эти URI должны быть определены и задокументированы.
                *   `title`: Краткое, человекочитаемое описание типа проблемы.
                *   `status`: HTTP-статус код ответа (400 или 409).
                *   `detail`: Человекочитаемое описание конкретной ошибки.
                *   (Для ошибок валидации 400) Рекомендуется использовать расширение `errors` (массив объектов), детализирующее ошибки по конкретным полям запроса, если это применимо.

    2.  **Аутентификация (Логин) Существующего Пользователя:**
        *   **Эндпоинт:** `POST /auth/login` (публично доступен).
        *   **Входные данные (Request Body):** JSON-объект, содержащий `email` и `password`.
        *   **Проверки:**
            *   Наличие пользователя с указанным email.
            *   Совпадение предоставленного пароля с сохраненным хешем.
        *   **Действия при успехе (HTTP 200 OK):**
            *   Генерация Access Token (согласно ADR-0017).
            *   Возврат JSON-ответа с Access Token, аналогично структуре при регистрации:
                ```json
                {
                  "access_token": "your_jwt_token_here",
                  "token_type": "Bearer",
                  "expires_in": 3600
                }
                ```
        *   **Действия при ошибке (HTTP 401 Unauthorized):**
            *   Возврат HTTP-ответа со статус-кодом `401 Unauthorized`.
            *   Заголовок `WWW-Authenticate: Bearer realm="task-tracker"` (или иной согласованный `realm`) **ДОЛЖЕН** быть включен. Дополнительно **МОГУТ** быть включены параметры `error` (например, `"invalid_grant"`) и `error_description` (например, `"Invalid credentials"`), согласно RFC 6750.
            *   Тело ответа должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
                *   `type`: URI (например, `https://task-tracker.example.com/probs/invalid-credentials`).
                *   `title`: "Invalid Credentials" или аналогичное.
                *   `status`: 401.
                *   `detail`: "The email or password provided is incorrect."

    3.  **Logout Пользователя:**
        *   Так как используются stateless JWT без серверного механизма отзыва (согласно ADR-0017), операция Logout является ответственностью **клиентской стороны** и заключается в безопасном удалении сохраненного Access Token.
        *   Серверный эндпоинт `/logout` на данном этапе **не реализуется**, так как он не предоставляет дополнительной функциональности по аннулированию JWT на стороне сервера.

*   **Последствия и Рекомендации:**
    *   Использовать стандартные, надежные реализации `PasswordEncoder` из Spring Security (например, `BCryptPasswordEncoder`).
    *   Клиентскому приложению необходимо реализовывать безопасное хранение и удаление JWT. Клиент также может использовать поле `expires_in` для информационных целей, но всегда должен полагаться на `exp` claim внутри самого JWT для определения фактического времени жизни токена.
    *   В будущем рассмотреть механизмы защиты от brute-force атак на эндпоинт логина (например, rate limiting, CAPTCHA после нескольких неудачных попыток).
    *   Определить и задокументировать пул `type` URI (для поля `type` в Problem Details JSON) для всех возможных ошибок аутентификации и других ошибок API.

# ADR-0019: Требования и Механизмы Авторизации Доступа к Ресурсам

*   **Статус:** Утвержден
*   **Дата:** 2025-05-10
*   **Связанные ADR:**
    *   ADR-0018: Требования и Процесс Аутентификации Пользователя (Обеспечивает получение аутентифицированного `principal` с `userId`)
*   **Контекст:**
    *   После успешной аутентификации пользователя (согласно ADR-0018), системе "Task Tracker" необходим механизм для определения, какие действия аутентифицированный пользователь может выполнять с ресурсами системы (например, задачами), а какие нет.
    *   Основное требование – пользователи должны иметь доступ и возможность модифицировать только свои собственные ресурсы.
    *   Система должна быть спроектирована с упором на "безопасность по умолчанию" для минимизации риска несанкционированного доступа.
    *   Ответы об ошибках авторизации должны соответствовать RFC 9457 (Problem Details for HTTP APIs).

*   **Принятое решение:**

    1.  **Основной Принцип Авторизации:**
        *   **Авторизация на основе владения ресурсом (Resource-based ownership):** Пользователь, идентифицированный по `userId` (из `sub` claim JWT, согласно ADR-0017), может выполнять операции только над ресурсами, которые ему принадлежат (т.е., связаны с его `userId`).
        *   **"Безопасные по умолчанию" репозитории:** Логика проверки владения должна быть максимально приближена к слою доступа к данным.

    2.  **Реализация Авторизации в Слоях:**

        *   **2.1. Слой Репозиториев (`TaskRepository` и аналогичные):**
            *   Является **основным местом** для реализации авторизации по владению ресурсом при операциях чтения.
            *   **Ограничение интерфейсов:** Интерфейсы репозиториев **не должны наследовать стандартные "всеобъемлющие" интерфейсы Spring Data JPA** (типа `JpaRepository`, `CrudRepository`) без явной и обоснованной необходимости. Вместо этого, они должны определять кастомный набор методов. Каждый такой метод, предназначенный для общего пользовательского доступа, по умолчанию должен быть "безопасным" (т.е., учитывать `userId` текущего пользователя).
            *   **Чтение данных (списки, одиночные сущности):** Авторизация встраивается непосредственно в JPQL/SQL запросы с использованием **Security Expressions в аннотации `@Query`**, ссылающихся на `principal.id`.
                *   Пример для получения списка задач текущего пользователя:
                    `@Query("SELECT t FROM Task t WHERE t.user.id = ?#{ principal.id }")`
                *   Пример для получения конкретной задачи текущего пользователя по ее ID:
                    `@Query("SELECT t FROM Task t WHERE t.id = :taskId AND t.user.id = ?#{ principal.id }")`
                *   Если ресурс не принадлежит пользователю или не существует, такие запросы вернут пустой результат (например, пустой список или `Optional.empty()`), что соответствует стратегии сокрытия информации.
            *   **Создание данных (`save` для новых сущностей):**
                *   Репозиторий предоставляет метод `save(S entity)`.
                *   Ответственность **сервисного слоя:** Установить корректный `userId` (полученный из `SecurityContext`) на новой сущности *перед* вызовом `save`.
                *   Поле `userId` в сущности `Task` (и аналогичных сущностях, принадлежащих пользователю) **ДОЛЖНО** быть сконфигурировано как неизменяемое после первоначальной установки (JPA аннотация `@Column(name = "user_id", nullable = false, updatable = false)`). Это предотвращает случайное или намеренное изменение владельца ресурса через стандартные операции обновления.
            *   **Обновление данных (`save` для существующих сущностей):**
                *   Сервисный слой **ОБЯЗАН** сначала загрузить существующую сущность через "безопасный" метод репозитория (например, `findByIdAndCurrentUser`). Это неявно подтверждает право пользователя на модификацию (т.к. он смог ее прочитать).
                *   После модификации полей сущности в сервисном слое, вызывается тот же метод `save(S entity)`. Неизменяемость поля `userId` гарантирует, что владелец не будет изменен.
            *   **Удаление данных:**
                *   Репозиторий **ДОЛЖЕН** предоставлять "безопасный" метод удаления, который включает проверку `userId` непосредственно в запросе.
                *   Пример: `@Modifying @Query("DELETE FROM Task t WHERE t.id = :taskId AND t.user.id = ?#{ principal.id }") int deleteByIdAndCurrentUser(@Param("taskId") Long taskId);`
                *   Сервисный слой вызывает этот метод. Возвращаемое значение (количество удаленных записей) может использоваться для определения, была ли операция успешной и принадлежал ли ресурс пользователю.

        *   **2.2. Сервисный Слой (`TaskService` и аналогичные):**
            *   Использует **исключительно "безопасные" методы репозиториев** для всех операций, где важна принадлежность ресурса пользователю.
            *   Отвечает за установку `userId` для новых сущностей перед их сохранением.
            *   Для более сложных бизнес-правил авторизации, которые не могут быть полностью выражены на уровне запросов репозитория, или для защиты методов, не связанных напрямую с CRUD одной сущности, может использоваться **Spring Method Security (`@PreAuthorize`, `@PostAuthorize`, `@PostFilter`)**.
            *   Логика таких проверок, если она сложная или переиспользуемая, инкапсулируется в отдельном Spring бине (например, `PermissionService`), методы которого вызываются из SpEL-выражений.
                Пример: `@PreAuthorize("@permissionService.canUserPerformComplexAction(authentication, #resourceId)")`.

        *   **2.3. `PermissionService` (или аналогичный бин):**
            *   Служит для централизации и инкапсуляции сложных или переиспользуемых правил авторизации, которые не являются простым сопоставлением `userId`.
            *   Не должен дублировать базовую проверку владения, если она эффективно реализована на уровне репозитория.

    3.  **Конфигурация Spring Security для Авторизации:**
        *   Использовать `@EnableMethodSecurity` для активации Method Security.
        *   Убедиться, что Java-код компилируется с флагом `-parameters` для корректной работы SpEL.
        *   Кастомная реализация `UserDetails` (из ADR-0018) должна предоставлять `id` пользователя для использования в `?#{ principal.id }`.

    4.  **Административный Доступ:**
        *   На данном этапе не реализуется в основном пользовательском API.
        *   Если в будущем потребуется административный доступ к ресурсам всех пользователей, он будет реализован через:
            *   Специальную роль (например, `ROLE_ADMIN`), включаемую в JWT администратора (см. ADR-0017).
            *   Проверки этой роли в `@PreAuthorize` (например, `@PreAuthorize("hasRole('ADMIN')")`).
            *   Отдельные "админские" методы в сервисах и/или репозиториях, которые не применяют стандартную фильтрацию по `userId` текущего пользователя, или используют для этого специальный параметр. Рассмотреть выделение таких операций в отдельные компоненты или даже сервисы.

    5.  **Обработка Ошибок Авторизации:**
        *   При попытке доступа к чужому ресурсу или выполнения неразрешенного действия, API **ДОЛЖЕН** вернуть:
            *   Предпочтительно **HTTP 404 Not Found**, если операция касается конкретного ресурса по ID (например, `GET /tasks/{taskId}`, `PUT /tasks/{taskId}`, `DELETE /tasks/{taskId}`). Это скрывает факт существования ресурса от неавторизованного пользователя.
            *   **HTTP 403 Forbidden** в других случаях отказа авторизации (например, если пользователь аутентифицирован, но не имеет нужной роли для выполнения общего действия).
        *   Тело ответа во всех случаях ошибки должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
            *   `type`: URI, идентифицирующий тип проблемы (например, `https://task-tracker.example.com/probs/access-denied`, `https://task-tracker.example.com/probs/resource-not-found`).
            *   `title`: Краткое описание типа проблемы.
            *   `status`: HTTP-статус код ответа (403 или 404).
            *   `detail`: Описание конкретной ошибки.

*   **Рассмотренные Альтернативы и Обоснование Выбора:**

    При проектировании механизма авторизации по владению ресурсом рассматривались несколько подходов, каждый со своими преимуществами и недостатками:

    1.  **Полная реализация авторизации в Сервисном Слое (без специализированных "безопасных" репозиториев):**
        *   **Описание:** Вся логика проверки владения реализуется непосредственно в методах сервисного слоя.
        *   **Недостатки:** Многословность, высокий риск ошибки (пропустить проверку), зашумление бизнес-логики.
        *   **Причина отказа:** Не обеспечивает "безопасность по умолчанию", слишком подвержен человеческому фактору.

    2.  **Использование исключительно Spring Method Security (`@PreAuthorize`, `@PostFilter`) на методах Сервисного Слоя:**
        *   **Описание:** Аннотации безопасности применяются к методам сервисного слоя.
        *   **Недостатки:** Неэффективность `@PostFilter` для больших коллекций, потенциальная сложность SpEL, риск неполного покрытия, не решает проблему "небезопасных" методов репозитория.
        *   **Причина отказа (как единственного решения):** Недостаточная защита на уровне данных и потенциальные проблемы с производительностью/сложностью. Используется как часть принятого решения для специфических случаев.

    3.  **Использование Hibernate Filters:**
        *   **Описание:** Глобальные или сессионные фильтры Hibernate для автоматического добавления условий в запросы.
        *   **Недостатки:** "Магия" (неявность фильтрации), сложность настройки и управления, меньшая гибкость для сложных правил по сравнению с Method Security.
        *   **Причина отказа (как основного решения):** Более высокая сложность и меньшая явность по сравнению с Security Expressions в `@Query` для простых случаев фильтрации по владельцу.

    4.  **Аспектно-Ориентированное Программирование (AOP) / Декораторы для Сервисов/Репозиториев:**
        *   **Описание:** Вынесение логики безопасности в аспекты или классы-декораторы.
        *   **Недостатки:** Сложность AOP, неявность (AOP), многословность (Декораторы).
        *   **Причина отказа (как основного решения):** Spring Security Method Security предоставляет схожий механизм на основе AOP, но с более стандартным API. Для простых проверок, встроенных в репозиторий, AOP избыточен.

*   **Последствия и Рекомендации:**
    *   Тщательно проектировать интерфейсы репозиториев, придерживаясь принципа "безопасных по умолчанию" методов.
    *   Обеспечить неизменяемость поля `userId` в сущностях (`@Column(name = "user_id", nullable = false, updatable = false)`) после его первоначальной установки.
    *   Проводить исчерпывающее тестирование безопасности, проверяя все возможные сценарии несанкционированного доступа к данным и операциям.
    *   Определить и задокументировать `type` URI (для Problem Details) для ошибок авторизации.
    *   Код-ревью должен уделять особое внимание корректности реализации механизмов авторизации в репозиториях и сервисном слое.

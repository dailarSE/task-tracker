# ADR-0020: Архитектура Компонентов Безопасности в Backend Сервисе (`task-tracker-backend`)

*   **Статус:** Утвержден
*   **Дата:** 2025-05-10
*   **Связанные ADR:**
    *   ADR-0017: Спецификация JWT и Обоснование Выбора
    *   ADR-0018: Требования и Процесс Аутентификации Пользователя
    *   ADR-0019: Требования и Механизмы Авторизации Доступа к Ресурсам
*   **Контекст:**
    *   Для реализации требований по аутентификации (ADR-0018) и авторизации (ADR-0019) с использованием JWT (ADR-0017) в сервисе `task-tracker-backend`, необходимо определить конкретные компоненты Spring Security и кастомные классы, их взаимодействие и конфигурацию.
    *   Цель – создать понятную, тестируемую и расширяемую архитектуру безопасности. Java-код должен компилироваться с флагом `-parameters` для корректной работы SpEL с именами параметров методов в аннотациях Method Security.

*   **Принятое решение:**

    1.  **Основная Конфигурация Spring Security (`SecurityConfig`):**
        *   Класс, аннотированный `@Configuration` и `@EnableWebSecurity`.
        *   Использует `@EnableMethodSecurity(prePostEnabled = true)` для активации Method Security (поддержка `@PreAuthorize` и др.).
        *   Определяет бин `SecurityFilterChain`. В этом бине конфигурируется:
            *   Отключение CSRF: `http.csrf(AbstractHttpConfigurer::disable)`.
            *   Управление сессиями: `http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`.
            *   Правила доступа к эндпоинтам (`http.authorizeHttpRequests`):
                *   Разрешение публичного доступа (`.permitAll()`) к `POST /user` (регистрация) и `POST /auth/login` (логин).
                *   Требование аутентификации (`.authenticated()`) для всех остальных запросов (например, `/tasks/**`, `GET /user`).
            *   Добавление кастомного `JwtAuthenticationFilter` (см. п.2) перед стандартным фильтром `UsernamePasswordAuthenticationFilter` Spring Security.
            *   Настройка `AuthenticationEntryPoint` (см. п.5) для обработки ошибок при попытке доступа неаутентифицированного пользователя к защищенным ресурсам.
            *   Настройка `AccessDeniedHandler` (см. п.5) для обработки ошибок авторизации аутентифицированного пользователя.
            *   Конфигурация CORS.
        *   Определяет бин `PasswordEncoder` (например, `BCryptPasswordEncoder`).
        *   Определяет бин `AuthenticationManager` (через `AuthenticationConfiguration`).

    2.  **Фильтр Аутентификации JWT (`JwtAuthenticationFilter`):**
        *   Кастомный фильтр (`OncePerRequestFilter`). Извлекает JWT из запроса, валидирует его через `JwtTokenProvider` (см. п.3) и, при успехе, устанавливает `Authentication` в `SecurityContextHolder`.

    3.  **Компоненты для Работы с JWT (`JwtTokenProvider`):**
        *   Сервисный класс, ответственный за генерацию JWT (на основе `UserDetails` или `userId`/`email`), валидацию JWT (подпись, срок действия), извлечение claims (включая `userId`), а также за формирование объекта `Authentication` на основе валидного JWT. Использует секретный ключ и время жизни токена из конфигурации.

    4.  **Компоненты Пользовательских Данных и Аутентификации:**
    *   **`UserDetailsServiceImpl`:** Реализация `UserDetailsService`. Загружает пользователя из `UserRepository` по `email` (для процесса логина, вызывается `AuthenticationManager`). Создает и возвращает `AppUserDetails`.
    *   **`AppUserDetails`:** Кастомная реализация `UserDetails`. Хранит `id` пользователя (для `principal.id` в SpEL), `email` (используемый как username), хешированный пароль, authorities/roles (если/когда они появятся).
    *   **`AuthService`:** Сервисный класс, инкапсулирующий логику:
        *   **Регистрации:** Принимает DTO с данными регистрации, выполняет валидацию, вызывает `PasswordEncoder` для хеширования пароля, сохраняет пользователя через `UserRepository`, вызывает `JwtTokenProvider` для генерации токена (для авто-логина). В случае ошибок валидации (например, неверный формат email, несовпадение паролей) или бизнес-логики (например, email уже занят) **выбрасывает специфичные кастомные исключения** (например, `UserRegistrationValidationException`, `EmailAlreadyExistsException`).
        *   **Логина:** Принимает DTO с кредам. Делегирует фактическую проверку кредов `AuthenticationManager`. `AuthenticationManager` (используя `UserDetailsServiceImpl` и `PasswordEncoder`) в случае неверных кредов **выбрасывает исключения типа `AuthenticationException`** (например, `BadCredentialsException`). `AuthService` обрабатывает результат от `AuthenticationManager` и, при успехе, вызывает `JwtTokenProvider` для генерации токена.

    5.  **Обработка Ошибок API (согласно RFC 9457 `application/problem+json`):**
        *   **Ошибки на публичных эндпоинтах (регистрация, логин):**
            *   Обрабатываются через механизм `@ControllerAdvice` и `@ExceptionHandler`, который ловит кастомные исключения, выброшенные `AuthService` (например, `EmailAlreadyExistsException`, `ValidationException`) или стандартные исключения Spring Security (например, `BadCredentialsException`).
            *   Формируют HTTP-ответы с соответствующими статус-кодами (400, 401, 409) и телом `application/problem+json`.
        *   **Ошибки доступа к защищенным ресурсам:**
            *   **`CustomAuthenticationEntryPoint`:** Реализует `AuthenticationEntryPoint`. Вызывается, когда неаутентифицированный пользователь пытается получить доступ к защищенному ресурсу. Формирует HTTP-ответ `401 Unauthorized` с заголовком `WWW-Authenticate: Bearer realm="task-tracker"` и телом `application/problem+json`.
            *   **`CustomAccessDeniedHandler`:** Реализует `AccessDeniedHandler`. Вызывается, когда аутентифицированный пользователь пытается получить доступ к ресурсу, на который у него нет прав. Формирует HTTP-ответ `403 Forbidden` или `404 Not Found` (в зависимости от стратегии, см. ADR-0019) с телом `application/problem+json`.

    6.  **Компоненты Авторизации:**
        *   **`PermissionService`:** Spring Bean для инкапсуляции сложных/переиспользуемых правил авторизации, вызываемый из SpEL в аннотациях `@PreAuthorize`.
        *   **Репозитории (например, `TaskRepository`):** Содержат методы с Security Expressions в `@Query` (`?#{ principal.id }`) для реализации авторизации по владению при чтении данных (согласно ADR-0019).

*   **Взаимодействие Компонентов (Общее описание):**
    *   Запросы к публичным эндпоинтам регистрации/логина обрабатываются соответствующими контроллерами и `AuthService`. Ошибки обрабатываются через `@ControllerAdvice`.
    *   Запросы к защищенным эндпоинтам проходят через `JwtAuthenticationFilter` для установления `Authentication` объекта в `SecurityContext`.
    *   Method Security (`@PreAuthorize`) использует `Authentication` (включая `principal.id`) и `PermissionService` для принятия решений об авторизации перед выполнением методов сервисного слоя.
    *   Сервисный слой взаимодействует с "безопасными по умолчанию" репозиториями.
    *   Ошибки аутентификации на защищенных путях обрабатываются `CustomAuthenticationEntryPoint`. Ошибки авторизации – `CustomAccessDeniedHandler`.

*   **Рассмотренные Альтернативы (для архитектуры компонентов):**

    1.  **Использование стандартных механизмов Spring Security без значительной кастомизации:**
        *   **Причина отказа:** Недостаточная гибкость для реализации всех принятых решений по JWT, авторизации по владению и стандартизированной обработке ошибок.

    2.  **Перенос всей логики JWT и аутентификации в отдельный микросервис (Auth Server):**
        *   **Причина отказа (на данном этапе):** Избыточная сложность для текущих целей и масштаба проекта. Выбранная архитектура оставляет возможность для такого перехода в будущем.

    3.  **Реализация аутентификации/авторизации "с нуля" без Spring Security:**
        *   **Причина отказа:** Нецелесообразно, трудоемко и рискованно, учитывая наличие Spring Security.

    4.  **Различные способы организации компонентов авторизации (альтернативы комбинации "безопасных репозиториев" и `PermissionService`):**
        *   **Только `PermissionService` для всей авторизации:** Менее эффективно для фильтрации списков, теряется преимущество "безопасных по умолчанию" репозиториев.
        *   **Только Security Expressions в `@Query` для всей авторизации:** Сложно для комплексных правил.
        *   **Обоснование выбранного подхода:** Комбинация "безопасных репозиториев" и `PermissionService` обеспечивает баланс чистоты кода, безопасности по умолчанию и гибкости.

*   **Последствия и Рекомендации:**
    *   Требуется тщательное модульное и интеграционное тестирование всех компонентов безопасности и их взаимодействий.
    *   Особое внимание уделить корректной передаче и использованию `userId` (`principal.id`) на всех уровнях для обеспечения авторизации по владению.
    *   Документировать потоки аутентификации и авторизации с помощью диаграмм:
        *   **C4 Model (Уровень 3 - Компоненты):** для отображения статической структуры компонентов безопасности в `task-tracker-backend`.
        *   **Sequence Diagrams:** для иллюстрации ключевых динамических сценариев взаимодействия (регистрация, логин, успешный/неуспешный доступ к защищенным ресурсам).

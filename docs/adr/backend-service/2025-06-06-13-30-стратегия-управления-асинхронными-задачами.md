# ADR-0037: Стратегия Управления Асинхронными Задачами и Пулами Потоков

*   **Статус:** Accepted
*   **Дата:** 2025-06-06

## 1. Контекст

Приложению `task-tracker-backend` требуется централизованная стратегия для управления асинхронными задачами (`@Async`, `CompletableFuture`). Использование дефолтного `Executor`'а Spring Boot не обеспечивает необходимой изоляции, наблюдаемости и возможности тюнинга для различных типов нагрузок (CPU-bound, I/O-bound).

## 2. Принятое Решение

**2.1. Централизованная Конфигурация:**
Все `Executor`'ы определяются как бины в централизованном конфигурационном классе (`AppConfig`). Использование дефолтного `@Async` executor'а Spring Boot **ЗАПРЕЩЕНО**. Разработчик, используя `@Async`, **ОБЯЗАН** явно указать имя бина `Executor`'а.

**2.2. Классификация `Executor`'ов по Типу Нагрузки:**
В приложении определяется несколько именованных пулов потоков, каждый из которых предназначен для своего типа задач:

1.  **CPU-Bound Executor (`applicationCpuExecutor`):**
    *   **Назначение:** Задачи, интенсивно использующие CPU.
    *   **Конфигурация:** Размер пула (`maxPoolSize`) не превышает количество ядер процессора.

2.  **I/O-Bound Executor (`applicationIoExecutor`):**
    *   **Назначение:** Блокирующие I/O операции (например, вызовы внешних HTTP API).
    *   **Конфигурация:** Размер пула (`maxPoolSize`) может значительно превышать количество ядер процессора.

3.  **Kafka-Specific Executor (`kafkaAsyncOperationsExecutor`):**
    *   **Назначение:** Исключительно для асинхронных операций, связанных с Kafka (инициация отправки, обработка коллбэков).
    *   **Конфигурация:** Настраивается как I/O-bound (`maxPoolSize > processors`).

**2.3. Единые Требования ко всем `Executor`'ам:**
*   **Мониторинг:** Каждый `Executor` регистрируется в `MeterRegistry` для сбора метрик Micrometer.
*   **Контекст:** Каждый `Executor` оборачивается для проброса MDC (`MdcTaskDecorator`) и OpenTelemetry (`Context.taskWrapping`).
*   **Именование:** Каждый `Executor` имеет осмысленный `threadNamePrefix`.
*   **Завершение:** Каждый `Executor` настроен на корректное завершение (`graceful shutdown`).

## 3. Обоснование и Рассмотренные Альтернативы

**3.1. Обоснование выделения `kafkaAsyncOperationsExecutor`:**
Взаимодействие с Kafka выделяется в отдельный пул для **изоляции ресурсов**, **независимого тюнинга** и **целевой наблюдаемости**. Это предотвращает блокировку отправки Kafka-сообщений другими долгими I/O-задачами и позволяет мониторить здоровье именно этой подсистемы через ее собственный набор метрик.

**3.2. Управление Конкуренцией за Ресурсы:**
Хотя все `Executor`'ы делят общие ресурсы CPU, классификация по типу нагрузки решает эту проблему. CPU-bound пулы строго ограничены количеством ядер. I/O-bound пулы имеют больше потоков, но большинство из них находятся в состоянии ожидания, не потребляя активно CPU. Это стандартный паттерн для эффективного управления ресурсами в приложениях со смешанной нагрузкой.

**3.3. Рассмотренные Альтернативы:**
*   **Один большой общий `Executor`:** Отвергнуто из-за отсутствия изоляции и возможности тюнинга.
*   **`Executor` для каждой фичи:** Отвергнуто, так как классификация по характеристикам задачи (CPU/IO) более фундаментальна для управления ресурсами.

## 4. Последствия

*   **Положительные:**
    *   Создается централизованная и понятная стратегия управления асинхронными задачами.
    *   Изоляция ресурсов и оптимальное их использование благодаря разделению пулов по типу нагрузки.
    *   Улучшенная наблюдаемость за счет отдельных метрик для каждого пула.
*   **Отрицательные/Затраты:**
    *   Увеличивается сложность `AppConfig`.
    *   Требует от разработчиков дисциплины и понимания, какой `Executor` выбрать.
    *   Необходимо проводить нагрузочное тестирование для окончательного тюнинга размеров пулов.
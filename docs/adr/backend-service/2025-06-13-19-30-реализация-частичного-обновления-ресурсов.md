# ADR-0038: Реализация частичного обновления ресурсов с использованием JSON Merge Patch и оптимистической блокировки

*   **Статус:** Принят
*   **Дата:** 2025-06-12
*   **Связанные ADR:**
    *   ADR-0019: Механизмы авторизации доступа к ресурсам
    *   ADR-0020: Архитектура Компонентов Безопасности
    *   ADR-0029: Определение Архитектуры Слоя Персистентности
    *   ADR-0030: Архитектура сущности Task, ее API и связанных компонентов
    *   ADR-0034: Стандарты интеграционного тестирования API контроллеров

## 1. Контекст

В ходе разработки фронтенда для управления задачами была выявлена неэффективность использования `PUT`-запроса для частичных обновлений. `PUT` требует от клиента отправки полного представления ресурса, даже если изменилось только одно поле. Это неудобно для реализации "live save" и приводит к избыточному трафику.

Кроме того, существует риск **"потерянных обновлений" (lost updates)**. Этот риск возникает, когда одна и та же сущность загружается в двух разных контекстах (например, в двух разных вкладках браузера одного пользователя), затем оба контекста инициируют обновление на основе устаревших данных, и последнее обновление затирает изменения предыдущего. Необходимо внедрить механизм для предотвращения таких конфликтов.

Цель — определить стандартный, гибкий и надежный способ частичного обновления ресурсов (на примере `Task`) и обработки конкурентного доступа.

## 2. Принятое Решение

Для реализации частичного обновления ресурсов будет использоваться комбинация стандарта **JSON Merge Patch (RFC 7396)** и механизма **оптимистической блокировки**.

**2.1. Стандарт JSON Merge Patch:**

*   Для частичных обновлений будет использоваться HTTP-метод `PATCH`.
*   Клиент должен отправлять `Content-Type: application/merge-patch+json`.
*   Тело запроса представляет собой JSON-объект, содержащий **только те поля, которые были изменены**.
*   Для очистки (установки в `null`) опционального поля (например, `description`) клиент должен явно передать это поле со значением `null`.

**2.2. Оптимистическая Блокировка:**

*   **На уровне Сущности:** В JPA-сущности, подлежащие конкурентному обновлению (например, `Task`), добавляется поле версии (например, `private int version;`), которое автоматически управляется фреймворком персистентности (например, с помощью аннотации `@Version`).
*   **На уровне API:**
    *   Поле `version` **обязательно** включается в DTO для ответов (`TaskResponse`).
    *   Клиент, отправляя запрос на изменение данных (`PATCH` или `PUT`), **обязан** включить в тело запроса поле `version` с тем значением, которое он получил при последней загрузке/обновлении ресурса.
    *   **На бэкенде:** Сервер, получая запрос на изменение, должен проверить, что версия, предоставленная клиентом, совпадает с текущей версией ресурса в базе данных. Если версии не совпадают, сервер **должен** отклонить запрос и вернуть HTTP-ответ `409 Conflict`.

**2.3. Контракт API (на примере `Task`):**

*   **Эндпоинт:** `PATCH /api/v1/tasks/{taskId}`
*   **Заголовок:** `Content-Type: application/merge-patch+json`
*   **Тело запроса (Пример):**
    ```json
    {
      "title": "Очень важный новый заголовок",
      "version": 2
    }
    ```
*   **Успешный ответ (`200 OK`):**
    *   Тело: **Полный** объект `TaskResponse`, содержащий все поля ресурса после обновления, включая **новую, инкрементированную `version`**.
*   **Ответ при конфликте (`409 Conflict`):**
    *   **Причина:** Предоставленная в запросе `version` не совпадает с текущей версией задачи в БД.
    *   **Тело (`ProblemDetail`):**
        ```json
        {
          "type": "https://task-tracker.example.com/probs/resource-conflict",
          "title": "Resource Conflict",
          "status": 409,
          "detail": "The resource was modified by another request. Please fetch the latest version and try again.",
          "instance": "/api/v1/tasks/123",
          "properties": {
            "conflictingResourceId": 123
          }
        }
        ```
    *   **Действия клиента:** При получении `409` клиент должен уведомить пользователя о конфликте и выполнить `GET`-запрос для получения актуальной версии ресурса.

## 3. Рассмотренные Альтернативы

1.  **JSON Patch (RFC 6902):**
    *   **Описание:** Более мощный стандарт, описывающий последовательность операций ("add", "replace", "remove", "copy", "move", "test").
    *   **Минусы:** Избыточная сложность для наших текущих потребностей (простое обновление полей).
    *   **Причина отклонения:** JSON Merge Patch проще в реализации как на клиенте, так и на сервере, и полностью покрывает наши сценарии.

2.  **Пессимистическая блокировка:**
    *   **Описание:** Блокировка записи в БД на время ее редактирования пользователем.
    *   **Минусы:** Плохо масштабируется в веб-приложениях, может приводить к долгим блокировкам и дедлокам, усложняет логику.
    *   **Причина отклонения:** Не подходит для stateless REST API.

3.  **Возврат полного объекта в теле ответа `409 Conflict`:**
    *   **Описание:** Включить актуальное состояние ресурса в ответ при конфликте, чтобы избавить клиента от дополнительного `GET`-запроса.
    *   **Минусы:** (1) Риск безопасности: можно случайно вернуть данные, на которые у пользователя уже нет прав после изменения. (2) Нарушение простоты и семантики REST.
    *   **Причина отклонения:** Безопасность и чистота архитектуры важнее, чем избавление от одного дополнительного запроса в редком сценарии конфликта.

## 4. Последствия

*   **Положительные:**
    *   Реализован гибкий и эффективный механизм частичного обновления.
    *   API защищено от "потерянных обновлений" благодаря оптимистической блокировке.
    *   Контракт API стандартизирован и понятен для клиентов.

*   **Отрицательные/Затраты:**
    *   **Backend:** Требуется добавить зависимость для обработки JSON Merge Patch, добавить поле версии в сущность `Task` и DTO, а также реализовать логику обработки `PATCH`-запроса и обнаружения конфликта версий.
    *   **Frontend:** Требуется реализовать логику для отслеживания `version`, формирования `PATCH`-запроса и обработки ответа `409 Conflict` (включая повторный `GET`-запрос).

*   **Влияние на другие эндпоинты (`PUT`):**
    *   Для обеспечения консистентности, механизм оптимистической блокировки (передача и проверка поля `version`) **должен быть также применен ко всем `PUT`-запросам**, которые обновляют сущности с полем версии. Это означает, что `TaskUpdateRequest` также должен будет включать поле `version`. `PUT /tasks/{taskId}` теперь также будет возвращать `409 Conflict` в случае несовпадения версий. Это предотвратит "потерянные обновления" и при полном обновлении ресурса.

*   **Необходимые действия:**
    *   Добавить поле `@Version` в `Task.java` и `version` в `TaskResponse.java`.
    *   Добавить поле `version` в `TaskUpdateRequest.java` и DTO для `PATCH`.
    *   Реализовать `PATCH /api/v1/tasks/{taskId}` в `TaskController` и `TaskService`.
    *   Обновить `PUT /api/v1/tasks/{taskId}` для включения проверки версии.
    *   Гарантировать обработку исключения, сигнализирующего о конфликте версий, и преобразование его в `409 Conflict`.
    *   Обновить OpenAPI документацию для `PATCH` и `PUT` эндпоинтов.
    *   Написать интеграционные тесты, покрывающие успешный `PATCH`/`PUT` и сценарии `409 Conflict` для обоих методов.
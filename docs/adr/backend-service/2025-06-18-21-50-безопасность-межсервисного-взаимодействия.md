# ADR-0039: Безопасность Межсервисного Взаимодействия

*   **Статус:** Принят
*   **Дата:** 2025-06-18
*   **Связанные ADR:**
    *   ADR-0022: Управление Конфигурационными Свойствами и Безопасность Секретов

## 1. Контекст

С введением сервиса `task-tracker-scheduler`, который должен взаимодействовать с `task-tracker-backend` через API, возникает необходимость в механизме аутентификации "сервис-сервис". Публичные эндпоинты, предназначенные для пользователей (защищенные JWT), не подходят для внутреннего взаимодействия. Необходимо обеспечить, чтобы только доверенные внутренние сервисы (такие как `scheduler`) могли получать доступ к специализированным внутренним API-эндпоинтам (например, `/api/v1/internal/**`).

## 2. Принятое Решение

Для аутентификации внутренних сервисов будет использоваться механизм на основе **статического API-ключа (API Key)**, передаваемого в HTTP-заголовке.

1.  **Схема Аутентификации:**
    *   Сервис-клиент (например, `scheduler`) при каждом запросе к внутреннему API `backend`'а **должен** включать HTTP-заголовок `X-API-Key` со значением секретного ключа.
    *   Сервис-сервер (`backend`) **должен** проверять наличие и корректность этого заголовка для всех запросов к эндпоинтам, находящимся в пространстве имен `/api/v1/internal/**`.

2.  **Реализация на Стороне `task-tracker-backend`:**
    *   Будет создан кастомный фильтр Spring Security (`ApiKeyAuthFilter`), который будет выполняться для путей `/api/v1/internal/**`.
    *   Фильтр будет извлекать значение из заголовка `X-API-Key` и сравнивать его с эталонным значением, хранящимся на сервере.
    *   Сравнение ключей должно производиться с использованием метода, устойчивого к "timing attacks" (атакам по времени), например, `MessageDigest.isEqual()`.
    *   Если ключ отсутствует или неверный, фильтр должен прерывать цепочку и возвращать ответ **HTTP 401 Unauthorized** (или **403 Forbidden**, если семантически более уместно) с `ProblemDetail`.

3.  **Управление Ключом:**
    *   API-ключ является **секретом**.
    *   Он **должен** генерироваться как криптографически случайная, длинная строка.
    *   На стороне `backend` (сервер) и `scheduler` (клиент) ключ **должен** предоставляться через переменные окружения и читаться в приложении через `@Value` или `@ConfigurationProperties` (согласно ADR-0022).
    *   **ЗАПРЕЩАЕТСЯ** хранить API-ключ в открытом виде в `application.yml` или коммитить его в систему контроля версий. Для локальной разработки (`dev`/`ci` профили) ключ может быть задан в `.env` файлах или профилях запуска IDE.

4.  **Разделение Конфигурации Безопасности:**
    *   Конфигурация `SecurityFilterChain` в `SecurityConfig` будет разделена для обработки разных путей:
        *   Один набор правил (с `JwtAuthenticationFilter`) будет применяться к публичным пользовательским API (`/api/v1/**`, исключая `/internal`).
        *   Второй, более строгий набор правил (с `ApiKeyAuthFilter`), будет применяться к `/api/v1/internal/**`.

## 3. Рассмотренные Альтернативы

1.  **Аутентификация по mTLS (Mutual TLS):**
    *   **Описание:** Клиент и сервер аутентифицируют друг друга с помощью TLS-сертификатов.
    *   **Плюсы:** Очень высокий уровень безопасности.
    *   **Минусы:** Значительно сложнее в настройке и управлении (требуется инфраструктура PKI, управление жизненным циклом сертификатов). Избыточно для нашего текущего уровня проекта.
    *   **Причина отклонения:** Чрезмерная сложность для текущих целей.

2.  **JWT с Grant Type `client_credentials`:**
    *   **Описание:** Использовать стандартный OAuth 2.0 флоу, где `scheduler` получает JWT, аутентифицируясь по `client_id` и `client_secret`.
    *   **Плюсы:** Стандартизированный, гибкий подход.
    *   **Минусы:** Требует наличия или реализации Identity/Authorization Server'а для выдачи токенов. Усложняет архитектуру, добавляя еще одну точку отказа.
    *   **Причина отклонения:** Избыточная сложность для простого внутреннего взаимодействия между двумя доверенными сервисами.

3.  **IP Whitelisting:**
    *   **Описание:** Разрешать доступ к внутренним API только с определенных IP-адресов.
    *   **Плюсы:** Просто в реализации на уровне сетевой инфраструктуры.
    *   **Минусы:** Хрупко (IP-адреса могут меняться, особенно в облачных/контейнерных средах), не обеспечивает аутентификацию самого приложения, а только его местоположения. Небезопасно, если в той же сети есть другие, менее доверенные сервисы.
    *   **Причина отклонения:** Недостаточный уровень безопасности и гибкости.

## 4. Последствия

*   **Положительные:**
    *   Простой, но достаточно надежный механизм для защиты внутреннего API.
    *   Четкое разделение доступа для внешних (пользовательских) и внутренних (сервис-сервис) вызовов.
    *   Легко реализуется и управляется в рамках Spring Security и переменных окружения.
*   **Отрицательные/Затраты:**
    *   **Безопасность ключа:** Вся безопасность системы зависит от того, насколько хорошо защищен статический API-ключ. Требуется строгая дисциплина в управлении этим секретом.
    *   **Ротация ключей:** Ручная. В production-среде потребуются процедуры для безопасной смены ключа на всех сервисах без простоя.
    *   Не предоставляет гранулярного контроля доступа (скоупов), как OAuth 2.0. Все, кто знает ключ, имеют одинаковый доступ к внутреннему API.
*   **Необходимые действия:**
    *   Сгенерировать безопасный API-ключ.
    *   Настроить переменные окружения для `backend` и `scheduler` сервисов.
    *   Реализовать `ApiKeyAuthFilter` и обновить `SecurityConfig` в `task-tracker-backend`.
    *   Реализовать добавление заголовка `X-API-Key` в API-клиенте сервиса `task-tracker-scheduler`.
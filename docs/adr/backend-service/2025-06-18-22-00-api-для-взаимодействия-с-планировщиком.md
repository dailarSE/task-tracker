# ADR-0041: API для Взаимодействия с Сервисом-Планировщиком

*   **Статус:** Принят
*   **Дата:** 2025-06-18
*   **Связанные ADR:** ADR-0039 (Безопасность межсервисного взаимодействия), ADR-0040 (Архитектура планировщика).
*   **Контекст:** Сервис `task-tracker-backend` является владельцем данных и должен предоставлять их внешним системам, таким как `task-tracker-scheduler`. Необходимо спроектировать внутренний API, который будет эффективным, безопасным и минимизирует нагрузку на базу данных.
*   **Принятое Решение:**
    1.  **Выделенное Пространство Имен:** Все внутренние, не предназначенные для публичного использования эндпоинты, размещаются в пространстве имен `/api/v1/internal/**`.
    2.  **Безопасность:** Доступ к этому пространству имен защищен через механизм API-ключей (как определено в ADR-0039).
    3.  **Разделение API на два этапа (для поддержки паттерна Producer/Consumer в планировщике):**
        *   **Эндпоинт для "Производителя" (`GET /.../user-ids-for-processing`):** Предоставляет высокопроизводительный способ получения списка ID всех пользователей, подлежащих обработке. Использует keyset-пагинацию для эффективности.
        *   **Эндпоинт для "Потребителей" (`POST /.../user-task-reports-by-ids`):** Принимает на вход список ID и возвращает готовые, агрегированные отчеты по задачам для этой пачки пользователей.
    4.  **Оптимизация на стороне БД:** Бэкенд берет на себя всю ответственность за сложную SQL-логику. Эндпоинт для потребителей должен выполнять **один** оптимизированный SQL-запрос, который переносит всю фильтрацию, сортировку, лимитирование и агрегацию на сторону PostgreSQL. Это минимизирует количество запросов к БД и объем передаваемых данных.
*   **Рассмотренные Альтернативы:**
    *   **Один "тяжелый" API с пагинацией:** Отвергнуто, так как это привело бы к неэффективному последовательному исполнению в планировщике.
    *   **Предоставление "сырых" данных задач и группировка на стороне планировщика:** Отвергнуто, так как это нарушает принцип "умных эндпоинтов" и перекладывает ответственность за обработку данных на клиента.
*   **Последствия:**
    *   API идеально соответствует потребностям параллельного и отказоустойчивого планировщика.
    *   Бэкенд инкапсулирует сложную логику запросов, предоставляя простой контракт.
    *   Требуется реализация двух новых эндпоинтов и сложного SQL-запроса на бэкенде.
# ADR-0008: Использование Testcontainers для интеграционных тестов базы данных

**Статус:** Accepted

**Дата:** 2025-05-08

## Контекст

Для обеспечения качества и надежности слоя персистентности в `task-tracker-backend` необходимо проводить интеграционное тестирование взаимодействия с базой данных (PostgreSQL). Тесты должны выполняться в окружении, максимально приближенном к продакшен-среде, и быть воспроизводимыми как локально у разработчиков, так и на CI-сервере.

Существуют различные подходы к настройке базы данных для интеграционных тестов: использование in-memory баз данных (например, H2), подключение к общей разделяемой тестовой БД или использование эфемерных экземпляров БД, управляемых тестами.

## Принятое Решение

Использовать **Testcontainers** для проведения интеграционных тестов слоя персистентности (в частности, для тестирования Spring Data JPA репозиториев).

Testcontainers будут использоваться для запуска Docker-контейнера с PostgreSQL непосредственно из кода тестов. Каждый тестовый класс (или тестовый набор) будет работать с чистым, изолированным экземпляром базы данных. Интеграция со Spring Boot будет осуществляться с помощью `spring-boot-testcontainers` и аннотации `@ServiceConnection` для автоматической настройки `DataSource`.

## Рассмотренные Альтернативы

1.  **In-memory база данных (например, H2 в режиме эмуляции PostgreSQL):**
    *   **Описание:** Использование легковесной встраиваемой базы данных H2, настроенной на эмуляцию синтаксиса PostgreSQL.
    *   **Плюсы:** Быстрый запуск тестов, отсутствие внешней зависимости от Docker.
    *   **Минусы:**
        *   Эмуляция не всегда полная. Могут быть отличия в поведении SQL, типах данных, функциях, ограничениях по сравнению с реальным PostgreSQL.
        *   Не тестируется работа с реальным драйвером PostgreSQL JDBC.
        *   Миграции Liquibase, написанные для PostgreSQL, могут не работать или работать некорректно с H2.
    *   **Причина отклонения:** Не обеспечивает достаточной уверенности в корректности работы с целевой СУБД (PostgreSQL). Риск расхождения поведения между тестовой и продакшен-средой.

2.  **Общая разделяемая тестовая база данных (Shared Test Database):**
    *   **Описание:** Все разработчики и CI-сервер используют один или несколько общих экземпляров PostgreSQL, выделенных для тестирования.
    *   **Плюсы:** Используется реальная СУБД.
    *   **Минусы:**
        *   Сложность управления состоянием БД между тестовыми запусками. Тесты могут влиять друг на друга из-за оставшихся данных.
        *   Требует дополнительной инфраструктуры и администрирования.
        *   Медленный цикл обратной связи, если тесты должны ждать очистки или подготовки БД.
        *   Параллельный запуск тестов на CI может быть затруднен.
    *   **Причина отклонения:** Проблемы с изоляцией тестов и сложность управления.

3.  **Внешний Docker-контейнер PostgreSQL, управляемый вручную или через `docker-compose` для тестов:**
    *   **Описание:** Перед запуском тестов разработчик или CI-скрипт запускает Docker-контейнер с PostgreSQL. Тесты подключаются к нему.
    *   **Плюсы:** Используется реальная СУБД в Docker.
    *   **Минусы:**
        *   Управление жизненным циклом контейнера (запуск, остановка, очистка данных) ложится на разработчика или CI-скрипты, что менее удобно и надежно.
        *   Сложнее обеспечить изоляцию данных, если контейнер не пересоздается для каждого тестового набора.
    *   **Причина отклонения:** Testcontainers предоставляют более элегантное и интегрированное решение для управления жизненным циклом Docker-контейнеров из кода тестов.

## Последствия

*   **Положительные:**
    *   **Высокая степень соответствия тестовой среды продакшену:** Тесты выполняются на реальном PostgreSQL, запущенном в Docker.
    *   **Изоляция тестов:** Каждый тестовый запуск (или класс) может использовать свой чистый экземпляр БД, что предотвращает влияние тестов друг на друга.
    *   **Воспроизводимость:** Тесты ведут себя одинаково локально и на CI.
    *   **Автоматическое управление ресурсами:** Testcontainers управляют запуском и остановкой контейнеров.
    *   **Простая интеграция со Spring Boot:** Благодаря `spring-boot-testcontainers` и `@ServiceConnection`.
    *   Liquibase миграции применяются к реальной PostgreSQL в тестах.
*   **Отрицательные/Затраты:**
    *   **Зависимость от Docker:** Docker должен быть установлен и доступен в среде выполнения тестов (локально у разработчика, на CI-агенте).
    *   **Время запуска тестов:** Запуск Docker-контейнера может занимать некоторое время, что может замедлить выполнение тестов по сравнению с in-memory базами. Однако, использование статических контейнеров на уровне класса может минимизировать этот эффект.
    *   Необходимо добавить зависимости Testcontainers в `pom.xml`.
*   **Необходимые действия:**
    *   Добавить соответствующие Testcontainers зависимости.
    *   Настроить CI-агент для работы с Docker.
    *   Написать интеграционные тесты, используя аннотации `@Testcontainers`, `@Container`, `@ServiceConnection`.
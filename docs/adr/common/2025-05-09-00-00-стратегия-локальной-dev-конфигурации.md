# ADR-0010: Стратегия конфигурации локального dev-окружения с использованием Docker Compose и Spring Boot профилей

**Статус:** Accepted

**Дата:** 2025-05-09

## 1. Контекст

Для эффективной локальной разработки и отладки сервиса `task-tracker-backend` и его будущих зависимостей (Kafka, стек обсервабилити) необходимо простое и воспроизводимое окружение. Разработчики должны иметь возможность быстро запускать все необходимые инфраструктурные компоненты и подключать к ним приложение, запущенное из IDE.

## 2. Принятое Решение

1.  **Инфраструктура через `docker-compose.yml`:** Все внешние зависимости для локальной разработки (PostgreSQL, Kafka, OTel Collector, Prometheus, Grafana, Loki, Tempo) определяются и запускаются через единый `docker-compose.yml` файл в корне проекта.
2.  **Spring Boot профиль `dev`:**
    *   Приложение `task-tracker-backend`, запущенное из IDE, использует профиль `dev` (активируется через VM Option `-Dspring.profiles.active=dev`).
    *   **`application-dev.yml`:**
        *   URL для подключения к PostgreSQL: `jdbc:postgresql://postgres:5432/task_tracker_db` (при наличии соответствующей записи в `hosts` файле, указывающей на `127.0.0.1`).
        *   Учетные данные для PostgreSQL (`spring.datasource.username`, `spring.datasource.password`): **Жестко прописаны** как `devuser` и `devpass`, чтобы соответствовать конфигурации PostgreSQL в `docker-compose.yml`.
        *   Включено детальное логирование SQL (`show-sql: true`, `format-sql: true`, уровни DEBUG/TRACE для Hibernate).
        *   OTel SDK включен, сэмплирование трейсов 100%.
        *   Эндпоинт OTel Collector для отправки телеметрии: `http://otel-collector:4318` (предполагая, что порт OTel Collector проброшен на хост).
3.  **Разрешение имен сервисов:** Для удобства подключения к сервисам, запущенным в Docker, из приложения на хосте (если используется имя сервиса, а не `localhost`), разработчики могут добавить соответствующие записи в свой локальный `hosts` файл (например, `127.0.0.1 postgres`, `127.0.0.1 otel-collector`).

## 3. Рассмотренные Альтернативы

1.  **Чтение dev-кредов из переменных окружения хоста для Spring Boot:**
    *   **Описание:** `application-dev.yml` считывает `spring.datasource.username=${POSTGRES_USER}` и `password=${POSTGRES_PASSWORD}`.
    *   **Плюсы:** Не коммитятся креды, гибкость.
    *   **Минусы:** Требует от каждого разработчика установки этих переменных окружения перед запуском из IDE. Незначительно усложняет первый запуск.
    *   **Причина отклонения (в пользу хардкода в `application-dev.yml`):** Для максимального упрощения dev-опыта на данном этапе выбран хардкод согласованных dev-кредов, которые также используются в `docker-compose.yml`.

3.  **Полностью изолированные Docker-контейнеры для всего, включая приложение бэкенда, даже для разработки:**
    *   **Описание:** Разработчик запускает `docker-compose up` и работает с приложением, уже запущенным в контейнере. Отладка через удаленный отладчик.
    *   **Плюсы:** Максимальное соответствие окружений.
    *   **Минусы:** Более медленный цикл разработки (пересборка образа при изменениях), сложнее отладка "на лету" из IDE.
    *   **Причина отклонения:** Для текущего этапа предпочтительнее более быстрый цикл разработки с запуском приложения напрямую из IDE.

## 4. Последствия

*   **Положительные:**
    *   Значительно упрощен запуск и настройка локального dev-окружения.
    *   Устранены проблемы с аутентификацией PostgreSQL при локальной разработке.
    *   Разработчики могут быстро поднять все зависимости одной командой `docker-compose up -d`.
    *   Конфигурация `dev` профиля ясна и предсказуема.
*   **Отрицательные/Затраты:**
    *   Наличие одинаковых кредов в `docker-compose.yml` и `application-dev.yml` требует их синхронного изменения, если они когда-либо поменяются для `dev`.
*   **Необходимые действия:**
    *   Обновить `application-dev.yml` для использования этих же жестко прописанных кредов и URL на `localhost` (или имя из `hosts` файла).
    *   Убедиться, что команда документировала этот подход.
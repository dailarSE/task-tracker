# ADR-0011: Обеспечение консистентности времени через использование UTC во всех компонентах системы

**Статус:** Accepted

**Дата:** 2025-05-09

## 1. Контекст

В распределенных системах, а также в системах, где пользователи могут находиться в разных часовых поясах, обработка и хранение времени может стать источником сложных ошибок и аномалий. Неправильная конвертация между часовыми поясами, неоднозначная интерпретация временных меток (timestamp) без указания пояса, а также проблемы с переходом на летнее/зимнее время могут приводить к некорректной работе бизнес-логики, ошибкам в данных и сложностям при отладке и анализе логов.

Проект "Task Tracker" включает сохранение временных меток (создание/обновление пользователей и задач, выполнение задач) и потенциально будет использоваться пользователями из разных часовых поясов.

## 2. Принятое Решение

1.  **Стандартный Часовой Пояс для Серверной Логики и Хранения:** Все серверные компоненты (приложение `task-tracker-backend`, база данных PostgreSQL, в будущем другие микросервисы) должны работать и хранить все временные метки в **UTC (Coordinated Universal Time)**.
2.  **Конфигурация JVM:** Для приложения `task-tracker-backend` при запуске из IDE (в `dev` профиле) и при выполнении тестов на CI-агенте (через Maven Surefire Plugin) будет установлена системная переменная JVM `-Duser.timezone=UTC`. *Примечание: Настройка для Docker-контейнера приложения отложена до этапа контейнеризации.*
3.  **Конфигурация Базы Данных (PostgreSQL):**
    *   Сервер PostgreSQL (запускаемый в Docker) по умолчанию инициализируется и работает в часовом поясе UTC. Это поведение будет сохранено.
    *   Для колонок, хранящих временные метки (например, `created_at`, `updated_at` в таблице `users`), используется тип данных **`TIMESTAMP WITH TIME ZONE` (TIMESTAMPTZ)**. В PostgreSQL этот тип данных хранит значение как момент времени в UTC, а при извлечении конвертирует его в часовой пояс сессии клиента (если он отличается).
4.  **Обработка времени в Java-коде:**
    *   Для представления моментов времени в Java-сущностях и DTO используется тип `java.time.Instant`, который всегда представляет собой точку на временной шкале UTC.
    *   Любые операции с датой/временем на сервере, требующие знания текущего момента, должны получать его как момент в UTC (например, через `@CreationTimestamp`, `@UpdateTimestamp` от Hibernate, которые работают с учетом часового пояса JVM, или `Instant.now()`).
5.  **Ответственность Фронтенда за Локальное Время Пользователя:**
    *   **Фронтенд-приложение несет ответственность за определение локального часового пояса пользователя.**
    *   При отправке любых данных, содержащих время, на бэкенд (например, дедлайн задачи), фронтенд должен **конвертировать это локальное время пользователя в UTC** и отправлять на бэкенд уже в UTC (например, в формате ISO 8601 с указанием `Z` или смещения +00:00).
    *   При получении данных от бэкенда (которые всегда будут в UTC), фронтенд несет ответственность за их конвертацию в локальный часовой пояс пользователя для корректного отображения.

## 3. Рассмотренные Альтернативы

1.  **Хранение времени в локальном часовом поясе сервера:**
    *   **Описание:** Сервер и БД работают в каком-то локальном часовом поясе (например, системном поясе сервера).
    *   **Минусы:** Создает неоднозначность, если серверы развернуты в разных поясах или если часовой пояс сервера меняется. Сложности при работе с пользователями из других часовых поясов. Проблемы с летним/зимним временем.
    *   **Причина отклонения:** Ненадежно и подвержено ошибкам.

2.  **Хранение времени в `TIMESTAMP WITHOUT TIME ZONE` с неявным соглашением об UTC:**
    *   **Описание:** Использовать тип `TIMESTAMP` в БД, но всегда записывать и читать его как будто это UTC.
    *   **Минусы:** Зависит от правильной настройки часового пояса JDBC-драйвера, JVM и клиента БД. Любое несоответствие приведет к некорректной интерпретации времени. Тип `TIMESTAMP WITHOUT TIME ZONE` не несет информации о поясе.
    *   **Причина отклонения:** Менее надежно, чем использование `TIMESTAMP WITH TIME ZONE`.

3.  **Бэкенд обрабатывает конвертацию в/из часового пояса пользователя:**
    *   **Описание:** Фронтенд передает время в локальном поясе пользователя + информацию о поясе, а бэкенд конвертирует его в UTC для хранения и обратно при отображении.
    *   **Минусы:** Усложняет бэкенд. Бэкенд должен знать о часовых поясах всех пользователей или получать эту информацию. Фронтенд все равно лучше знает локальный пояс пользователя.
    *   **Причина отклонения:** Перенос ответственности за работу с локальным временем пользователя на фронтенд является более чистым решением.

## 4. Последствия

*   **Положительные:**
    *   **Консистентность:** Все временные метки на сервере и в БД хранятся и обрабатываются в едином стандарте (UTC).
    *   **Устранение неоднозначности:** Момент времени всегда интерпретируется одинаково, независимо от настроек сервера или клиента.
    *   **Упрощение логики на бэкенде:** Бэкенду не нужно заботиться о конвертации часовых поясов пользователей при хранении и основной обработке.
    *   **Корректная работа с пользователями из разных часовых поясов** (при условии правильной работы фронтенда).
    *   **Упрощение анализа логов и данных:** Все временные метки в логах и БД будут в UTC.
*   **Отрицательные/Затраты:**
    *   Необходимо обеспечить установку `-Duser.timezone=UTC` для всех JVM, где запускается бэкенд.
    *   Фронтенд-приложение должно корректно обрабатывать конвертацию времени в/из UTC.
    *   Разработчики должны помнить об этом соглашении при работе с датой/временем.
*   **Необходимые действия:**
    *   Настроить JVM опцию `-Duser.timezone=UTC` для запуска из IDE и в Maven Surefire. (Отложено для Docker-контейнера приложения).
    *   Использовать тип `TIMESTAMPTZ` в миграциях БД.
    *   Использовать `java.time.Instant` в Java-коде для представления времени.
    *   Донести до команды разработки фронтенда требования по работе с временем.
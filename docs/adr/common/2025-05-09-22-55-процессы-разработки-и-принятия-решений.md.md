# ADR-0014: Процессы принятия архитектурных решений, управления задачами и работы с системой контроля версий

**Статус:** Accepted

**Дата:** 2025-05-09

## 1. Контекст

Для эффективной и скоординированной работы команды над проектом "Task Tracker" необходимо определить и формализовать процессы, связанные с:
*   Принятием и документированием архитектурно значимых решений.
*   Декомпозицией требований на фичи и задачи.
*   Работой с системой контроля версий Git (ветвление, коммиты, слияние).
Это поможет обеспечить прозрачность, предсказуемость, качество кода и документации, а также снизить риски, связанные с несогласованными действиями.

## 2. Принятое Решение

**2.1. Процесс Принятия и Документирования Архитектурных Решений (ADR):**
    *   **Идентификация:** Любой член команды может инициировать обсуждение архитектурно значимого вопроса. Тимлид или архитектор определяет, требует ли вопрос формализации в виде ADR.
    *   **Обсуждение:** Решение обсуждается командой (на встречах, в чате, в комментариях к задаче). Рассматриваются различные варианты.
    *   **Формулирование ADR:** Ответственный (обычно тимлид, архитектор или разработчик, глубоко вовлеченный в проблему) создает черновик ADR в соответствии с принятым шаблоном (см. ADR-0013).
    *   **Ревью ADR (неформальное):** Черновик ADR может быть рассмотрен другими членами команды для получения обратной связи.
    *   **Утверждение:** Решение и ADR считаются принятыми после согласования с тимлидом/архитектором. Статус ADR меняется на "Accepted".
    *   **Хранение:** ADR хранится в Git-репозитории в `docs/adr/` и версионируется вместе с кодом.
    *   **Обновление:** Принятые ADR не изменяются. Если решение пересматривается, создается новый ADR, который ссылается на старый и указывает его новый статус (Deprecated, Superseded).

**2.2. Формализация и Выделение Фич/Задач:**
    *   **Источник:** Требования (ТЗ, User Stories), технический долг, предложения по улучшению.
    *   **Декомпозиция:** Крупные фичи разбиваются на более мелкие, управляемые задачи (например, в Jira).
    *   **Приоритезация:** Задачи приоритезируются в рамках бэклога спринта/проекта.
    *   **Связь с ADR:** Если реализация задачи требует принятия архитектурно значимого решения, создается или обновляется соответствующий ADR.

**2.3. Правила Работы с Ветками (GitHub Flow - адаптированный):**
    *   **`main`:** Основная стабильная ветка. Всегда должна быть в состоянии, готовом к деплою (или отражать последний деплой). Прямые коммиты в `main` запрещены. Слияние только через Pull Request (PR) / Merge Request (MR).
    *   **Feature-ветки (`feature/название-фичи` или `feature/TTN-описание`):** Для каждой новой фичи, улучшения или значимой задачи создается отдельная ветка от актуального состояния `main`.
        *   Именование: `feature/TTN-kratkoe-opisanie` (где TTN - номер задачи в Jira, если используется) или `feature/kratkoe-opisanie-logicheskoy-celi`.
    *   **Bugfix-ветки (`bugfix/название-бага` или `bugfix/TTN-описание`):** Для исправления багов. Создаются от `main` (если баг в текущем релизе) или от соответствующей feature-ветки (если баг найден в ходе разработки фичи).
    *   **Hotfix-ветки (`hotfix/название-хотфикса`):** (Если потребуется для "боевых" ситуаций) Для срочных исправлений в продакшене. Создаются от тега релиза на `main`, мержуются обратно в `main` и в активные feature-ветки.
    *   **Регулярное обновление feature-веток:** Разработчики должны регулярно обновлять свои feature-ветки последними изменениями из `main`. Предпочтительно использовать `git rebase origin/main` для поддержания чистой и линейной истории коммитов в feature-ветке перед созданием PR. В случае сложных или длительных конфликтов при rebase, допустимо использовать `git merge origin/main` в feature-ветку.

**2.4. Правила для Коммитов:**
    *   **Атомарность:** Коммит должен представлять одно логическое изменение.
    *   **Сообщения коммитов:** Использовать стандарт Conventional Commits (например, `feat: ...`, `fix: ...`, `docs: ...`, `refactor: ...`, `test: ...`, `chore: ...`).
        *   Заголовок должен быть кратким и информативным.
        *   Тело коммита (если нужно) должно объяснять "что" и "почему", а не "как".
    *   **Частота:** Коммитить часто, небольшими порциями.

**2.5. Правила Слияния (Pull Request / Merge Request Workflow):**
    *   **Создание PR:** После завершения работы в feature/bugfix-ветке и локального тестирования, разработчик создает PR в `main`.
    *   **Описание PR:** PR должен иметь четкое описание проделанной работы, ссылки на задачи в Jira (если используются), инструкции по тестированию (если нужны).
    *   **CI-проверка:** Автоматический CI-пайплайн (Jenkins) должен успешно пройти для PR (сборка, все тесты).
    *   **Код-ревью:** Обязательное код-ревью как минимум одним другим членом команды (предпочтительно тимлид или другой senior-разработчик). Все замечания должны быть устранены.
    *   **Слияние:** После успешного CI и одобрения ревью, PR может быть смержен.
        *   **Метод слияния:** Предпочтительным методом является **"Rebase and merge"**. Это обеспечивает линейную историю коммитов в ветке `main`. Если `rebase` feature-ветки на `main` вызывает значительные или трудноразрешимые конфликты (например, из-за длительного существования ветки или большого количества пересекающихся изменений), в качестве альтернативы допустимо использовать **"Merge commit"** (со стандартным merge-коммитом, без squash).
    *   **Удаление ветки:** После мержа feature/bugfix-ветка удаляется из удаленного репозитория.

## 3. Рассмотренные Альтернативы

1.  **Менее формальный процесс ADR:** Не документировать решения или делать это нерегулярно.
    *   *Причина отклонения:* Риск потери знаний, несогласованность.
2.  **Другие модели ветвления Git (например, Git Flow, GitLab Flow):**
    *   Git Flow: Более сложная модель с ветками `develop`, `release`, `hotfix`. Может быть избыточной для проектов с частыми релизами или непрерывной доставкой, которые лучше поддерживаются GitHub Flow.
    *   *Причина выбора GitHub Flow (адаптированного):* Простота, хорошо подходит для большинства проектов с CI/CD, стремимся к линейной истории.
3.  **Отсутствие код-ревью или CI:**
    *   *Причина отклонения:* Критически снижает качество и надежность.
4.  **Только "Squash and merge" или только "Merge commit" как методы слияния:**
    *   "Squash and merge": Теряет детальную историю коммитов фичи, что может быть неудобно для анализа.
    *   "Merge commit" (без rebase): Создает больше merge-коммитов в истории `main`, делая ее менее линейной.
    *   *Причина выбора "Rebase and merge" как основного с "Merge commit" как запасного:* Стремление к линейной истории, но с возможностью прагматичного решения при сложных конфликтах.

## 4. Последствия

*   **Положительные:**
    *   Повышение прозрачности и предсказуемости процесса разработки.
    *   Улучшение качества кода и архитектуры благодаря формализации решений и код-ревью.
    *   Сохранение знаний и контекста архитектурных выборов.
    *   Более стабильная и чистая (по возможности линейная) история в `main` ветке.
    *   Упрощение онбординга.
*   **Отрицательные/Затраты:**
    *   Требуется время и дисциплина для следования процессам (написание ADR, код-ревью, корректное ведение веток).
    *   Процесс `rebase` требует от разработчиков большего внимания и навыков работы с Git, особенно при наличии конфликтов.
    *   Может незначительно замедлить "быстрые" правки из-за необходимости проходить через PR и ревью.
*   **Необходимые действия:**
    *   Донести эти правила до всех членов команды.
    *   Настроить CI-сервер для автоматической проверки PR.
    *   Регулярно проводить код-ревью.
    *   Поощрять создание ADR для значимых решений.
    *   Обучить команду (если необходимо) правильному использованию `git rebase` и разрешению конфликтов.

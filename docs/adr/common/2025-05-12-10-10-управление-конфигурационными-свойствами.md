**ADR-0022: Управление Конфигурационными Свойствами и Безопасность Секретов**

*   **Статус:** Утвержден
*   **Дата:** 2025-05-12
*   **Связанные ADR:** ADR-0011 (конфигурация dev-окружения), ADR-0017 (Спецификация JWT), ADR-0024 (Управление текстовыми ресурсами)
*   **Контекст:** Приложению `task-tracker-backend` требуется способ управления конфигурационными параметрами, включая чувствительные данные (секреты), обеспечивая безопасность, гибкость, валидацию и предсказуемость в различных окружениях.

*   **Принятое Решение:**

    1.  **Type-Safe Конфигурация:**
        *   Использовать классы, аннотированные `@ConfigurationProperties`, для доступа к конфигурационным параметрам приложения. Это обеспечивает type-safety, интеграцию с IDE и возможность группировки связанных свойств.
        *   Префикс для свойств, относящихся к приложению `task-tracker`, должен быть осмысленным (например, `app.security.jwt.*`, `app.kafka.*`).

    2.  **Валидация Свойств:**
        *   Классы `@ConfigurationProperties` **ДОЛЖНЫ** быть аннотированы `@Validated` (из `org.springframework.validation.annotation.Validated`).
        *   Поля в этих классах **ДОЛЖНЫ** быть провалидированы при старте приложения с использованием аннотаций Jakarta Bean Validation (например, `@NotBlank`, `@Size`, `@Positive`, `@NotNull`, `@Pattern`).
        *   Сообщения для аннотаций валидации **ДОЛЖНЫ** извлекаться из Resource Bundle через ключи (согласно ADR-0024).

    3.  **Управление Секретными Значениями (JWT Secret Key, Пароли БД и т.д.):**
        *   **Запрет Хранения в VCS:** Секретные значения **НИКОГДА** не должны храниться в системе контроля версий в открытом виде в файлах конфигурации (`application.yml`, `application.properties` и их профильных вариантах, кроме случаев, описанных ниже для `dev`/`ci`).
        *   **Формат JWT Secret Key:** Секретный ключ для JWT (и другие бинарные секреты, если применимо) **ДОЛЖЕН** предоставляться и ожидаться приложением в **Base64-кодированном виде**, когда он поступает из внешних источников (переменные окружения, файлы конфигурации для `prod`). Приложение отвечает за его декодирование перед использованием.
        *   **Предоставление Секретов для Production (`prod` профиль):**
            *   Секреты **ОБЯЗАТЕЛЬНЫ** и **ДОЛЖНЫ** предоставляться приложению через безопасные внешние механизмы:
                *   Переменные окружения (предпочтительный и наиболее универсальный способ).
                *   Внешние системы управления секретами (например, HashiCorp Vault, AWS Secrets Manager, Kubernetes Secrets), если инфраструктура это поддерживает и настроена интеграция.
        *   **Управление Секретами для Локальной Разработки и CI (`dev`, `ci` профили):**
            *   **Локальная разработка (`dev`):** Допускается использование временных/тестовых секретов (в Base64-формате, если это стандарт для данного секрета), определенных в `application-dev.yml`. Этот файл **ДОЛЖЕН** быть добавлен в `.gitignore`.
            *   **CI (`ci`):** Секреты для CI **ДОЛЖНЫ** предоставляться через переменные окружения, управляемые CI-сервером (например, Jenkins Credentials). Не допускается использование дефолтных/вкомпилированных секретов для CI-сборки, которая может производить артефакты для развертывания.
            *   **Опциональные/Дефолтные Секреты (НЕ для `prod`):** Приложение **не должно** содержать встроенных "магических" или дефолтных значений для критичных секретов (таких как JWT `secret-key`) в коде. Даже для профилей `dev` и `ci` ожидается, что такие секреты будут явно сконфигурированы (например, через `application-dev.yml` или переменные окружения CI), хотя сами значения этих секретов могут быть тестовыми или менее стойкими, чем для `prod`. Отсутствие явно сконфигурированного критичного секрета приведет к ошибке при старте приложения (например, из-за срабатывания `@NotBlank` на соответствующем поле в `@ConfigurationProperties`).

    4.  **Принцип "Fail-Fast" для Критических Конфигураций:**
        *   Для критически важных для безопасности или функционирования конфигураций (например, JWT `secret-key` в `prod` профиле, URL для подключения к основной БД в `prod`) приложение **ДОЛЖНО** реализовывать логику "fail-fast":
            *   Приложение **НЕ ДОЛЖНО СТАРТОВАТЬ** (должно выбросить исключение и завершить работу) при отсутствии или невалидности таких критических конфигурационных параметров, особенно в `prod` профиле.
            *   Валидация `@ConfigurationProperties` (см. п.2) является основным механизмом для этого.
            *   Дополнительные проверки, специфичные для конкретных конфигурационных параметров (например, проверка минимальной длины декодированного JWT секрета после его загрузки из JwtProperties), ДОЛЖНЫ быть реализованы в компоненте, ответственном за инициализацию или первое использование этого параметра (например, в конструкторе или @PostConstruct методе сервиса, который напрямую работает с этим параметром, как JwtKeyService для секретного ключа JWT). Такие проверки ДОЛЖНЫ приводить к ошибке при старте приложения (например, выбрасыванием IllegalStateException), если проверка не пройдена, тем самым реализуя принцип "fail-fast".

*   **Рассмотренные Альтернативы:**
    *   Чтение свойств напрямую через `@Value`: Менее type-safe, сложнее для группировки, валидации и управления жизненным циклом связанных свойств.
    *   Хранение секретов в коде или коммитируемых файлах: Категорически неприемлемо из-за рисков безопасности.
    *   Отсутствие fail-fast: Приводит к запуску приложения в небезопасной или неработоспособной конфигурации.

*   **Последствия:**
    *   Улучшение безопасности за счет строгого управления секретами и их форматом.
    *   Повышение надежности приложения за счет валидации конфигурации при старте и принципа "fail-fast".
    *   Упрощение конфигурации для разработчиков в `dev`-окружении при сохранении строгости для `prod`.
    *   Требует дисциплины в управлении конфигурационными файлами и переменными окружения для различных сред.
    *   Приложение будет зависеть от корректного декодирования Base64 для секретов.


**ADR-0024: Централизация и Управление Текстовыми Ресурсами Приложения через Resource Bundle**

*   **Статус:** Утвержден
*   **Дата:** 2025-05-12
*   **Связанные ADR:**
    *   ADR-0007: Использование структуры пакетов по доменам (фичам) в Backend сервисе
    *   ADR-0022: Управление Конфигурационными Свойствами и Безопасность Секретов
*   **Контекст:**
    *   Приложение `task-tracker-backend` генерирует различные текстовые сообщения, которые могут быть видны конечному пользователю (через ответы API), администратору (например, тексты email-уведомлений), а также используются для валидации данных на уровне конфигурации и DTO.
    *   Хардкодинг таких строк в Java-коде или аннотациях затрудняет их изменение, управление консистентностью формулировок по всему приложению и делает невозможной или крайне сложной потенциальную будущую интернационализацию (I18N).
    *   Необходимо установить единый, централизованный, легко навигируемый и **надежный** механизм для управления всеми такими текстовыми ресурсами, обеспечивающий "production-ready" подход. Надежность включает в себя явное обнаружение отсутствующих ключей сообщений.

*   **Принятое Решение: Использовать Java Resource Bundle и Spring `MessageSource` с Консистентной Конвенцией Именования Ключей, Гибкой Структурой Файлов и Строгой Обработкой Отсутствующих Ключей**

    1.  **Центральный Механизм Управления Текстами:**
        *   Все текстовые ресурсы приложения (сообщения об ошибках валидации, тексты для ответов API, тексты email-уведомлений и т.д.), которые не являются частью исполняемого кода, конфигурационных параметров (ADR-0022), или отладочных логов (ADR-0023), **ДОЛЖНЫ** управляться через механизм Java Resource Bundle.
        *   Доступ к этим ресурсам в коде приложения **ДОЛЖЕН** осуществляться через стандартный Spring Framework интерфейс `org.springframework.context.MessageSource`.

    2.  **Структура Файлов Resource Bundle и Определение Базовых Имен (`basename`):**
        *   Файлы сообщений (`.properties`) **ДОЛЖНЫ** размещаться в директории `src/main/resources/i18n/`.
        *   Внутри `i18n/` **РЕКОМЕНДУЕТСЯ** использовать доменную структуру поддиректорий (согласно ADR-0007), чтобы логически группировать сообщения. Например: `i18n/security/`, `i18n/user/`, `i18n/common/`.
        *   Имена файлов могут отражать их назначение (например, `validation_messages.properties`, `api_errors.properties`, `notifications.properties`) или более специфичный домен (например, `jwt_validation.properties`).
        *   Свойство `spring.messages.basename` в `application.yml` **ДОЛЖНО** содержать список базовых имен (путей от корня classpath без суффикса локали и `.properties`), разделенных запятыми.
            *   **Порядок в `basename` важен:** Более специфичные файлы (например, `i18n/security/jwt_validation`) **ДОЛЖНЫ** идти раньше более общих файлов того же домена (например, `i18n/security/validation`) или общих файлов приложения (например, `i18n/messages`), если предполагается возможность переопределения или детализации сообщений.
            *   Пример:
                ```yaml
                spring:
                  messages:
                    basename:
                      i18n/security/jwt_validation,  # Специфичные для JWT валидации
                      i18n/security/auth_errors,     # Ошибки аутентификации
                      i18n/security/messages,        # Общие сообщения безопасности
                      i18n/user/messages,
                      i18n/common_errors,
                      i18n/messages                  # Самые общие или фолбэки
                ```

    3.  **Конвенция Именования Ключей Сообщений:**
        *   Ключ, используемый в Java-коде (например, `{ключ}` в аннотациях валидации или `"ключ"` при вызове `messageSource.getMessage(...)`), **ДОЛЖЕН** быть **полным квалифицированным ключом**, отражающим его логическое местоположение или назначение.
        *   **Рекомендуемый Формат Ключа:** `<домен1>.<домен2_опционально>.<компонент_или_сущность>.<поле_или_аспект>.<описание_ошибки_или_сообщения>`
            *   Пример для валидации `@ConfigurationProperties` (префикс `app.security.jwt`): `{security.jwt.secretKey.notBlank}`. (Здесь `app.` опускается из ключа сообщения для краткости, но сохраняется в префиксе свойств).
            *   Пример для DTO пользователя: `{user.dto.registerRequest.email.invalidFormat}`.
            *   Пример для API ошибки: `{api.error.authentication.invalidToken.title}`.
        *   Эта конвенция обеспечивает глобальную уникальность ключей и упрощает навигацию к соответствующему сообщению. Ключ, как он указан в коде/аннотации, должен *точно так же* быть определен в одном из файлов, перечисленных в `spring.messages.basename`.

    4.  **Параметризация Сообщений:**
        *   Использовать стандартный механизм `java.text.MessageFormat` (`{0}`, `{1}`) для динамических значений и встроенные параметры аннотаций Bean Validation (`{min}`, `{max}`).

    5.  **Конфигурация `MessageSource` в Spring Boot (`application.yml`):**
        *   Помимо `spring.messages.basename`, **ДОЛЖНЫ** быть установлены следующие свойства для обеспечения надежности и предсказуемости:
            *   `spring.messages.encoding: UTF-8`.
            *   `spring.messages.fallback-to-system-locale: false`.
            *   `spring.messages.always-use-message-format: false` (или `true`, если необходимо обрабатывать одинарные кавычки во всех сообщениях).
            *   **Свойство `spring.messages.use-code-as-default-message` НЕ ДОЛЖНО быть установлено в `true`** для production-сборок или при выполнении тестов на CI. Если ключ сообщения не найден, `MessageSource` **ДОЛЖЕН** выбрасывать `NoSuchMessageException` (если не указано дефолтное сообщение в вызове `getMessage`). Это позволяет обнаруживать отсутствующие ключи на этапе тестирования или при старте.
                *   Для локальной разработки (профиль `dev`) *допускается* временная установка `use-code-as-default-message: true` для удобства, но это не должно попадать в основные конфигурации.

    6.  **Использование в Коде:**
        *   Внедрять Spring `MessageSource`.
        *   Получать сообщения через `messageSource.getMessage(...)`. При использовании версий без `defaultMessage` быть готовым обрабатывать `NoSuchMessageException`.
        *   Для аннотаций валидации: Spring автоматически использует `MessageSource`.
	
	7.  **Особенности Интерполяции Сообщений для Стандартных Аннотаций Jakarta Bean Validation:**
    *   При использовании ключей из Resource Bundle в атрибуте `message` стандартных аннотаций Jakarta Bean Validation (например, `@Size`, `@Pattern`, `@Min`, `@Max` и т.д.), и их последующей интерполяции через связку Spring `MessageSource` и нижележащего Bean Validation Provider (по умолчанию Hibernate Validator), необходимо учитывать следующий механизм:
        1.  Bean Validation Provider (Hibernate Validator) при обнаружении аннотации с `message = "{my.custom.key}"` сначала обращается к `jakarta.validation.MessageInterpolator`.
        2.  В Spring Boot, `MessageInterpolator` по умолчанию сконфигурирован для использования Spring `MessageSource`.
        3.  `MessageSource` извлекает строку-шаблон по ключу `my.custom.key` из соответствующего `.properties` файла.
        4.  **Эта строка-шаблон затем возвращается обратно Bean Validation Provider (Hibernate Validator) для финальной интерполяции.**
        5.  Hibernate Validator уже в этой строке-шаблоне ищет свои нативные плейсхолдеры, такие как `{min}`, `{max}`, `${validatedValue}`, атрибуты аннотации (например, `{regexp}` для `@Pattern`) и подставляет в них актуальные значения из атрибутов самой аннотации валидации.
    *   **Следствие для `messages.properties`:** Чтобы использовать атрибуты аннотаций (например, `min` и `max` из `@Size`) в сообщениях, хранящихся в Resource Bundle, строка для соответствующего ключа в `.properties` файле **ДОЛЖНА** содержать плейсхолдеры, понятные Bean Validation Provider (Hibernate Validator), а не плейсхолдеры `java.text.MessageFormat` (типа `{0}`, `{1}`).
        *   **Пример для `@Size(min=8, max=255, message="{user.password.size}")`:**
            В `messages.properties`:
            `user.password.size=Password must be between {min} and {max} characters long.`
            (Hibernate Validator подставит `8` вместо `{min}` и `255` вместо `{max}`).
    *   **Отличие от прямого использования `MessageSource`:** Этот механизм отличается от прямого вызова `messageSource.getMessage("key", new Object[]{arg0, arg1}, locale)`, где `MessageSource` ожидает плейсхолдеры `{0}`, `{1}` в строке из `.properties` файла. Для сообщений, не связанных со стандартными аннотациями Bean Validation, по-прежнему используется стандартная параметризация `MessageFormat`.
    *   **Цель:** Такой подход позволяет централизовать все шаблоны сообщений в Resource Bundle и одновременно использовать возможности Bean Validation Provider по интерполяции атрибутов аннотаций.

*   **Рассмотренные Альтернативы:**
    *   Хардкодинг строк: Отвергнуто из-за плохой поддерживаемости, отсутствия консистентности и невозможности I18N.
    *   Хранение строк в БД: Избыточно и неэффективно для большинства сообщений приложения.
    *   Единый глобальный файл сообщений без структуры: Затрудняет навигацию и управление при росте проекта.
    *   Использование `use-code-as-default-message: true` в production: Отвергнуто, так как скрывает ошибки отсутствующих ключей.

*   **Последствия и Рекомендации:**
    *   Обеспечивается централизованное, структурированное и **надежное** управление текстовыми ресурсами.
    *   Отсутствующие ключи сообщений будут приводить к ошибкам, способствуя их быстрому обнаружению.
    *   Значительно упрощается поддержка, изменение текстов и создается фундамент для I18N.
    *   Улучшается навигация между кодом и файлами сообщений.
    *   **Гибкость в организации файлов:** Разработчики могут начать с одного или нескольких общих файлов сообщений для домена (например, `i18n/security/messages.properties`) и, по мере роста количества сообщений, рефакторить их в более гранулярные файлы (например, `i18n/security/jwt_messages.properties`, `i18n/security/auth_messages.properties`), обновляя `spring.messages.basename` без изменения Java-кода, использующего эти ключи.
    *   **Требования к Тестированию:**
        *   Интеграционные тесты API **ДОЛЖНЫ** проверять корректность возвращаемых текстов сообщений об ошибках (извлекая их через `MessageSource` с ожидаемым ключом в тестовом коде или проверяя фактический текст).
        *   Рассмотреть создание специального теста, который проверяет наличие всех ключей, используемых в аннотациях валидации `@ConfigurationProperties` и DTO, в Resource Bundle.
    *   Требуется дисциплина в следовании принятой структуре директорий, конвенции именования ключей и обеспечении наличия всех ключей.

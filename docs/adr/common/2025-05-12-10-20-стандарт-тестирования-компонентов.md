**ADR-0025: Стандарты Тестирования Компонентов**

*   **Статус:** Утверждено
*   **Дата:** 2025-05-12
*   **Связанные ADR:**
    *   ADR-0008: Использование Testcontainers для интеграционных тестов базы данных (Определяет инструмент для ИТ БД)
    *   ADR-0015: Стратегия и подходы к тестированию в проекте "Task Tracker" (Определяет общие типы тестов и инструменты)
    *   ADR-0016: Конвенции и инструменты для интеграционного тестирования JPA и CI-отчетности (Определяет именование ИТ, `@DataJpaTest` и CI-аспекты)
    *   ADR-0021: Стандарт Документирования Кода с Использованием Javadoc (Качество кода распространяется и на тесты)
*   **Контекст:**
    *   ADR-0015 и ADR-0016 определили общую стратегию тестирования, типы тестов, инструменты и аспекты CI.
    *   Этот ADR дополняет их, устанавливая конкретные стандарты и принципы для написания качественных юнит- и интеграционных тестов компонентов в `task-tracker-backend`, фокусируясь на разделении их ответственности и требованиях к тестовым сценариям.
    *   Цель – обеспечить высокое покрытие кода тестами, раннее обнаружение ошибок и регрессий, а также поддерживаемость самого тестового кода.

*   **Принятые Решения по Стандартам Тестирования Компонентов:**

    1.  **Разделение Ответственности между Юнит- и Интеграционными Тестами:**
        *   **1.1. Юнит-тесты (Unit Tests):**
            *   **Цель:** Проверка корректности работы **одного изолированного компонента** (класса или небольшого набора тесно связанных классов) без взаимодействия с его реальными внешними зависимостями (БД, другие сервисы, файловая система, сетевые вызовы и т.д.).
            *   **Изоляция:** Внешние зависимости **ДОЛЖНЫ** быть заменены тестовыми двойниками (stubs, mocks, spies – используя Mockito).
            *   **Скорость:** Должны быть **очень быстрыми** для частого запуска (локально и на CI).
            *   **Область Применения:** Сервисный слой (бизнес-логика), утилитарные классы, компоненты со сложной внутренней логикой (например, компоненты JWT, кастомные валидаторы), сложные методы в POJO/DTO. Простые POJO/DTO (только геттеры/сеттеры, `equals`/`hashCode`/`toString`, сгенерированные Lombok или IDE) обычно не требуют отдельных юнит-тестов.
            *   **Что НЕ тестируют:** Интеграцию с фреймворком (например, корректность DI Spring), взаимодействие с реальной БД, HTTP-запросы/ответы.
        *   **1.2. Интеграционные тесты (Integration Tests - IT):**
            *   **Цель:** Проверка взаимодействия **между несколькими компонентами** приложения или интеграции приложения с **реальными или тестовыми экземплярами внешних зависимостей** (например, база данных, брокер сообщений).
            *   **Изоляция и Мокирование:**
                *   Тестируется *интеграция*. Поэтому для зависимостей, являющихся объектом тестирования интеграции (например, БД при тестировании репозитория или полного API-потока с БД), **ДОЛЖНЫ** использоваться их реальные или тестовые экземпляры (например, БД через Testcontainers, согласно ADR-0008).
                *   **Использование моков в интеграционных тестах СЛЕДУЕТ МИНИМИЗИРОВАТЬ.** Моки могут применяться только для имитации *внешних систем, не являющихся частью текущей тестируемой интеграции и труднодоступных в тестовом окружении* (например, сторонний платежный шлюз, внешний почтовый сервис, если его имитация через Testcontainers нецелесообразна или невозможна).
                *   **ЗАПРЕЩАЕТСЯ** мокировать компоненты, которые являются частью проверяемого интеграционного сценария (например, мокирование `AuthService` в интеграционном тесте контроллера, который должен проверить полный флоу аутентификации).
            *   **Скорость:** Медленнее юнит-тестов. Запускаются на CI, локально – по необходимости.
            *   **Область Применения:**
                *   **Слой персистентности:** Взаимодействие JPA-репозиториев с БД (ADR-0016, `@DataJpaTest` + Testcontainers).
                *   **API/Контроллеры:** Полный HTTP-флоу от запроса до ответа, включая валидацию DTO, работу контроллера, вызов сервиса, взаимодействие с БД, сериализацию/десериализацию, формирование корректных HTTP-статусов и ответов (включая Problem Details). Используется `@SpringBootTest` (предпочтительно с `WebEnvironment.RANDOM_PORT` для проверки полного стека) + `TestRestTemplate`, или `WebEnvironment.MOCK` + `MockMvc` для более легковесных тестов веб-слоя.
                *   **Взаимодействие с брокерами сообщений (когда появится):** Отправка и получение сообщений с использованием Testcontainers для Kafka.
                *   Проверка корректности работы цепочки фильтров Spring Security, аутентификации и авторизации на уровне HTTP-запросов (через `@SpringBootTest` + `TestRestTemplate`/`MockMvc`).
            *   **Именование:** Использовать суффикс `IT.java` (согласно ADR-0016).

    2.  **Требования к Качеству и Полноте Тестовых Сценариев:**
        *   **2.1. Покрытие Сценариев:**
            *   Тесты **ДОЛЖНЫ** покрывать как позитивные сценарии ("happy path"), так и негативные сценарии (обработка ошибок, выбрасывание ожидаемых исключений, невалидные входные данные).
            *   Необходимо тестировать граничные условия (например, пустые коллекции, нулевые значения там, где они допустимы или не допустимы, максимальные/минимальные значения).
        *   **2.2. Структура Тестового Метода (Arrange-Act-Assert - AAA):**
            *   Код внутри каждого тестового метода **ДОЛЖЕН** следовать паттерну AAA для ясности и читаемости:
                *   **Arrange (Подготовка):** Настройка начальных условий, создание объектов, мокирование (в юнит-тестах) или подготовка тестовых данных/состояния (в интеграционных).
                *   **Act (Действие):** Вызов тестируемого метода или выполнение тестируемого сценария.
                *   **Assert (Проверка):** Проверка результатов выполнения, состояния объектов, выброшенных исключений, вызовов моков (в юнит-тестах), состояния БД (в интеграционных).
        *   **2.3. Именование Тестовых Методов:**
            *   Имена тестовых методов **ДОЛЖНЫ** быть описательными и четко указывать на тестируемый сценарий и ожидаемое поведение.
            *   Рекомендуемый формат: `methodName_whenCondition_shouldExpectedBehavior()` или `shouldExpectedBehavior_whenCondition_forMethodName()`.
            *   Пример: `generateToken_whenPrincipalIsAppUserDetails_shouldReturnValidJwt()`
            *   Пример: `shouldThrowUsernameNotFoundException_whenUserEmailDoesNotExist_forLoadUserByUsername()`
            *   Для `@ParameterizedTest` рекомендуется использовать атрибут `name` аннотации для включения параметров теста в отображаемое имя (например, `name = "{displayName} - [{index}] {arguments}"`).
        *   **2.4. Изоляция Тестов:**
            *   Каждый тестовый метод **ДОЛЖЕН** быть независим от других. Результат выполнения одного теста не должен влиять на результат другого.
            *   Использовать аннотации `@BeforeEach` для настройки общего состояния перед каждым тестом и `@AfterEach` для очистки (если необходимо).
            *   Для ресурсов, инициализация которых занимает значительное время (например, Docker-контейнеры в Testcontainers), **ДОПУСКАЕТСЯ** использовать `@BeforeAll` и `@AfterAll` для управления их жизненным циклом на уровне тестового класса, при условии обеспечения очистки состояния между тестами.
        *   **2.5. Один Логический Assert на Тест (Рекомендация):**
            *   По возможности, каждый тестовый метод должен проверять одно конкретное логическое утверждение или аспект поведения.
            *   Допустимо иметь несколько физических вызовов `assert...()` в одном тесте, если они все относятся к проверке одного и того же логического результата или состояния (например, проверка нескольких полей одного DTO или корректности состояния объекта).
            *   Избегать перегруженных тестов, проверяющих множество несвязанных вещей.
        *   **2.6. Отсутствие Логики в Тестах:**
            *   Тестовые методы **НЕ ДОЛЖНЫ** содержать сложной бизнес-логики, условных операторов или циклов, влияющих на ход самого теста. Если требуется сложная подготовка данных или проверка, выносить ее во вспомогательные приватные методы тестового класса или статические фабричные методы.
        *   **2.7. Читаемость и Поддерживаемость Тестов:**
            *   Тестовый код является кодом первого класса и **ДОЛЖЕН** быть таким же чистым, читаемым и поддерживаемым, как и основной код приложения. Использовать осмысленные имена переменных, избегать "магических чисел" (использовать именованные константы).
            *   При проверке исключений использовать `org.junit.jupiter.api.Assertions.assertThrows` или аналогичные конструкции из AssertJ, которые явно указывают ожидаемый тип исключения.
            *   В ассертах **РЕКОМЕНДУЕТСЯ** использовать описательные сообщения (`as("...")` в AssertJ), чтобы при падении теста было сразу понятно, что пошло не так.
        *   **2.8. Тестирование Исключений:**
            *   Для проверки корректного выбрасывания ожидаемых исключений **СЛЕДУЕТ** использовать `org.junit.jupiter.api.Assertions.assertThrows` или аналогичные методы из библиотек утверждений (например, `assertThatExceptionOfType` из AssertJ).
            *   **ДОЛЖНА** проверяться не только сам факт выбрасывания исключения, но и, по возможности, его тип, сообщение (если оно является частью контракта) и причина (`cause`), если это релевантно.

*   **Рассмотренные Альтернативы:**
    *   **Смешивание юнит- и интеграционных тестов:** Приводит к медленным, ненадежным и трудноотлаживаемым тестовым наборам.
    *   **Тестирование только через UI/E2E:** Недостаточно для детальной проверки компонентов, медленно, дорого в поддержке, ошибки обнаруживаются поздно.
    *   **Отсутствие стандартов написания тестов:** Ведет к неконсистентным, неполным и труднопонимаемым тестам.
    *   **Активное использование моков в интеграционных тестах:** Уменьшает достоверность тестов, так как не проверяется реальное взаимодействие между компонентами. Отвергнуто в пользу использования реальных или тестовых экземпляров зависимостей (например, через Testcontainers), где это возможно.

*   **Последствия:**
    *   Повышение качества и надежности разрабатываемого ПО.
    *   Упрощение рефакторинга и внесения изменений благодаря наличию "сети безопасности" из тестов.
    *   Раннее обнаружение багов и регрессий в процессе разработки.
    *   Улучшение понимания работы компонентов через их тесты.
    *   Требует времени и усилий на написание и поддержку качественных тестов.
    *   Минимизация моков в интеграционных тестах повышает достоверность этих тестов, но может незначительно увеличить время их выполнения и сложность настройки тестового окружения.
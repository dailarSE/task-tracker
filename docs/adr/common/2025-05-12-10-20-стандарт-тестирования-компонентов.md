**ADR-0025: Стандарты Тестирования Компонентов**

*   **Статус:** Утверждено
*   **Дата:** 2025-05-12
*   **Связанные ADR:**
    *   ADR-0008: Использование Testcontainers для интеграционных тестов базы данных (Определяет инструмент для ИТ БД)
    *   ADR-0015: Стратегия и подходы к тестированию в проекте "Task Tracker" (Определяет общие типы тестов и инструменты)
    *   ADR-0016: Конвенции и инструменты для интеграционного тестирования JPA и CI-отчетности (Определяет именование ИТ, `@DataJpaTest` и CI-аспекты)
    *   ADR-0021: Стандарт Документирования Кода с Использованием Javadoc (Качество кода распространяется и на тесты)
*   **Контекст:**
    *   ADR-0015 и ADR-0016 определили общую стратегию тестирования, типы тестов, инструменты и аспекты CI.
    *   Этот ADR дополняет их, устанавливая конкретные стандарты и принципы для написания качественных юнит- и интеграционных тестов компонентов в `task-tracker-backend`, фокусируясь на разделении их ответственности и требованиях к тестовым сценариям.
    *   Цель – обеспечить высокое покрытие кода тестами, раннее обнаружение ошибок и регрессий, а также поддерживаемость самого тестового кода.

*   **Принятые Решения по Стандартам Тестирования Компонентов:**

    1.  **Разделение Ответственности между Юнит- и Интеграционными Тестами:**
        *   **1.1. Юнит-тесты (Unit Tests):**
            *   **Цель:** Проверка корректности работы **одного изолированного компонента** (класса или небольшого набора тесно связанных классов) без взаимодействия с его реальными внешними зависимостями (БД, другие сервисы, файловая система, сетевые вызовы и т.д.).
            *   **Изоляция:** Внешние зависимости **ДОЛЖНЫ** быть заменены моками (stubs, mocks, spies – используя Mockito).
            *   **Скорость:** Должны быть **очень быстрыми** для частого запуска (локально и на CI).
            *   **Область Применения:** Сервисный слой (бизнес-логика), утилитарные классы, компоненты со сложной внутренней логикой (например, `JwtTokenProvider`, части `AuthService`, кастомные валидаторы), POJO/DTO (если есть сложная логика в методах).
            *   **Что НЕ тестируют:** Интеграцию с фреймворком (например, корректность DI Spring), взаимодействие с реальной БД, HTTP-запросы/ответы.
        *   **1.2. Интеграционные тесты (Integration Tests - IT):**
            *   **Цель:** Проверка взаимодействия **между несколькими компонентами** приложения или интеграции приложения с **внешними зависимостями** (например, база данных, брокер сообщений).
            *   **Изоляция:** Тестируется *интеграция*, поэтому реальные или тестовые экземпляры зависимостей (например, БД через Testcontainers, согласно ADR-0008) используются. Моки могут применяться для имитации *других внешних систем*, не являющихся объектом данного интеграционного теста.
            *   **Скорость:** Медленнее юнит-тестов. Запускаются на CI, локально – по необходимости.
            *   **Область Применения:**
                *   **Слой персистентности:** Взаимодействие JPA-репозиториев с БД (ADR-0016, `@DataJpaTest` + Testcontainers).
                *   **API/Контроллеры:** Полный HTTP-флоу от запроса до ответа, включая валидацию DTO, работу контроллера, вызов сервиса, взаимодействие с БД (если необходимо), сериализацию/десериализацию, формирование корректных HTTP-статусов и ответов (включая Problem Details). (`@SpringBootTest` + `MockMvc` или `TestRestTemplate`).
                *   **Взаимодействие с брокерами сообщений** : Отправка и получение сообщений.
                *   Проверка корректности работы цепочки фильтров Spring Security, аутентификации и авторизации на уровне HTTP-запросов.
            *   **Именование:** Использовать суффикс `IT.java` (согласно ADR-0016).

    2.  **Требования к Качеству и Полноте Тестовых Сценариев:**
        *   **2.1. Покрытие Сценариев:**
            *   Тесты **ДОЛЖНЫ** покрывать как позитивные сценарии ("happy path"), так и негативные сценарии (обработка ошибок, выбрасывание ожидаемых исключений, невалидные входные данные).
            *   Необходимо тестировать граничные условия (например, пустые коллекции, нулевые значения там, где они допустимы или не допустимы, максимальные/минимальные значения).
        *   **2.2. Структура Тестового Метода (Arrange-Act-Assert - AAA):**
            *   Код внутри каждого тестового метода **ДОЛЖЕН** следовать паттерну AAA для ясности и читаемости:
                *   **Arrange (Подготовка):** Настройка начальных условий, создание объектов, мокирование зависимостей.
                *   **Act (Действие):** Вызов тестируемого метода или выполнение тестируемого сценария.
                *   **Assert (Проверка):** Проверка результатов выполнения, состояния объектов, выброшенных исключений, вызовов моков.
        *   **2.3. Именование Тестовых Методов:**
            *   Имена тестовых методов **ДОЛЖНЫ** быть описательными и четко указывать на тестируемый сценарий и ожидаемое поведение.
            *   Рекомендуемый формат: `methodName_whenCondition_shouldExpectedBehavior()` или `shouldExpectedBehavior_whenCondition_forMethodName()`.
            *   Пример: `generateToken_whenPrincipalIsAppUserDetails_shouldReturnValidJwt()`
            *   Пример: `shouldThrowUsernameNotFoundException_whenUserEmailDoesNotExist_forLoadUserByUsername()`
        *   **2.4. Изоляция Тестов:**
            *   Каждый тестовый метод **ДОЛЖЕН** быть независим от других. Результат выполнения одного теста не должен влиять на результат другого.
            *   Использовать аннотации `@BeforeEach` для настройки общего состояния перед каждым тестом и `@AfterEach` для очистки (если необходимо).
        *   **2.5. Один Логический Assert на Тест (Рекомендация):**
            *   По возможности, каждый тестовый метод должен проверять одно конкретное логическое утверждение или аспект поведения.
            *   Допустимо иметь несколько физических вызовов `assert...()` в одном тесте, если они все относятся к проверке одного и того же логического результата или состояния.
            *   Избегать перегруженных тестов, проверяющих множество несвязанных вещей.
        *   **2.6. Отсутствие Логики в Тестах:**
            *   Тестовые методы **НЕ ДОЛЖНЫ** содержать сложной логики (условия, циклы). Если требуется сложная подготовка данных или проверка, выносить ее во вспомогательные приватные методы тестового класса.
        *   **2.7. Читаемость и Поддерживаемость Тестов:**
            *   Тестовый код является кодом первого класса и **ДОЛЖЕН** быть таким же чистым, читаемым и поддерживаемым, как и основной код приложения. Использовать осмысленные имена переменных, избегать "магических чисел" (использовать константы).

*   **Рассмотренные Альтернативы:**
    *   **Смешивание юнит- и интеграционных тестов:** Приводит к медленным, ненадежным и трудноотлаживаемым тестовым наборам.
    *   **Тестирование только через UI/E2E:** Недостаточно для детальной проверки компонентов, медленно, дорого в поддержке, ошибки обнаруживаются поздно.
    *   **Отсутствие стандартов написания тестов:** Ведет к неконсистентным, неполным и труднопонимаемым тестам.
*   **Последствия:**
    *   Повышение качества и надежности разрабатываемого ПО.
    *   Упрощение рефакторинга и внесения изменений благодаря наличию "сети безопасности" из тестов.
    *   Раннее обнаружение багов и регрессий в процессе разработки.
    *   Улучшение понимания работы компонентов через их тесты.
    *   Требует времени и усилий на написание и поддержку качественных тестов.

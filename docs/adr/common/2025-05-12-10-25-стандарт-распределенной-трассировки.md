**ADR-0026: Требования к Применению Распределенной Трассировки**

*   **Статус:** Утверждено
*   **Дата:** 2025-05-12
*   **Связанные ADR:**
    *   ADR-0009: Определение стратегии обсервабилити и выбор технологического стека (Определяет OpenTelemetry, Tempo, авто-инструментацию, и автоматическое включение `trace_id`/`span_id` в логи).
    *   ADR-0023: Стандарт Применения Логгирования в Приложении (Определяет, что логи коррелируются с трассами через `trace_id`/`span_id`).
*   **Контекст:**
    *   ADR-0009 установил OpenTelemetry (OTel) как стандарт для сбора телеметрии, включая распределенные трассы, и Tempo как бэкенд для их хранения. Было принято решение использовать возможности авто-инструментации, предоставляемые OTel Java Agent или Spring Boot OTel Starter, для обеспечения базового уровня трассировки.
    *   Однако, для получения максимальной пользы от трассировки, особенно для понимания специфичных для приложения бизнес-операций и диагностики узких мест во внутренней логике, может потребоваться дополнительная, кастомная инструментация.
    *   Этот ADR определяет, когда и как разработчики должны применять кастомную инструментацию (создание спанов и добавление атрибутов) в коде приложения `task-tracker-backend`, устанавливая четкий приоритет для авто-инструментации и минимизируя избыточную ручную работу.
    *   Предполагается, что проект использует OpenTelemetry Java Agent или Spring Boot OTel Starter, которые поддерживают декларативную инструментацию через аннотации из пакета `io.opentelemetry.instrumentation.annotations` (например, `@WithSpan`, `@SpanAttribute`) или аналогичные механизмы, предоставляемые через Micrometer Tracing.

*   **Принятые Решения по Применению Трассировки:**

    1.  **Приоритет Авто-Инструментации:**
        *   **Основа Трассировки:** Авто-инструментация, предоставляемая OpenTelemetry Java Agent или интегрированными средствами Spring Boot OTel Starter, является **основным и предпочтительным** способом получения трассировочных данных.
        *   **Ожидаемое Покрытие Авто-Инструментацией:** Предполагается, что авто-инструментация покроет большинство стандартных взаимодействий и точек интеграции в приложении, включая, но не ограничиваясь:
            *   Обработку входящих HTTP-запросов (например, в Spring MVC контроллерах).
            *   Выполнение исходящих HTTP-клиентских вызовов (например, через `RestTemplate`, `WebClient`).
            *   Взаимодействия с базой данных через JDBC (включая вызовы через Spring Data JPA).
            *   Обработку сообщений из/в системы очередей (например, Kafka, когда она будет интегрирована).
            *   Выполнение запланированных задач, аннотированных Spring `@Scheduled`.
            *   Другие распространенные фреймворки и библиотеки, для которых существуют официальные или общепринятые OTel-инструментации.
        *   **Проверка Необходимости Кастомной Инструментации:** Перед добавлением любой кастомной инструментации (создания спанов или атрибутов вручную) разработчик **ДОЛЖЕН** сначала проанализировать существующие трассы (например, в Tempo или Grafana), чтобы убедиться, что интересующий участок кода или специфическая операция действительно не покрывается авто-инструментацией с достаточной степенью детализации.

    2.  **Применение Кастомной Инструментации (Спаны и Атрибуты) – для Обоснованных Случаев:**
        *   Кастомная инструментация (создание новых спанов или добавление атрибутов к существующим спанам) **ДОЛЖНА** применяться осмысленно и **только тогда, когда авто-инструментация не обеспечивает необходимой детализации или видимости** для ключевых бизнес-операций, сложных внутренних процессов, или для улучшения диагностики и понимания потока выполнения.
        *   **2.1. Критерии для Создания Кастомных Спанов:**
            Кастомный спан оправдан, если он обрамляет:
            *   **Значимые Бизнес-Логические Блоки:** Четко выделенные, последовательные и важные с точки зрения бизнеса шаги внутри одного автоматически созданного спана (например, внутри спана метода контроллера), которые сами по себе могут быть длительными, ресурсоемкими или критичными для анализа производительности или понимания бизнес-потока. *Пример: в методе обработки заказа шаги "Проверка наличия товара", "Обработка платежа", "Обновление статуса заказа" могут быть выделены в кастомные спаны.*
            *   **Операции, Невидимые для Авто-Инструментации:** Длительные или сложные вычисления, происходящие исключительно в памяти приложения; работа с локальным кэшем (если используемая библиотека кэширования не инструментируется автоматически); выполнение сложных алгоритмов, которые не включают инструментируемых внешних вызовов (JDBC, HTTP).
            *   **Улучшение Читаемости и Структурирования Трасс:** Для очень больших или логически сложных методов, выполнение которых не разбивается на внешние вызовы, создание внутренних под-спанов может существенно улучшить понимание трассы и локализацию узких мест.
            *   **Явное Определение Типа Спана (`SpanKind`):** В редких случаях, когда авто-инструментация не может корректно определить или установить `SpanKind` (например, для взаимодействия по нестандартному протоколу или с системой, для которой нет стандартной OTel-инструментации).
        *   **2.2. Критерии для Добавления Кастомных Атрибутов к Спанам (Автоматическим или Кастомным):**
            Кастомные атрибуты добавляются для обогащения спанов контекстом, полезным для анализа, фильтрации и корреляции трасс:
            *   **Ключевые Бизнес-Идентификаторы:** Идентификаторы, связывающие спан с конкретными бизнес-сущностями (например, `user.id`, `task.id`, `order.id`, `customer.email`). **Внимание:** При добавлении атрибутов, содержащих Персональные Идентификационные Данные (PII), необходимо строго соблюдать политики безопасности и конфиденциальности данных; PII должны добавляться только при крайней необходимости и с пониманием рисков.
            *   **Важные Параметры Операции:** Значения, которые существенно влияют на логику выполнения или результат операции (например, `request.type`, `item.count`, `payment.method`, `query.parameters.size`).
            *   **Результаты Операции (нечувствительные):** Информация о результате выполнения операции, если она не является ошибкой, но важна для контекста (например, `validation.result = "success"`, `cache.hit = "true"`, `items.processed.count = 10`).
            *   **Дополнительная Информация об Ошибках:** Хотя статус ошибки (`StatusCode.ERROR`) и исключение часто устанавливаются автоматически, кастомные атрибуты могут предоставить дополнительный контекст об ошибке, который не является частью стандартного сообщения исключения или стектрейса.
        *   **2.3. Предпочтительные Инструменты для Кастомной Инструментации:**
            *   **Декларативный Подход (Приоритетный):** Использовать аннотации, предоставляемые экосистемой OpenTelemetry или совместимыми библиотеками. Для проекта, использующего OTel Agent или Spring Boot OTel Starter, предпочтительны аннотации из пакета `io.opentelemetry.instrumentation.annotations`:
                *   **`@WithSpan`:** Для создания нового спана вокруг метода. Атрибут `value` используется для задания имени спана (например, `@WithSpan("user.registration.validation")`). Если `value` не указан, имя генерируется (например, `ClassName.methodName`). Атрибут `kind` используется для указания типа спана (`SpanKind.CLIENT`, `SpanKind.SERVER`, `SpanKind.PRODUCER`, `SpanKind.CONSUMER`, `SpanKind.INTERNAL` (по умолчанию)).
                *   **`@SpanAttribute`:** Для автоматического добавления значения параметра метода в качестве атрибута спана. Имя атрибута можно указать в аннотации (например, `@SpanAttribute("user.id") Long id`), если оно отличается от имени параметра метода.
            *   **Программный Подход (Для Сложных Случаев):** Использовать OpenTelemetry API напрямую (через `io.opentelemetry.api.trace.Tracer` для создания спанов и `io.opentelemetry.api.trace.Span.current()` для доступа к текущему спану и добавления атрибутов/событий). Этот подход применяется, когда жизненный цикл спана не совпадает с границами одного метода, или требуется очень сложное динамическое управление атрибутами/событиями, которое невозможно выразить декларативно.
        *   **2.4. Именование Кастомных Спанов и Атрибутов:**
            *   **Имена Спанов:** Должны быть осмысленными, лаконичными и следовать конвенции, позволяющей легко их идентифицировать и группировать. Рекомендуемый формат для программно создаваемых или явно именованных спанов: `<домен_или_компонент>.<операция_или_действие>` (например, `user.service.create`, `task.repository.findByOwner`, `email.kafka.sendWelcomeEmail`). Избегать слишком общих имен типа "process" или "handle".
            *   **Имена Атрибутов:** По возможности, использовать стандартные семантические конвенции OpenTelemetry для имен атрибутов (например, `http.method`, `db.statement`, `messaging.destination_name`). Для кастомных атрибутов использовать четкие, понятные имена, возможно, с префиксами, отражающими домен или контекст (например, `app.user.id`, `app.task.priority`).

    3.  **Добавление Событий (Events) к Спанам:**
        *   Для фиксации значимых моментов времени или дискретных событий *внутри* одного существующего спана (автоматически или кастомно созданного) **МОЖНО** использовать `Span.current().addEvent("имя_события", Attributes.of(AttributeKey.stringKey("event.detail"), "доп. информация"))`.
        *   **Примеры:** "Начало валидации данных", "Данные провалидированы успешно", "Запрос к внешней системе отправлен", "Получен ответ от внешней системы".
        *   События особенно полезны для понимания внутренней структуры длительных спанов или для отслеживания последовательности шагов, которые нецелесообразно выделять в отдельные под-спаны.

    4.  **Обработка Ошибок в Трассах:**
        *   Авто-инструментация и аннотация `@WithSpan` обычно автоматически помечают спан как ошибочный (`StatusCode.ERROR`), если из инструментируемого метода выбрасывается исключение. Запись самого исключения (стектрейс, сообщение) также часто происходит автоматически.
        *   При программном управлении спанами, если операция внутри спана завершилась ошибкой, разработчик **ОБЯЗАН** явно установить статус ошибки для спана (`span.setStatus(StatusCode.ERROR, "Краткое описание причины ошибки")`) и записать информацию об исключении (`span.recordException(exception)`).

    5.  **Распространение Контекста Трассировки:**
        *   **Автоматическое Распространение:** Для стандартных протоколов и взаимодействий (HTTP, Kafka с соответствующими OTel-инструментациями) контекст трассировки (содержащий `trace_id` и `span_id`, обычно через W3C Trace Context headers) распространяется автоматически между процессами и компонентами.
        *   **Асинхронные Операции в Приложении:** При использовании механизмов асинхронного выполнения в Java (например, Spring `@Async`, кастомные `ExecutorService`, `CompletableFuture`) **НЕОБХОДИМО** обеспечить корректную передачу и восстановление контекста трассировки в новые потоки или при возобновлении выполнения. Spring Boot OTel Starter и инструментации OTel обычно предоставляют для этого поддержку (например, через инструментированные обертки для `Executor`'ов). Если используются полностью кастомные механизмы асинхронности, может потребоваться ручное управление контекстом с использованием OTel API (`Context.makeCurrent()`, `Context.current().wrap(...)`).

*   **Рассмотренные Альтернативы:**
    *   **Полное отсутствие кастомной инструментации (опора только на авто-инструментацию):** Отвергнуто, так как это может привести к "слепым зонам" в трассах, где выполняются важные, но не инструментированные автоматически бизнес-операции, что затруднит диагностику и анализ производительности.
    *   **Чрезмерная или нецелесообразная кастомная инструментация (инструментировать каждый метод):** Отвергнуто, так как это неоправданно увеличивает сложность кода, вносит накладные расходы на производительность и может "зашуметь" трассы избыточными спанами, затрудняя их анализ. Данный ADR направлен на достижение баланса.
*   **Последствия:**
    *   Обеспечивается сбалансированный подход к трассировке: авто-инструментация предоставляет широкое базовое покрытие, а кастомная инструментация добавляет специфическую детализацию там, где это действительно необходимо для понимания бизнес-логики и диагностики.
    *   Трассы остаются информативными и полезными, не будучи перегруженными избыточными или незначащими спанами.
    *   Требует от разработчиков понимания возможностей авто-инструментации, анализа существующих трасс перед добавлением кастомной инструментации, и осмысленного применения аннотаций (`@WithSpan`, `@SpanAttribute`) или программного API OTel.
    *   Ожидается небольшое увеличение накладных расходов на выполнение кода из-за дополнительной инструментации, что является приемлемой платой за улучшенную наблюдаемость.
    *   Необходимо обеспечить наличие соответствующих зависимостей в проекте (например, `opentelemetry-instrumentation-annotations` или аналогичные для Micrometer Tracing) и правильную конфигурацию OTel агента/стартера для обработки этих аннотаций.

**ADR-0027: Использование `java.time.Clock` для Управления Временем**

*   **Статус:** Утвержден
*   **Дата:** 2025-05-12
*   **Контекст:**
    *   Многие компоненты приложения (например, генерация JWT, логика аудита, планировщик задач) зависят от текущего времени.
    *   Тестирование компонентов, зависящих от `System.currentTimeMillis()` или `Instant.now()`, затруднено, так как время не контролируется в тестах.

*   **Принятое Решение:**

    1.  **Внедрение `java.time.Clock`:**
        *   Все компоненты приложения, которым необходимо получать текущее время (например компоненты, использующие Spring Data JPA Auditing для установки временных меток `@CreatedDate`/`@LastModifiedDate`), **ДОЛЖНЫ** получать его через инъекцию зависимости бина `java.time.Clock`.
        *   **ЗАПРЕЩАЕТСЯ** прямое использование `System.currentTimeMillis()`, `new Date()`, `Instant.now()` (без аргумента `Clock`), `LocalDateTime.now()` (без аргумента `Clock`), `ZonedDateTime.now()` (без аргумента `Clock` или с системной зоной по умолчанию) и т.п. в коде сервисов, контроллеров и других управляемых Spring компонентов.

    2.  **Конфигурация Бина `Clock`:**
        *   В основной конфигурации приложения (например, `AppConfig.java`) **ДОЛЖЕН** быть определен бин `Clock`, возвращающий `Clock.systemUTC()`. Это соответствует ADR-0012 (Обеспечение консистентности времени через UTC).
        *   Этот же бин `Clock` **ДОЛЖЕН** использоваться для конфигурации `DateTimeProvider` в `JpaAuditingConfig` (если JPA Auditing используется), чтобы обеспечить консистентность временных меток аудита.

    3.  **Использование `Clock` в Компонентах:**
        *   Компоненты **ДОЛЖНЫ** получать `Clock` через конструктор и использовать его для получения текущего времени (например, `Instant.now(this.clock)`).

    4.  **Тестирование Компонентов, Зависящих от Времени:**
        *   В юнит- и интеграционных тестах, где требуется контроль над временем, системный бин `Clock` **ДОЛЖЕН** быть заменен на экземпляр `Clock` с фиксированным временем.
        *   **Предпочтительный способ:** Использование `Clock.fixed(FIXED_INSTANT, ZoneOffset.UTC)`.
        *   **Альтернативный способ (для специфических сценариев):** Использование моков (например, `@MockBean Clock mockClock;` или `@Mock Clock mockClock;` с `@InjectMocks`). Этот подход может быть полезен, если требуется эмулировать изменение времени в ходе одного тестового метода или верифицировать специфические вызовы методов `Clock` (что обычно не требуется для `instant()` или `getZone()`). При мокировании `Clock` необходимо мокировать как минимум `clock.instant()` и `clock.getZone()`.

*   **Рассмотренные Альтернативы:**
    *   Прямое использование `System.currentTimeMillis()` или `Instant.now()`: Отвергнуто, так как затрудняет тестирование и делает код менее предсказуемым.
    *   Использование кастомных оберток над системным временем: Отвергнуто как избыточное, так как `java.time.Clock` предоставляет стандартное и более гибкое решение.

*   **Последствия:**
    *   Значительное улучшение тестируемости компонентов, зависящих от времени.
    *   Повышение предсказуемости и контролируемости кода, работающего со временем.
    *   Требует дисциплины от разработчиков для последовательного использования инъектированного `Clock`.
    *   Все временные метки, генерируемые приложением (например, `iat`, `exp` в JWT; `createdAt`, `updatedAt` в сущностях при использовании JPA Auditing, сконфигурированного с этим же бином `Clock`), будут основаны на времени из этого бина `Clock`, что обеспечивает консистентность (включая использование UTC).

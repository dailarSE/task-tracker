**ADR-0027: Использование `java.time.Clock` для Управления Временем**

*   **Статус:** Утвержден
*   **Дата:** 2025-05-12
*   **Контекст:**
    *   Многие компоненты приложения (например, генерация JWT, логика аудита, планировщик задач) зависят от текущего времени.
    *   Тестирование компонентов, зависящих от `System.currentTimeMillis()` или `Instant.now()`, затруднено, так как время не контролируется в тестах.

*   **Принятое Решение:**

    1.  **Внедрение `java.time.Clock`:**
        *   Все компоненты приложения, которым необходимо получать текущее время, **ДОЛЖНЫ** получать его через инъекцию зависимости бина `java.time.Clock`.
        *   **ЗАПРЕЩАЕТСЯ** прямое использование `System.currentTimeMillis()`, `new Date()`, `Instant.now()` (без аргумента `Clock`), `LocalDateTime.now()` (без аргумента `Clock`) и т.п. в коде сервисов, контроллеров и других управляемых Spring компонентов.

    2.  **Конфигурация Бина `Clock`:**
        *   В основной конфигурации приложения (например, `AppConfig.java`) **ДОЛЖЕН** быть определен бин `Clock`:
            ```java
            @Configuration
            public class AppConfig {
                @Bean
                public Clock clock() {
                    // Использовать системные часы, работающие в UTC, для основного приложения.
                    // Это соответствует ADR-0012 (Обеспечение консистентности времени через UTC).
                    return Clock.systemUTC();
                }
            }
            ```

    3.  **Использование `Clock` в Компонентах:**
        *   Компоненты получают `Clock` через конструктор:
            ```java
            @Service
            public class MyTimeSensitiveService {
                private final Clock clock;

                public MyTimeSensitiveService(Clock clock) {
                    this.clock = clock;
                }

                public void doSomething() {
                    Instant currentTime = Instant.now(this.clock);
                    // ... использовать currentTime ...
                }
            }
            ```

    4.  **Тестирование Компонентов, Зависящих от Времени:**
        *   В юнит- и интеграционных тестах, где требуется контроль над временем, бин `Clock` **ДОЛЖЕН** быть заменен на фиксированный или управляемый экземпляр `Clock`.
        *   Это можно сделать через:
            *   Использование `@MockBean Clock clock;` (для Mockito) и `when(clock.instant()).thenReturn(FIXED_INSTANT);`.
            *   Внедрение тестовой конфигурации, которая предоставляет бин `Clock.fixed(FIXED_INSTANT, ZoneOffset.UTC)`.
            *   Пример для юнит-теста:
                ```java
                @ExtendWith(MockitoExtension.class)
                class MyTimeSensitiveServiceTest {
                    @Mock
                    private Clock mockClock;
                    @InjectMocks
                    private MyTimeSensitiveService service;

                    private static final Instant FIXED_NOW = Instant.parse("2025-01-01T12:00:00Z");

                    @BeforeEach
                    void setUp() {
                        when(mockClock.instant()).thenReturn(FIXED_NOW);
                        when(mockClock.getZone()).thenReturn(ZoneOffset.UTC); // Важно для now(clock)
                    }
                    // ... тесты ...
                }
                ```

*   **Рассмотренные Альтернативы:**
    *   Прямое использование `System.currentTimeMillis()` или `Instant.now()`: Затрудняет тестирование, делает код менее предсказуемым.
    *   Использование кастомных оберток над системным временем: Избыточно, так как `java.time.Clock` предоставляет стандартное решение.

*   **Последствия:**
    *   Значительное улучшение тестируемости компонентов, зависящих от времени.
    *   Повышение предсказуемости и контролируемости кода, работающего со временем.
    *   Требует дисциплины от разработчиков для последовательного использования инъектированного `Clock`.
    *   Все временные метки, генерируемые приложением (например, `iat`, `exp` в JWT, `createdAt`, `updatedAt` в сущностях, если они управляются приложением, а не БД/ORM-аннотациями), будут основаны на времени из этого бина `Clock`, что обеспечивает консистентность (включая использование UTC).


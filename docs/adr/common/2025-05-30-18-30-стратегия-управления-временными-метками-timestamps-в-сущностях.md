# ADR-0033: Стратегия управления временными метками (timestamps) в сущностях

**Статус:** Принят

**Дата:** 2025-05-30

## 1. Контекст

При работе с временными метками в Java (используя `java.time.Instant` с наносекундной точностью) и их сохранении в базу данных (например, PostgreSQL с типом `TIMESTAMPTZ`, который по умолчанию имеет микросекундную точность) возникает проблема расхождения в точности. Это может приводить к неконсистентным данным при чтении и сравнении, а также к неожиданному поведению API, если клиент ожидает определенную точность.

Кроме того, для разных сущностей могут быть предпочтительны разные подходы к управлению аудиторскими полями (такими как `createdAt`, `updatedAt`): автоматический (через JPA Auditing) или ручной для полного контроля. В проекте "Task Tracker" сущность `User` использует JPA Auditing (ADR-0029), в то время как для сущности `Task` возникла потребность в более явном контроле.

Необходимо определить единую и консистентную стратегию управления временными метками для всех сущностей, учитывая точность хранения и специфику аудита.

## 2. Принятое Решение

1.  **Дифференцированный подход к аудиту времени:**
    *   **Для сущности `User`:** Продолжать использовать механизм Spring Data JPA Auditing с кастомным `DateTimeProvider`, основанным на инжектированном бине `java.time.Clock` (как определено в ADR-0029). Этот подход подходит для сущностей с простой логикой аудита.
    *   **Для сущности `Task` (и потенциально других будущих сущностей, где требуется аналогичный или более сложный контроль):** Использовать **ручное управление** временными метками (`createdAt`, `updatedAt`, `completedAt` и т.д.) непосредственно в сервисном слое. Источником времени для установки этих полей должен служить инжектированный бин `java.time.Clock`.

2.  **Округление `Instant` до микросекунд:**
    *   Все значения `java.time.Instant`, которые устанавливаются вручную в сервисном слое (например, для сущности `Task`) и предназначены для сохранения в базу данных, должны быть **округлены (усечены) до микросекунд** с использованием `instant.truncatedTo(ChronoUnit.MICROS)` перед передачей в слой персистентности.
    *   Это обеспечивает консистентность между точностью времени в Java-коде и точностью хранения в PostgreSQL (тип `TIMESTAMPTZ`), а также делает ответы API более предсказуемыми в части формата и точности временных полей.

3.  **Сохранение принципов ADR-0012:**
    *   Все временные метки продолжают храниться и обрабатываться в UTC.
    *   В базе данных используется тип `TIMESTAMPTZ`.
    *   Клиент API должен ожидать временные метки от сервера с микросекундной точностью.

## 3. Обоснование

*   **Полный контроль:** Ручное управление временными метками (для `Task`) предоставляет полный контроль над их значениями и логикой установки, что особенно важно для полей типа `completedAt`, зависящих от бизнес-логики, а также для точного управления `updatedAt` в сложных сценариях.
*   **Консистентность точности:** Округление до микросекунд устраняет проблему расхождения точности между Java `Instant` (наносекунды) и стандартной точностью `TIMESTAMPTZ` в PostgreSQL (микросекунды). Это предотвращает потенциальные ошибки при сравнении и обеспечивает предсказуемый формат времени в API ответах.
*   **Гибкость:** Дифференцированный подход к аудиту позволяет выбирать наиболее подходящий инструмент для каждой сущности. JPA Auditing удобен для простых случаев (`User`), тогда как ручное управление необходимо для более сложных (`Task`).
*   **Тестируемость:** Использование инжектированного `Clock` как для JPA Auditing (через `DateTimeProvider`), так и для ручного управления, обеспечивает высокую тестируемость логики, связанной со временем.

## 4. Последствия

*   **Положительные:**
    *   Улучшенная консистентность и предсказуемость временных меток в системе и API.
    *   Больший контроль над логикой установки временных полей для сущностей, где это необходимо.
    *   Упрощение сравнения временных меток в тестах и потенциально на клиенте (хотя сравнение с допуском остается лучшей практикой).
*   **Отрицательные/Затраты:**
    *   Необходимость явной установки и округления времени в сервисах для сущностей с ручным управлением (например, `TaskService`). Это добавляет немного бойлерплейт-кода.
    *   Разработчики должны помнить о необходимости округления `Instant` до микросекунд при ручной установке.
*   **Необходимые действия:**
    *   Реализовать ручную установку и округление временных меток в `TaskService` и других сервисах, где это применимо.
    *   Обновить существующие тесты для учета округления (хотя сравнение с допуском уже должно это покрывать).
    *   Убедиться, что Javadoc и другая документация отражают этот подход.

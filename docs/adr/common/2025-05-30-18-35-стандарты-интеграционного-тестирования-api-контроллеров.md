# ADR-0034: Стандарты интеграционного тестирования API контроллеров

**Статус:** Принят

**Дата:** 2025-05-30

## 1. Контекст

В проекте "Task Tracker" используется многоуровневая стратегия тестирования, описанная в ADR-0015. Интеграционные тесты API контроллеров играют ключевую роль в проверке сквозного взаимодействия компонентов бэкенд-сервиса, от HTTP-запроса до ответа, включая слой персистентности и логику безопасности. По мере развития API и усложнения тестовых сценариев возникла необходимость формализовать специфические подходы и стандарты для этого типа тестов, чтобы обеспечить их качество, надежность, поддерживаемость и консистентность.

Ранее интеграционные тесты могли иметь разную степень изоляции или использовать разные подходы к подготовке данных и проверке результатов. Это могло приводить к хрупкости тестов и усложнению их анализа.

## 2. Принятое Решение

Для интеграционного тестирования API контроллеров (файлы с суффиксом `*IT.java` в пакетах `*.web` или `*.controller`) в проекте "Task Tracker" принимаются следующие стандарты и практики:

1.  **Инструментарий:**
    *   Использовать Spring Boot Test с аннотацией `@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)` для запуска полного контекста приложения и реального веб-сервера на случайном порту.
    *   Для выполнения HTTP-запросов к API использовать `org.springframework.boot.test.web.client.TestRestTemplate`.
    *   Для управления зависимостями базы данных использовать Testcontainers (PostgreSQL), как определено в ADR-0007.

2.  **Принцип "Черного Ящика" (Black-Box Testing):**
    *   **Запрещено прямое использование (инъекция или вызов) бинов репозиториев (`*Repository`) и сервисов (`*Service`) внутри IT-тестов контроллеров.**
    *   Все взаимодействия с тестируемой системой, включая подготовку начальных данных (pre-conditions) и проверку состояния системы после выполнения операции (post-conditions/assertions), должны осуществляться **исключительно через HTTP-вызовы к API** самого тестируемого приложения (т.е. через `TestRestTemplate`).
    *   Вспомогательные методы внутри тестового класса для инкапсуляции повторяющихся API-запросов (например, `createTaskApi(...)`, `getTaskApi(...)`) приветствуются для улучшения читаемости и уменьшения дублирования кода.

3.  **Управление Аутентификацией в Тестах:**
    *   Для генерации JWT, необходимых для доступа к защищенным эндпоинтам, использовать стандартизированную утилиту `TestJwtUtil.java` (созданную в рамках разработки US6). Эта утилита должна использовать те же конфигурационные свойства JWT (ключ, время жизни и т.д.), что и основное приложение в тестовом профиле.
    *   Тестовые пользователи, необходимые для генерации токенов и проверки авторизации, должны создаваться либо через API регистрации (если это не усложняет тест чрезмерно), либо через прямое сохранение в БД в методах `@BeforeEach` или `@BeforeAll` тестового класса (это допустимое исключение из правила "только через API" для начальной настройки тестового окружения, если API регистрации отсутствует или его использование для каждого теста избыточно).

4.  **Проверка Ответов API:**
    *   **HTTP Статус и Заголовки:** Всегда проверять корректность HTTP статуса ответа и важных заголовков (например, `Location` для 201 Created, `WWW-Authenticate` для 401 Unauthorized, `Content-Type`).
    *   **Тело Ответа (DTO):** Проверять структуру и значения ключевых полей в DTO ответа. Для сравнения сложных объектов DTO использовать `isEqualToComparingFieldByFieldRecursively()` из AssertJ или аналогичные подходы.
    *   **Ответы с Ошибками (`ProblemDetail`):**
        *   Использовать стандартизированные вспомогательные assert-методы (хелперы) внутри тестовых классов для проверки структуры `ProblemDetail` (согласно RFC 9457).
        *   Эти хелперы должны проверять: HTTP статус, `type` URI (сравнивая с константами из `ApiConstants` или соответствующего Exception-класса), `title` (сравнивая с ожидаемым значением из `MessageSource` для текущей локали), `instance` URI, а также наличие и значения специфичных `properties` (например, `error_ref`, `invalid_params`, `requested_task_id`).
    *   **Временные Метки (`java.time.Instant`):** При сравнении временных меток, полученных из API, с ожидаемыми значениями, всегда использовать сравнение с допуском (например, `assertThat(actualInstant).isCloseTo(expectedInstant, within(offset))`) для учета возможного округления точности при сохранении/чтении из БД. Рекомендуемый допуск – несколько миллисекунд (например, `Duration.ofMillis(100)`).

5.  **Изоляция Тестов:** Каждый тестовый метод должен быть независим и не влиять на другие тесты. Очистка данных (например, через `@AfterEach` с вызовом `userRepository.deleteAllInBatch()`) должна обеспечивать чистое состояние перед каждым тестом.

## 3. Обоснование

*   **Надежность и Реалистичность:** Тестирование через HTTP API максимально приближено к тому, как реальные клиенты будут взаимодействовать с системой. Это проверяет весь стек приложения, от веб-слоя до базы данных, включая конфигурацию Spring Security, сериализацию/десериализацию, обработку ошибок.
*   **Уменьшение Хрупкости Тестов:** Запрет на прямой доступ к внутренним компонентам (сервисам, репозиториям) делает тесты менее чувствительными к изменениям внутренней реализации этих компонентов, пока контракт API остается неизменным.
*   **Проверка Контракта API:** Такие тесты фактически проверяют соблюдение контракта API.
*   **Качество API:** Необходимость подготавливать данные и проверять состояние через API стимулирует разработку полнофункционального и удобного API (например, наличие `GET` эндпоинтов для проверки созданных или измененных ресурсов).
*   **Консистентность Тестового Кода:** Стандартизация подходов к генерации JWT, проверке `ProblemDetail` и другим аспектам улучшает читаемость и поддерживаемость тестов.

## 4. Последствия

*   **Положительные:**
    *   Повышение уверенности в корректности работы API в целом.
    *   Более надежное обнаружение регрессий, затрагивающих взаимодействие компонентов.
    *   IT-тесты служат хорошей документацией использования API.
*   **Отрицательные/Затраты:**
    *   Написание IT-тестов контроллеров в таком стиле может быть более трудоемким, чем тесты с мокированием сервисного слоя, так как требует настройки данных и выполнения HTTP-запросов.
    *   Время выполнения IT-тестов может быть значительным из-за поднятия полного контекста и работы с реальной БД (через Testcontainers).
    *   Может потребоваться создание дополнительных "вспомогательных" API эндпоинтов или усложнение логики существующих для обеспечения возможности подготовки данных и проверки состояния исключительно через API.
*   **Необходимые действия:**
    *   Все новые IT-тесты для контроллеров должны следовать этим стандартам.
    *   Существующие IT-тесты контроллеров (`UserControllerIT.java`, `TaskControllerIT.java`) должны быть рефакторены для соответствия этим стандартам.
    *   Команда должна поддерживать и развивать `TestJwtUtil` и общие assert-хелперы.
# ADR-0004/1: Определение Архитектуры Слоя Персистентности для Backend Сервисов

**Статус:** Accepted

**Дата:** 2025-05-05

## 1. Контекст

Для бэкенд-сервисов проекта "Task Tracker" требуется стандартизированный и эффективный подход к взаимодействию с реляционной базой данных (PostgreSQL, согласно ADR-0002). Необходимо выбрать технологии и паттерны для маппинга объектов на реляционную структуру (ORM), управления транзакциями, выполнения запросов и обеспечения валидации данных на уровне персистентности. Схема базы данных управляется через Liquibase (согласно ADR-0004). Важно также предусмотреть гибкость для будущих потребностей, таких как пакетные операции.

## 2. Принятое Решение

1.  **ORM и Стандарт:** Использовать **Jakarta Persistence API (JPA)** как стандарт для объектно-реляционного отображения. В качестве реализации JPA использовать **Hibernate**.
2.  **Доступ к данным:** Использовать **Spring Data JPA** для упрощения создания слоя доступа к данным (репозиториев).
3.  **Управление транзакциями:** Использовать декларативное управление транзакциями Spring (`@Transactional`).
4.  **Валидация сущностей:** Использовать аннотации **Jakarta Bean Validation** на полях JPA-сущностей.
5.  **Аудит временных меток:** Для полей, отслеживающих время создания и последнего обновления сущностей (например, `createdAt`, `updatedAt`):
    *   Тип данных `java.time.Instant` в Java-сущностях (соответствует `TIMESTAMPTZ` в PostgreSQL, согласно ADR-0011).
    *   Использовать аннотации **Hibernate (`@CreationTimestamp`, `@UpdateTimestamp`)**. Выбор в пользу аннотаций Hibernate сделан из-за их простоты и отсутствия необходимости в дополнительной конфигурации Spring Data JPA Auditing (`@EnableJpaAuditing`, `AuditorAware`), которая была бы избыточна для текущих требований простого аудита времени. Если в будущем потребуется аудит по пользователю (`@CreatedBy`, `@LastModifiedBy`), будет рассмотрен переход на полное решение Spring Data JPA Auditing.
6.  **Генерация первичных ключей:** По умолчанию для автоинкрементных первичных ключей использовать стратегию JPA **`@GeneratedValue(strategy = GenerationType.SEQUENCE)`** в сочетании с аннотацией **`@SequenceGenerator`**.
    *   Это обеспечивает получение ID до фактической вставки (`INSERT`) в базу данных, что полезно для снижения нагрузки на базу и/или для пакетных операций, где ID могут быть нужны заранее.
    *   Каждая сущность, требующая автогенерируемого ID, будет иметь свой собственный именованный sequence в базе данных (например, `users_id_seq`, `tasks_id_seq`), который будет создаваться через миграции Liquibase.
    *   Стратегия `GenerationType.IDENTITY` будет рассматриваться только в исключительных случаях, если для конкретной сущности она будет явно более подходящей и не будет ожидаться пакетных операций с предварительным получением ID.
7.  **Проверка соответствия схемы:** Настроить Hibernate на проверку соответствия JPA-сущностей схеме БД, созданной Liquibase, используя свойство `spring.jpa.hibernate.ddl-auto: validate`.

## 3. Рассмотренные Альтернативы

1.  **Чистый JDBC:**
    *   *Причина отклонения:* Слишком трудоемко, увеличивает время разработки.
2.  **Другие ORM/Data Mapping фреймворки (MyBatis, jOOQ):**
    *   *Причина отклонения:* Spring Data JPA с Hibernate является стандартом в экосистеме Spring, обеспечивает хороший баланс удобства и мощности.
3.  **Hibernate `ddl-auto: update` или `create` для управления схемой:**
    *   *Причина отклонения:* Рассмотрено в ADR-0004 (Выбор Liquibase). Недостаточная надежность и контроль.
4.  **Аннотации Spring Data JPA Auditing (`@CreatedDate`, `@LastModifiedDate`) для аудита времени:**
    *   *Описание:* Использование встроенного механизма аудита Spring Data.
    *   *Плюсы:* Часть Spring Data, не привязано к Hibernate.
    *   *Минусы:* Требует дополнительной конфигурации (`@EnableJpaAuditing`). Для простого аудита времени аннотации Hibernate проще.
    *   *Причина отклонения (на текущем этапе):* Для текущих нужд аудита только времени аннотации Hibernate проще и не требуют дополнительной настройки. Переход на Spring Data JPA Auditing будет рассмотрен при необходимости аудита пользователя.
5.  **Стратегия генерации ID `GenerationType.IDENTITY` по умолчанию:**
    *   *Описание:* ID генерируется базой данных в момент `INSERT`.
    *   *Плюсы:* Проста в настройке для СУБД с поддержкой автоинкрементных колонок (как `BIGSERIAL` в PostgreSQL).
    *   *Минусы:* ID становится доступен только после фактической вставки в БД, что затрудняет некоторые сценарии, включая пакетные операции с предварительным назначением ID или установку связей до сохранения родительской сущности.
    *   *Причина отклонения (как дефолтной стратегии):* `SEQUENCE` предоставляет большую гибкость для будущих потребностей, особенно для пакетных операций.

## 4. Последствия

*   **Положительные:**
    *   Быстрая разработка слоя доступа к данным.
    *   Стандартизированный подход к ORM (JPA).
    *   Декларативное управление транзакциями и валидация.
    *   Автоматическое управление полями аудита времени с минимальной конфигурацией.
    *   Гибкая стратегия генерации ID (`SEQUENCE`), подходящая для пакетных операций и получения ID до вставки.
    *   Проверка консистентности схемы при старте.
*   **Отрицательные/Затраты:**
    *   Необходимо явно создавать и управлять sequence'ами в базе данных через миграции Liquibase.
    *   Конфигурация `@SequenceGenerator` для каждой сущности с автогенерируемым ID.
    *   Некоторое (обычно незначительное) снижение производительности пакетных вставок по сравнению с `IDENTITY`, если не используется оптимизация получения ID из sequence (например, `allocationSize` > 1).
*   **Необходимые действия:**
    *   Включить зависимости `spring-boot-starter-data-jpa` и `spring-boot-starter-validation`.
    *   При создании миграций для таблиц с автоинкрементными ID, создавать соответствующие sequence (например, `CREATE SEQUENCE users_id_seq START 1 INCREMENT 1;`).
    *   В JPA-сущностях использовать `@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "entity_id_seq")` и `@SequenceGenerator(name = "entity_id_seq", sequenceName = "entity_id_seq", allocationSize = 1)`.
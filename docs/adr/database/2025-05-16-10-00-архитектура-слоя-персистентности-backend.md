**ADR-0029: Определение Архитектуры Слоя Персистентности для Backend Сервисов**

*   **Статус:** Утвержден
*   **Дата:** 2025-05-16
*   **Заменяет:** ADR-0005
*   **Связанные ADR:**
    *   ADR-0002: Использование PostgreSQL в качестве основной реляционной СУБД
    *   ADR-0004: Использование Liquibase для управления миграциями базы данных
    *   ADR-0012: Обеспечение консистентности времени через использование UTC
    *   ADR-0027: Использование `java.time.Clock` для Управления Временем

## 1. Контекст

Для бэкенд-сервисов проекта "Task Tracker" требуется стандартизированный и эффективный подход к взаимодействию с реляционной базой данных (PostgreSQL, согласно ADR-0002). Необходимо выбрать технологии и паттерны для маппинга объектов на реляционную структуру (ORM), управления транзакциями, выполнения запросов и обеспечения валидации данных на уровне персистентности. Схема базы данных управляется через Liquibase (согласно ADR-0004). Важно также предусмотреть гибкость для будущих потребностей, таких как пакетные операции и тестируемость компонентов, зависящих от времени.

## 2. Принятое Решение

1.  **ORM и Стандарт:** Использовать **Jakarta Persistence API (JPA)** как стандарт для объектно-реляционного отображения. В качестве реализации JPA использовать **Hibernate**.
2.  **Доступ к данным:** Использовать **Spring Data JPA** для упрощения создания слоя доступа к данным (репозиториев).
3.  **Управление транзакциями:** Использовать декларативное управление транзакциями Spring (`@Transactional`).
4.  **Валидация сущностей:** Использовать аннотации **Jakarta Bean Validation** на полях JPA-сущностей. Сообщения валидации должны извлекаться из Resource Bundle (согласно ADR-0024).
5.  **Аудит временных меток:** Для полей, отслеживающих время создания и последнего обновления сущностей (например, `createdAt`, `updatedAt`):
    *   Тип данных `java.time.Instant` в Java-сущностях (соответствует `TIMESTAMPTZ` в PostgreSQL, согласно ADR-0012).
    *   Использовать аннотации **Spring Data JPA Auditing (`@CreatedDate`, `@LastModifiedDate`)**.
    *   Активировать JPA Auditing с помощью `@EnableJpaAuditing(dateTimeProviderRef = "auditingDateTimeProvider")` в конфигурационном классе (например, `AppConfig`).
    *   Предоставить кастомный бин `DateTimeProvider` с именем `auditingDateTimeProvider`, который использует инжектированный бин `java.time.Clock` (сконфигурированный на UTC, согласно ADR-0027) для получения текущего времени. Это обеспечивает консистентность времени и улучшает тестируемость.
    *   Сущности, подлежащие аудиту, должны быть аннотированы `@EntityListeners(AuditingEntityListener.class)`.
6.  **Генерация первичных ключей:** По умолчанию для автоинкрементных первичных ключей использовать стратегию JPA **`@GeneratedValue(strategy = GenerationType.SEQUENCE)`** в сочетании с аннотацией **`@SequenceGenerator`**.
    *   Это обеспечивает получение ID до фактической вставки (`INSERT`) в базу данных, что полезно для снижения нагрузки на базу и/или для пакетных операций, где ID могут быть нужны заранее.
    *   Каждая сущность, требующая автогенерируемого ID, будет иметь свой собственный именованный sequence в базе данных (например, `users_id_seq`, `tasks_id_seq`), который будет создаваться через миграции Liquibase.
    *   Стратегия `GenerationType.IDENTITY` будет рассматриваться только в исключительных случаях, если для конкретной сущности она будет явно более подходящей и не будет ожидаться пакетных операций с предварительным получением ID.
7.  **Проверка соответствия схемы:** Настроить Hibernate на проверку соответствия JPA-сущностей схеме БД, созданной Liquibase, используя свойство `spring.jpa.hibernate.ddl-auto: validate`.

## 3. Рассмотренные Альтернативы

1.  **Чистый JDBC:**
    *   *Причина отклонения:* Слишком трудоемко, увеличивает время разработки.
2.  **Другие ORM/Data Mapping фреймворки (MyBatis, jOOQ):**
    *   *Причина отклонения:* Spring Data JPA с Hibernate является стандартом в экосистеме Spring, обеспечивает хороший баланс удобства и мощности.
3.  **Hibernate `ddl-auto: update` или `create` для управления схемой:**
    *   *Причина отклонения:* Рассмотрено в ADR-0004 (Выбор Liquibase). Недостаточная надежность и контроль.
4.  **Аудит времени через аннотации Hibernate (`@CreationTimestamp`, `@UpdateTimestamp`):**
    *   *Описание:* Использование аннотаций, специфичных для Hibernate.
    *   *Плюсы:* Простота, не требуют дополнительной конфигурации `@EnableJpaAuditing`.
    *   *Минусы:* Привязка к Hibernate. Не используют стандартный механизм Spring Data JPA Auditing. Менее гибко в плане предоставления кастомного `DateTimeProvider` для тестирования времени, если не интегрировать с `java.time.Clock` через Hibernate-специфичные механизмы (что может быть сложнее).
    *   *Причина отклонения:* Выбрано решение Spring Data JPA Auditing с кастомным `DateTimeProvider` на основе `Clock` как более стандартное в экосистеме Spring, лучше интегрируемое с ADR-0027 и предоставляющее большую гибкость для тестирования и будущего расширения (например, для аудита пользователя).
5.  **Стратегия генерации ID `GenerationType.IDENTITY` по умолчанию:**
    *   *Описание:* ID генерируется базой данных в момент `INSERT`.
    *   *Плюсы:* Проста в настройке для СУБД с поддержкой автоинкрементных колонок (как `BIGSERIAL` в PostgreSQL).
    *   *Минусы:* ID становится доступен только после фактической вставки в БД, что затрудняет некоторые сценарии, включая пакетные операции с предварительным назначением ID или установку связей до сохранения родительской сущности.
    *   *Причина отклонения (как дефолтной стратегии):* `SEQUENCE` предоставляет большую гибкость для будущих потребностей, особенно для пакетных операций, и был выбран как предпочтительный по умолчанию, несмотря на необходимость явного создания sequence'ов.

## 4. Последствия

*   **Положительные:**
    *   Быстрая разработка слоя доступа к данным.
    *   Стандартизированный подход к ORM (JPA).
    *   Декларативное управление транзакциями и валидация.
    *   Тестируемый и консистентный аудит временных меток благодаря Spring Data JPA Auditing и `Clock`.
    *   Гибкая стратегия генерации ID (`SEQUENCE`), подходящая для пакетных операций и получения ID до вставки.
    *   Проверка консистентности схемы при старте.
*   **Отрицательные/Затраты:**
    *   Необходимо настроить `@EnableJpaAuditing` и бин `DateTimeProvider`.
    *   Необходимо явно создавать и управлять sequence'ами в базе данных через миграции Liquibase для каждой сущности с автогенерируемым ID.
    *   Конфигурация `@SequenceGenerator` для каждой сущности с автогенерируемым ID.
    *   Некоторое (обычно незначительное) снижение производительности пакетных вставок по сравнению с `IDENTITY`, если не используется оптимизация получения ID из sequence (например, `allocationSize` > 1).
*   **Необходимые действия:**
    *   Включить зависимости `spring-boot-starter-data-jpa` и `spring-boot-starter-validation`.
    *   Настроить `AppConfig` с `@EnableJpaAuditing` и бинами `Clock` и `DateTimeProvider`.
    *   В JPA-сущностях использовать `@EntityListeners(AuditingEntityListener.class)` и аннотации `@CreatedDate`, `@LastModifiedDate`.
    *   При создании миграций для таблиц с автоинкрементными ID, создавать соответствующие sequence (например, `CREATE SEQUENCE users_id_seq START 1 INCREMENT 1;`).
    *   В JPA-сущностях использовать `@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "entity_id_seq")` и `@SequenceGenerator(name = "entity_id_seq", sequenceName = "entity_id_seq", allocationSize = 1)`. (Имена генератора и sequence должны быть уникальны для каждой сущности).
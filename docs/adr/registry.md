## ADR-0001: Выбор Java/Spring Boot для бэкенда и ориентация на микросервисный подход

Использовать Java и Spring Boot для разработки бэкенд-сервисов. Проект будет развиваться с прицелом на микросервисную архитектуру. Использовать Maven для сборки.

## ADR-0002: Использование PostgreSQL в качестве основной реляционной СУБД

Использовать PostgreSQL

## ADR-0003: Внедрение комплексного стека обсервабилити (OTel, Prometheus, Grafana, Loki, Tempo)

Использовать OpenTelemetry (OTel) как стандарт для сбора телеметрии. Интегрировать стек: Prometheus для метрик, Loki для логов, Tempo для трейсов, Grafana для визуализации, OTel Collector для сбора и процессинга.

## ADR-0004: Использование Liquibase для управления миграциями базы данных

Использовать **Liquibase** в качестве инструмента для управления миграциями схемы базы данных. Миграции будут писаться в формате YAML и интегрироваться с жизненным циклом Spring Boot приложения, так что они будут автоматически применяться при старте приложения.

## ADR-0005: Определение Архитектуры Слоя Персистентности для Backend Сервисов

Поглощен ADR-0029

## ADR-0006: Использование Timestamp-based именования для файлов миграций Liquibase

Использовать **именование файлов миграций Liquibase на основе временной метки (timestamp-based naming)**.
Формат имени файла будет следующим: `YYYY-MM-DD-HH-MM-SS-краткое-описательное-имя.yaml`.
Например: `2025-05-09-10-30-00-create-users-table.yaml`.
Временная метка соответствует моменту создания (или коммита) файла миграции.

## ADR-0007: Использование структуры пакетов по доменам (фичам) в Backend сервисе

Использовать **организацию пакетов по доменам (фичам)** для бэкенд-сервиса `task-tracker-backend`.
Это означает, что пакеты верхнего уровня будут соответствовать основным бизнес-областям или функциональным возможностям системы. Например:
- `com.example.tasktracker.backend.user` (для всего, что связано с пользователями и аутентификацией)
- `com.example.tasktracker.backend.task` (для управления задачами)
- `com.example.tasktracker.backend.notification` (для отправки уведомлений)
Внутри каждого пакета домена компоненты могут быть сгруппированы по техническим слоям (например, `controller`, `service`, `entity`, `repository`, `dto`), но основной принцип группировки — принадлежность к фиче.
Также будут существовать общие пакеты на верхнем уровне для конфигураций и переиспользуемых компонентов, не относящихся к конкретному домену, например:
- `com.example.tasktracker.backend.config` (общие конфигурации Spring)
- `com.example.tasktracker.backend.common` (общие утилиты, исключения, модели)

## ADR-0008: Использование Testcontainers для интеграционных тестов базы данных

Использовать **Testcontainers** для проведения интеграционных тестов слоя персистентности (в частности, для тестирования Spring Data JPA репозиториев).
Testcontainers будут использоваться для запуска Docker-контейнера с PostgreSQL непосредственно из кода тестов. Каждый тестовый класс (или тестовый набор) будет работать с чистым, изолированным экземпляром базы данных. Интеграция со Spring Boot будет осуществляться с помощью `spring-boot-testcontainers` и аннотации `@ServiceConnection` для автоматической настройки `DataSource`.

## ADR-0009: Определение стратегии обсервабилити и выбор технологического стека

Superseded by ADR-0028
	
## ADR-0010: Выбор и конфигурация CI-сервера и агента для сборки и тестирования

1.  **CI-сервер:** Использовать **Jenkins**, развернутый в Docker-контейнере на основной VPS. Образ `jenkins/jenkins:lts-jdk21` (или аналогичный с нужной версией JDK).
2.  **Jenkins Агент:** Использовать **внешний Jenkins агент**, установленный и работающий непосредственно на **хост-машине VPS Ubuntu 22**.
    *   **Подключение к Master:** Агент подключается к Jenkins Master (в Docker) через JNLP (или WebSocket).
    *   **Метка Агента:** Агенту присвоена метка (label) `ubuntu-docker` для использования в `Jenkinsfile`.
    *   **Доступ к Docker:** Пользователь, от имени которого работает агент на VPS, добавлен в группу `docker`, что обеспечивает агенту прямой доступ к Docker-демону хост-машины. Это необходимо для запуска Testcontainers.
    *   **Управление:** Агент настроен как systemd сервис для автоматического запуска при старте VPS.
3.  **`Jenkinsfile`:** Пайплайн Jenkins определяется в `Jenkinsfile` в корне репозитория, используется декларативный синтаксис.
4.  **Профиль для CI:** В приложении Spring Boot используется профиль `ci` (`application-ci.yml`) для специфичных настроек во время выполнения на CI-агенте (например, уровни логирования, отключение OTel SDK).

## ADR-0011: Стратегия конфигурации локального dev-окружения с использованием Docker Compose и Spring Boot профилей

1.  **Инфраструктура через `docker-compose.yml`:** Все внешние зависимости для локальной разработки (PostgreSQL, Kafka, OTel Collector, Prometheus, Grafana, Loki, Tempo) определяются и запускаются через единый `docker-compose.yml` файл в корне проекта.
2.  **Spring Boot профиль `dev`:**
    *   Приложение `task-tracker-backend`, запущенное из IDE, использует профиль `dev` (активируется через VM Option `-Dspring.profiles.active=dev`).
    *   **`application-dev.yml`:**
        *   URL для подключения к PostgreSQL: `jdbc:postgresql://postgres:5432/task_tracker_db` (при наличии соответствующей записи в `hosts` файле, указывающей на `127.0.0.1`).
        *   Учетные данные для PostgreSQL (`spring.datasource.username`, `spring.datasource.password`): **Жестко прописаны** как `devuser` и `devpass`, чтобы соответствовать конфигурации PostgreSQL в `docker-compose.yml`.
        *   Включено детальное логирование SQL (`show-sql: true`, `format-sql: true`, уровни DEBUG/TRACE для Hibernate).
        *   OTel SDK включен, сэмплирование трейсов 100%.
        *   Эндпоинт OTel Collector для отправки телеметрии: `http://otel-collector:4318` (предполагая, что порт OTel Collector проброшен на хост).
3.  **Разрешение имен сервисов:** Для удобства подключения к сервисам, запущенным в Docker, из приложения на хосте (если используется имя сервиса, а не `localhost`), разработчики могут добавить соответствующие записи в свой локальный `hosts` файл (например, `127.0.0.1 postgres`, `127.0.0.1 otel-collector`).

## ADR-0012: Обеспечение консистентности времени через использование UTC во всех компонентах системы

1.  **Стандартный Часовой Пояс для Серверной Логики и Хранения:** Все серверные компоненты (приложение `task-tracker-backend`, база данных PostgreSQL, в будущем другие микросервисы) должны работать и хранить все временные метки в **UTC (Coordinated Universal Time)**.
2.  **Конфигурация JVM:** Для приложения `task-tracker-backend` при запуске из IDE (в `dev` профиле) и при выполнении тестов на CI-агенте (через Maven Surefire Plugin) будет установлена системная переменная JVM `-Duser.timezone=UTC`. *Примечание: Настройка для Docker-контейнера приложения отложена до этапа контейнеризации.*
3.  **Конфигурация Базы Данных (PostgreSQL):**
    *   Сервер PostgreSQL (запускаемый в Docker) по умолчанию инициализируется и работает в часовом поясе UTC. Это поведение будет сохранено.
    *   Для колонок, хранящих временные метки (например, `created_at`, `updated_at` в таблице `users`), используется тип данных **`TIMESTAMP WITH TIME ZONE` (TIMESTAMPTZ)**. В PostgreSQL этот тип данных хранит значение как момент времени в UTC, а при извлечении конвертирует его в часовой пояс сессии клиента (если он отличается).
4.  **Обработка времени в Java-коде:**
    *   Для представления моментов времени в Java-сущностях и DTO используется тип `java.time.Instant`, который всегда представляет собой точку на временной шкале UTC.
    *   Любые операции с датой/временем на сервере, требующие знания текущего момента, должны получать его как момент в UTC (например, через `@CreationTimestamp`, `@UpdateTimestamp` от Hibernate, которые работают с учетом часового пояса JVM, или `Instant.now()`).
5.  **Ответственность Фронтенда за Локальное Время Пользователя:**
    *   **Фронтенд-приложение несет ответственность за определение локального часового пояса пользователя.**
    *   При отправке любых данных, содержащих время, на бэкенд (например, дедлайн задачи), фронтенд должен **конвертировать это локальное время пользователя в UTC** и отправлять на бэкенд уже в UTC (например, в формате ISO 8601 с указанием `Z` или смещения +00:00).
    *   При получении данных от бэкенда (которые всегда будут в UTC), фронтенд несет ответственность за их конвертацию в локальный часовой пояс пользователя для корректного отображения.
	
## ADR-0013: Стандарты и подходы к документированию архитектурных решений и диаграмм

1.  **Architecture Decision Records (ADR):**
    *   **Назначение:** Для фиксации всех архитектурно значимых решений, их контекста, рассмотренных альтернатив и последствий.
    *   **Формат:** Markdown (`.md`).
    *   **Хранение:** В Git-репозитории, в директории `docs/adr/`.
    *   **Структура директорий ADR:** ADR группируются по тематическим поддиректориям (например, `common`, `backend-service`, `database`, `observability`, `ci-cd`, etc.) внутри `docs/adr/` для лучшей организации.
    *   **Именование файлов ADR:** Используется формат `YYYY-MM-DD-HH-MM-краткое-описательное-имя.md` (например, `2025-05-10-10-00-пример-решения.md`). Временная метка обеспечивает глобальную хронологию и уникальность.
    *   **Шаблон ADR:** Используется стандартный шаблон, включающий как минимум: Заголовок (с номером ADR), Статус, Дату, Контекст, Принятое Решение, Рассмотренные Альтернативы, Последствия. Номер ADR присваивается последовательно (например, ADR-0001, ADR-0002).
    *   **Процесс:** Решения обсуждаются командой; ответственный (обычно архитектор или тимлид) формулирует ADR; ADR может проходить неформальное ревью командой.
2.  **Архитектурные Диаграммы (C4 Model):**
    *   **Назначение:** Для визуализации архитектуры на различных уровнях абстракции (Контекст, Контейнеры, Компоненты).
    *   **Инструмент:** `draw.io` для создания и редактирования диаграмм.
    *   **Исходный формат:** Файлы `.drawio` (XML) сохраняются в Git.
    *   **Формат для публикации/документации:** Диаграммы экспортируются в формат **WebP (lossless)** для вставки в Markdown-документы (ADR, README).
    *   **Хранение:** Исходники (`.drawio`) и экспортированные изображения (`.webp`) хранятся в Git-репозитории в директории `docs/diagrams/`. Для детализирующих диаграмм используются поддиректории, соответствующие элементу верхнего уровня (например, `docs/diagrams/task-tracker-system/backend-api/`).
    *   **Именование файлов диаграмм:** `c4-L[Уровень]-описание.drawio` и `c4-L[Уровень]-описание.webp` (например, `c4-L1-system-context.webp`, `c4-L2-containers-task-tracker-system.webp`).
3.  **Файлы `README.md`:**
    *   **Корневой `README.md`:** Содержит общее описание проекта, инструкции по запуску, ссылки на ключевые разделы документации (включая ADR и диаграммы).
    *   **`README.md` на уровне модулей/сервисов:** Содержат специфичную информацию для данного модуля.
4.  **Confluence (или аналогичная Wiki):**
    *   Используется для хранения "живой" информации, не подходящей для Git: практические гайды, протоколы встреч (если не формализованы в ADR), информация о команде, общие процессы.
    *   Не используется для дублирования ADR или диаграмм, которые хранятся в Git. Может содержать обзорные страницы со ссылками на документацию в Git.

## ADR-0014: Процессы принятия архитектурных решений, управления задачами и работы с системой контроля версий

**2.1. Процесс Принятия и Документирования Архитектурных Решений (ADR):**
    *   **Идентификация:** Любой член команды может инициировать обсуждение архитектурно значимого вопроса. Тимлид или архитектор определяет, требует ли вопрос формализации в виде ADR.
    *   **Обсуждение:** Решение обсуждается командой (на встречах, в чате, в комментариях к задаче). Рассматриваются различные варианты.
    *   **Формулирование ADR:** Ответственный (обычно тимлид, архитектор или разработчик, глубоко вовлеченный в проблему) создает черновик ADR в соответствии с принятым шаблоном (см. ADR-0013).
    *   **Ревью ADR (неформальное):** Черновик ADR может быть рассмотрен другими членами команды для получения обратной связи.
    *   **Утверждение:** Решение и ADR считаются принятыми после согласования с тимлидом/архитектором. Статус ADR меняется на "Accepted".
    *   **Хранение:** ADR хранится в Git-репозитории в `docs/adr/` и версионируется вместе с кодом.
    *   **Обновление:** Принятые ADR не изменяются. Если решение пересматривается, создается новый ADR, который ссылается на старый и указывает его новый статус (Deprecated, Superseded).

**2.2. Формализация и Выделение Фич/Задач:**
    *   **Источник:** Требования (ТЗ, User Stories), технический долг, предложения по улучшению.
    *   **Декомпозиция:** Крупные фичи разбиваются на более мелкие, управляемые задачи (например, в Jira).
    *   **Приоритезация:** Задачи приоритезируются в рамках бэклога спринта/проекта.
    *   **Связь с ADR:** Если реализация задачи требует принятия архитектурно значимого решения, создается или обновляется соответствующий ADR.

**2.3. Правила Работы с Ветками (GitHub Flow - адаптированный):**
    *   **`main`:** Основная стабильная ветка. Всегда должна быть в состоянии, готовом к деплою (или отражать последний деплой). Прямые коммиты в `main` запрещены. Слияние только через Pull Request (PR) / Merge Request (MR).
    *   **Feature-ветки (`feature/название-фичи` или `feature/TTN-описание`):** Для каждой новой фичи, улучшения или значимой задачи создается отдельная ветка от актуального состояния `main`.
        *   Именование: `feature/TTN-kratkoe-opisanie` (где TTN - номер задачи в Jira, если используется) или `feature/kratkoe-opisanie-logicheskoy-celi`.
    *   **Bugfix-ветки (`bugfix/название-бага` или `bugfix/TTN-описание`):** Для исправления багов. Создаются от `main` (если баг в текущем релизе) или от соответствующей feature-ветки (если баг найден в ходе разработки фичи).
    *   **Hotfix-ветки (`hotfix/название-хотфикса`):** (Если потребуется для "боевых" ситуаций) Для срочных исправлений в продакшене. Создаются от тега релиза на `main`, мержуются обратно в `main` и в активные feature-ветки.
    *   **Регулярное обновление feature-веток:** Разработчики должны регулярно обновлять свои feature-ветки последними изменениями из `main`. Предпочтительно использовать `git rebase origin/main` для поддержания чистой и линейной истории коммитов в feature-ветке перед созданием PR. В случае сложных или длительных конфликтов при rebase, допустимо использовать `git merge origin/main` в feature-ветку.

**2.4. Правила для Коммитов:**
    *   **Атомарность:** Коммит должен представлять одно логическое изменение.
    *   **Сообщения коммитов:** Использовать стандарт Conventional Commits (например, `feat: ...`, `fix: ...`, `docs: ...`, `refactor: ...`, `test: ...`, `chore: ...`).
        *   Заголовок должен быть кратким и информативным.
        *   Тело коммита (если нужно) должно объяснять "что" и "почему", а не "как".
    *   **Частота:** Коммитить часто, небольшими порциями.

**2.5. Правила Слияния (Pull Request / Merge Request Workflow):**
    *   **Создание PR:** После завершения работы в feature/bugfix-ветке и локального тестирования, разработчик создает PR в `main`.
    *   **Описание PR:** PR должен иметь четкое описание проделанной работы, ссылки на задачи в Jira (если используются), инструкции по тестированию (если нужны).
    *   **CI-проверка:** Автоматический CI-пайплайн (Jenkins) должен успешно пройти для PR (сборка, все тесты).
    *   **Код-ревью:** Обязательное код-ревью как минимум одним другим членом команды (предпочтительно тимлид или другой senior-разработчик). Все замечания должны быть устранены.
    *   **Слияние:** После успешного CI и одобрения ревью, PR может быть смержен.
        *   **Метод слияния:** Предпочтительным методом является **"Rebase and merge"**. Это обеспечивает линейную историю коммитов в ветке `main`. Если `rebase` feature-ветки на `main` вызывает значительные или трудноразрешимые конфликты (например, из-за длительного существования ветки или большого количества пересекающихся изменений), в качестве альтернативы допустимо использовать **"Merge commit"** (со стандартным merge-коммитом, без squash).
    *   **Удаление ветки:** После мержа feature/bugfix-ветка удаляется из удаленного репозитория.

## ADR-0015: Стратегия и подходы к тестированию в проекте "Task Tracker"

**2.1. Юнит-тесты (Unit Tests):**
    *   **Цель:** Тестирование отдельных, изолированных компонентов (классов, методов) на корректность их логики.
    *   **Инструменты:** JUnit 5, Mockito.
    *   **Область применения:** Сервисный слой (бизнес-логика), утилитарные классы, отдельные сложные методы в контроллерах или других компонентах.
    *   **Изоляция:** Зависимости должны быть замоканы для обеспечения изоляции тестируемого юнита.
    *   **Скорость:** Должны быть очень быстрыми.
    *   **Запуск:** Выполняются на фазе `test` Maven плагином Surefire. Запускаются часто локально и всегда на CI.

**2.2. Интеграционные тесты (Integration Tests):**
    *   **Цель:** Тестирование взаимодействия между несколькими компонентами системы или интеграции с внешними зависимостями (база данных, брокеры сообщений, внешние API).
    *   **Типы интеграционных тестов (на текущем этапе и в ближайшем будущем):**
        *   **Тесты слоя персистентности:** Проверка корректности работы Spring Data JPA репозиториев и их взаимодействия с реальной базой данных.
            *   **Инструменты:** Spring Boot Test (`@SpringBootTest` или `@DataJpaTest`), Testcontainers (для PostgreSQL).
        *   **Тесты API/Контроллеров (когда появятся контроллеры):** Проверка работы REST API эндпоинтов, включая валидацию запросов, корректность ответов, обработку ошибок, интеграцию с сервисным слоем.
            *   **Инструменты:** Spring Boot Test (`@SpringBootTest` с `WebEnvironment.MOCK` или `RANDOM_PORT`), MockMvc или RestAssured. Testcontainers могут использоваться, если эндпоинты зависят от БД.
        *   **Тесты взаимодействия с Kafka (когда появится Kafka):** Проверка отправки и получения сообщений.
            *   **Инструменты:** Spring Boot Test, Embedded Kafka (для Spring Kafka) или Testcontainers для Kafka.
    *   **Скорость:** Медленнее юнит-тестов, так как требуют поднятия контекста Spring и/или внешних зависимостей.
    *   **Запуск:**
        *   **Локально:** Могут запускаться разработчиком по необходимости.
        *   **CI:** Обязательно выполняются на CI-сервере.
        *   **Maven:** Будут настроены для запуска плагином Failsafe на фазах `integration-test` и `verify`. Пока запускаются Surefire вместе с юнит-тестами.

**2.3. Контрактные тесты (Contract Tests - видение на будущее):**
    *   **Цель:** (Когда появятся несколько взаимодействующих микросервисов) Проверка соблюдения контрактов (API) между сервисами-провайдерами и сервисами-консьюмерами.
    *   **Инструменты:** Например, Spring Cloud Contract.
    *   **Статус:** На данном этапе не реализуются, но учитываются как возможный следующий шаг при развитии микросервисной архитектуры.

**2.4. End-to-End (E2E) тесты (видение на будущее):**
    *   **Цель:** Тестирование всей системы как "черного ящика" через пользовательский интерфейс (если он будет сложным) или через публичные API, имитируя реальные пользовательские сценарии.
    *   **Инструменты:** Selenium, Cypress, Playwright (для UI); Postman/Newman, Karate DSL (для API E2E).
    *   **Статус:** На данном этапе не реализуются.

**2.5. Покрытие Кода (Code Coverage):**
    *   **Цель:** Измерение процента кода, покрытого автоматическими тестами. Служит индикатором, но не самоцелью.
    *   **Инструменты:** JaCoCo (для Java).
    *   **Процесс:** Отчеты о покрытии будут генерироваться на CI и могут быть интегрированы в Jenkins для визуализации.
	
## ADR-0016: Конвенции и инструменты для интеграционного тестирования JPA и CI-отчетности

1.  **Именование интеграционных тестов:**
    *   Интеграционные тесты, предназначенные для выполнения Maven Failsafe Plugin, должны именоваться с использованием суффикса `IT`. Например: `UserRepositoryIT.java`. Это соответствует стандартным паттернам Failsafe и упрощает конфигурацию.

2.  **Тестирование слоя JPA (Репозитории):**
    *   Для интеграционных тестов компонентов слоя JPA (например, Spring Data JPA репозиториев) рекомендуется использовать аннотацию `@DataJpaTest`.
    *   Эта аннотация загружает сфокусированный срез контекста Spring, необходимый для JPA, автоматически настраивает транзакционность для тестовых методов (с откатом по умолчанию) и может использоваться совместно с Testcontainers (через `@ServiceConnection`) для тестирования на реальной СУБД.

3.  **Отчетность по результатам тестов в CI (Jenkins):**
    *   Jenkins пайплайн настроен на сбор и публикацию результатов юнит-тестов (выполняемых Surefire) и интеграционных тестов (выполняемых Failsafe).
    *   Для этого используется стандартный шаг `junit` в `Jenkinsfile`, который обрабатывает XML-отчеты, генерируемые Maven-плагинами.

4.  **Отчетность по покрытию кода в CI (Jenkins):**
    *   Для сбора данных о покрытии кода используется JaCoCo Maven Plugin, настроенный на сбор данных как от юнит-, так и от интеграционных тестов в единый файл `jacoco.exec`.
    *   Для публикации и визуализации отчетов о покрытии в Jenkins используется "coverage plugin" через шаг `recordCoverage` в `Jenkinsfile`. Пайплайн настроен на обработку XML-отчета `jacoco.xml`.
	
## ADR-0017: Спецификация JWT и Обоснование Выбора

Использовать JSON Web Tokens (JWT)**

    1.  **Обоснование выбора JWT:**
        *   **Stateless:** Серверу не нужно хранить состояние сессии пользователя, что упрощает масштабирование и подходит для распределенных систем.
        *   **Self-contained:** Токен содержит всю необходимую информацию (claims) для идентификации пользователя и базовой авторизации, уменьшая необходимость частых обращений к БД или серверу аутентификации для валидации.
        *   **Стандарт (RFC 7519):** Широко распространенный и поддерживаемый стандарт с множеством библиотек.
        *   **Гибкость:** Подходит для различных типов клиентов (веб, мобильные).
        *   **Безопасность (при правильном использовании):** Подписанные токены защищены от подделки. Использование HTTPS для передачи токенов защищает от их перехвата.

    2.  **Тип используемого токена:**
        *   Будет использоваться только **Access Token**.
        *   **Refresh Token:** На данном этапе **не используется** для упрощения архитектуры. Пользователю потребуется пройти повторную аутентификацию (логин) после истечения срока действия Access Token.

    3.  **Спецификация Access Token:**
        *   **3.1. Алгоритм Подписи:**
            *   **Текущая реализация:** Симметричный алгоритм **HS256 (HMAC with SHA-256)**. Секретный ключ для подписи будет генерироваться и управляться через переменные окружения.
            *   **Перспектива:** Архитектура должна предусматривать возможность конфигурации для поддержки асимметричных алгоритмов (например, RS256) при будущей интеграции с внешними Identity Provider (IdP).
        *   **3.2. Состав (Claims):**
            *   `iss` (Issuer): Идентификатор сервиса, выдавшего токен (например, URI или имя сервиса `task-tracker-backend`).
            *   `sub` (Subject): **Уникальный числовой идентификатор пользователя (`Long id`)** из базы данных. Является основным идентификатором пользователя в контексте токена.
            *   `exp` (Expiration Time): Unix timestamp, определяющий время истечения срока действия токена.
            *   `iat` (Issued At): Unix timestamp, определяющий время выдачи токена.
            *   `jti` (JWT ID): Уникальный идентификатор токена (рекомендуется для обеспечения уникальности и возможности отслеживания).
            *   `email` (Кастомный claim): Email адрес пользователя, связанного с `sub`. Предназначен для удобства использования на клиенте или в других сервисах.
            *   `authorities` (Кастомный claim): *Массив строк. Зарезервировано для будущего использования* (например, для передачи ролей пользователя, таких как `"ROLE_ADMIN"`).
        *   **3.3. Время Жизни:**
            *   **15-60 минут.** Конкретное значение настраивается через конфигурацию приложения. Короткое время жизни повышает безопасность, уменьшая окно для использования потенциально скомпрометированного токена.
        *   **3.4. Передача Клиентом:**
            *   Токен должен передаваться клиентом в HTTP-заголовке `Authorization` со схемой `Bearer`:
                `Authorization: Bearer <token>`
        *   **3.5. Отзыв Токенов (Revocation):**
            *   На данном этапе **не реализуется**, так как JWT по своей природе stateless. Операция Logout на стороне клиента будет заключаться в удалении токена из хранилища клиента.
			
## ADR-0018: Требования и Процесс Аутентификации Пользователя

1.  **Регистрация Нового Пользователя:**
	*   **Эндпоинт:** `POST /api/v1/users/register` (публично доступен).
	*   **Входные данные (Request Body):** JSON-объект, содержащий `email`, `password`, `repeatPassword`.
	*   **Проверки (Валидация):**
		*   Валидность формата email.
		*   Совпадение `password` и `repeatPassword`.
		*   Уникальность email в системе.
		*   *Требования к сложности и минимальной длине пароля на данном этапе не определены. Могут быть введены
		и задокументированы позже; может потребоваться механизм для обновления существующих паролей пользователей.*
	*   **Действия при успехе (HTTP 201 Created):**
		*   Создание новой записи пользователя в базе данных. Пароль должен храниться в хешированном виде с 
		использованием сильного, общепринятого алгоритма (например, BCrypt, предоставляемый стандартными
		реализациями `PasswordEncoder` из Spring Security).
		*   **Автоматическая аутентификация:** Пользователь считается аутентифицированным немедленно после 
		успешной регистрации.
		*   Генерация Access Token (согласно ADR-0017).
		*   Возврат JSON-ответа, содержащего Access Token. Рекомендуемая структура ответа:
		
			```json
			{
			  "access_token": "your_jwt_token_here",
			  "token_type": "Bearer",
			  "expires_in": 3600
			}
			```
			
		*   В HTTP-заголовке ответа X-Access-Token также ДОЛЖЕН содержаться выданный Access Token.
		*   В HTTP-ответе также **ДОЛЖЕН** присутствовать заголовок `Location` с URI созданного ресурса пользователя
		`api/v1/users/me`.
		*   Отправка приветственного email пользователю (асинхронно, через Kafka).
	*   **Действия при ошибке:**
		*   При ошибках валидации входных данных (неверный формат email, несовпадение паролей): 
		HTTP **400 Bad Request**.
		*   Если email уже занят: HTTP **409 Conflict**.
		*   Тело ответа во всех случаях ошибки должно быть в формате `application/problem+json` (RFC 9457),
		содержащим как минимум:
			*   `type`: URI, идентифицирующий тип проблемы (например, 
			`https://task-tracker.example.com/probs/validation-error`,
			`https://task-tracker.example.com/probs/email-already-taken`).
			Эти URI должны быть определены и задокументированы.
			*   `title`: Краткое, человекочитаемое описание типа проблемы.
			*   `status`: HTTP-статус код ответа (400 или 409).
			*   `detail`: Человекочитаемое описание конкретной ошибки.
			*   (Для ошибок валидации 400) Рекомендуется использовать расширение `errors` 
			(массив объектов), детализирующее ошибки по конкретным полям запроса, если это применимо.

2.  **Аутентификация (Логин) Существующего Пользователя:**
	*   **Эндпоинт:** `POST /api/v1/auth/login` (публично доступен).
	*   **Входные данные (Request Body):** JSON-объект, содержащий `email` и `password`.
	*   **Проверки:**
		*   Наличие пользователя с указанным email.
		*   Совпадение предоставленного пароля с сохраненным хешем.
	*   **Действия при успехе (HTTP 200 OK):**
		*   Генерация Access Token (согласно ADR-0017).
		*   Возврат JSON-ответа с Access Token, аналогично структуре при регистрации:
		
			```json
			{
			  "access_token": "your_jwt_token_here",
			  "token_type": "Bearer",
			  "expires_in": 3600
			}
			```
			
		*   В HTTP-заголовке ответа X-Access-Token также ДОЛЖЕН содержаться выданный Access Token.
	*   **Действия при ошибке (HTTP 401 Unauthorized):**
		*   Возврат HTTP-ответа со статус-кодом `401 Unauthorized`.
		*   Заголовок `WWW-Authenticate: Bearer realm="task-tracker"` **ДОЛЖЕН** быть включен. 
		Дополнительно **МОГУТ** быть включены параметры `error` (например, `"invalid_grant"`) и `error_description`
		(например, `"Invalid credentials"`), согласно RFC 6750.
		*   Тело ответа должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
			*   `type`: URI (например, `https://task-tracker.example.com/probs/invalid-credentials`).
			*   `title`: "Invalid Credentials" или аналогичное.
			*   `status`: 401.
			*   `detail`: "The email or password provided is incorrect."

3.  **Logout Пользователя:**
	*   Так как используются stateless JWT без серверного механизма отзыва (согласно ADR-0017), операция Logout
	является ответственностью **клиентской стороны** и заключается в безопасном удалении сохраненного Access Token.
	*   Серверный эндпоинт `/logout` на данном этапе **не реализуется**, так как он не предоставляет дополнительной 
	функциональности по аннулированию JWT на стороне сервера.

# ADR-0019: Требования и Механизмы Авторизации Доступа к Ресурсам

1.  **Основной Принцип Авторизации:**
	*   **Авторизация на основе владения ресурсом (Resource-based ownership):** Пользователь, идентифицированный 
	по `userId` (из `sub` claim JWT, согласно ADR-0017), может выполнять операции только над ресурсами, которые ему 
	принадлежат (т.е., связаны с его `userId`).
	*   **"Безопасные по умолчанию" репозитории:** Логика проверки владения должна быть максимально приближена к 
	слою доступа к данным.

2.  **Реализация Авторизации в Слоях:**

	*   **2.1. Слой Репозиториев (`TaskRepository` и аналогичные):**
		*   Является **основным местом** для реализации авторизации по владению ресурсом при операциях чтения.
		*   **Ограничение интерфейсов:** Интерфейсы репозиториев **не должны наследовать стандартные "всеобъемлющие"
		интерфейсы Spring Data JPA** (типа `JpaRepository`, `CrudRepository`) без явной и обоснованной необходимости.
		Вместо этого, они должны определять кастомный набор методов. Каждый такой метод, предназначенный для общего пользовательского доступа, по умолчанию должен быть "безопасным" (т.е., учитывать `userId` текущего пользователя).
		*   **Чтение данных (списки, одиночные сущности):** Авторизация встраивается непосредственно в JPQL/SQL 
		запросы с использованием **Security Expressions в аннотации `@Query`**, ссылающихся на `principal.id`.
			*   Пример для получения списка задач текущего пользователя:
				`@Query("SELECT t FROM Task t WHERE t.user.id = ?#{ principal.id }")`
			*   Пример для получения конкретной задачи текущего пользователя по ее ID:
				`@Query("SELECT t FROM Task t WHERE t.id = :taskId AND t.user.id = ?#{ principal.id }")`
			*   Если ресурс не принадлежит пользователю или не существует, такие запросы вернут пустой результат 
			(например, пустой список или `Optional.empty()`), что соответствует стратегии сокрытия информации.
		*   **Создание данных (`save` для новых сущностей):**
			*   Репозиторий предоставляет метод `save(S entity)`.
			*   Ответственность **сервисного слоя:** Установить корректный `userId` (полученный из `SecurityContext`)
			на новой сущности *перед* вызовом `save`.
			*   Поле `userId` в сущности `Task` (и аналогичных сущностях, принадлежащих пользователю) **ДОЛЖНО** 
			быть сконфигурировано как неизменяемое после первоначальной установки (JPA аннотация 
			`@Column(name = "user_id", nullable = false, updatable = false)`). Это предотвращает случайное или 
			намеренное изменение владельца ресурса через стандартные операции обновления.
		*   **Обновление данных (`save` для существующих сущностей):**
			*   Сервисный слой **ОБЯЗАН** сначала загрузить существующую сущность через "безопасный" метод 
			репозитория (например, `findByIdAndCurrentUser`). Это неявно подтверждает право пользователя на 
			модификацию (т.к. он смог ее прочитать).
			*   После модификации полей сущности в сервисном слое, вызывается тот же метод `save(S entity)`. 
			Неизменяемость поля `userId` гарантирует, что владелец не будет изменен.
		*   **Удаление данных:**
			*   Репозиторий **ДОЛЖЕН** предоставлять "безопасный" метод удаления, который включает проверку 
			`userId` непосредственно в запросе.
			*   Пример: `@Modifying @Query("DELETE FROM Task t WHERE t.id = :taskId AND t.user.id = ?#{ principal.id }")
			int deleteByIdAndCurrentUser(@Param("taskId") Long taskId);`
			*   Сервисный слой вызывает этот метод. Возвращаемое значение (количество удаленных записей) **ДОЛЖНО**
			использоваться для определения результата операции и формирования соответствующего HTTP-ответа:
			*   Если метод `deleteByIdAndCurrentUser` (или аналогичный безопасный метод удаления) вернул `0`, 
			это означает, что ресурс с указанным идентификатором (`taskId` в примере) либо не существует, либо не 
			принадлежит текущему аутентифицированному пользователю. В соответствии со стратегией сокрытия информации
			(см. п.5 данного ADR), сервисный слой **ДОЛЖЕН** интерпретировать этот результат как "ресурс не найден 
			для данного пользователя" и обеспечить возврат клиенту HTTP-ответа **404 Not Found** с телом в формате 
			Problem Details.
			*   Если метод вернул `1` (или ожидаемое положительное количество удаленных записей, если логика 
			удаления может затрагивать несколько сущностей по одному вызову), это означает успешное удаление 
			ресурса, принадлежащего текущему пользователю. В этом случае сервисный слой **ДОЛЖЕН** обеспечить 
			возврат клиенту HTTP-ответа **204 No Content** (без тела ответа).

	*   **2.2. Сервисный Слой (`TaskService` и аналогичные):**
		*   Использует **исключительно "безопасные" методы репозиториев** для всех операций, где важна принадлежность
		ресурса пользователю.
		*   Отвечает за установку `userId` для новых сущностей перед их сохранением.
		*   Для более сложных бизнес-правил авторизации, которые не могут быть полностью выражены на уровне запросов
		репозитория, или для защиты методов, не связанных напрямую с CRUD одной сущности, может использоваться 
		**Spring Method Security (`@PreAuthorize`, `@PostAuthorize`, `@PostFilter`)**.
		*   Логика таких проверок, если она сложная или переиспользуемая, инкапсулируется в отдельном Spring бине
		(например, `PermissionService`), методы которого вызываются из SpEL-выражений.
			Пример: `@PreAuthorize("@permissionService.canUserPerformComplexAction(authentication, #resourceId)")`.

	*   **2.3. `PermissionService` (или аналогичный бин):**
		*   Служит для централизации и инкапсуляции сложных или переиспользуемых правил авторизации, которые не 
		являются простым сопоставлением `userId`.
		*   Не должен дублировать базовую проверку владения, если она эффективно реализована на уровне репозитория.

3.  **Конфигурация Spring Security для Авторизации:**
	*   Использовать `@EnableMethodSecurity` для активации Method Security.
	*   Убедиться, что Java-код компилируется с флагом `-parameters` для корректной работы SpEL.
	*   Кастомная реализация `UserDetails` (из ADR-0018) должна предоставлять `id` пользователя для использования 
	в `?#{ principal.id }`.

4.  **Административный Доступ:**
	*   На данном этапе не реализуется в основном пользовательском API.
	*   Если в будущем потребуется административный доступ к ресурсам всех пользователей, он будет реализован через:
		*   Специальную роль (например, `ROLE_ADMIN`), включаемую в JWT администратора (см. ADR-0017).
		*   Проверки этой роли в `@PreAuthorize` (например, `@PreAuthorize("hasRole('ADMIN')")`).
		*   Отдельные "админские" методы в сервисах и/или репозиториях, которые не применяют стандартную фильтрацию
		по `userId` текущего пользователя, или используют для этого специальный параметр. Рассмотреть выделение таких операций в отдельные компоненты или даже сервисы.

5.  **Обработка Ошибок Авторизации:**
	*   При попытке доступа к чужому ресурсу или выполнения неразрешенного действия, API **ДОЛЖЕН** вернуть:
		*   Предпочтительно **HTTP 404 Not Found**, если операция касается конкретного ресурса по ID (например, 
		`GET /tasks/{taskId}`, `PUT /tasks/{taskId}`, `DELETE /tasks/{taskId}`). Это скрывает факт существования 
		ресурса от неавторизованного пользователя.
		*   **HTTP 403 Forbidden** в других случаях отказа авторизации (например, если пользователь аутентифицирован,
		но не имеет нужной роли для выполнения общего действия).
	*   Тело ответа во всех случаях ошибки должно быть в формате `application/problem+json` (RFC 9457), содержащим 
	как минимум:
		*   `type`: URI, идентифицирующий тип проблемы (например, 
		* `https://task-tracker.example.com/probs/access-denied`, 
		* `https://task-tracker.example.com/probs/resource-not-found`).
		*   `title`: Краткое описание типа проблемы.
		*   `status`: HTTP-статус код ответа (403 или 404).
		*   `detail`: Описание конкретной ошибки.

# ADR-0020: Архитектура Компонентов Безопасности в Backend Сервисе (`task-tracker-backend`)

1.  **Основная Конфигурация Spring Security (`SecurityConfig`):**
	*   Центральный конфигурационный класс, аннотированный `@Configuration` и `@EnableWebSecurity`.
	*   Активирует Method Security с помощью `@EnableMethodSecurity` для поддержки аннотаций типа `@PreAuthorize`.
	*   Определяет основной бин `SecurityFilterChain`, который конфигурирует:
		*   **Отключение CSRF:** `http.csrf(AbstractHttpConfigurer::disable)` (т.к. используется stateless JWT).
		*   **Управление Сессиями:** `http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`.
		*   **Правила Доступа к Эндпоинтам (`http.authorizeHttpRequests`):**
			*   Публичный доступ (`.permitAll()`) к эндпоинтам регистрации (например, `POST /api/v1/users/register`) и логина (например, `POST /api/v1/auth/login`).
			*   Требование аутентификации (`.authenticated()`) для всех остальных запросов.
		*   **Пользовательские Фильтры:** Добавление кастомного `JwtAuthenticationFilter` (см. п.2) в цепочку фильтров Spring Security (например, перед `UsernamePasswordAuthenticationFilter`).
		*   **Обработка Исключений Безопасности:** Настройка кастомных `AuthenticationEntryPoint` (см. п.5.2) и `AccessDeniedHandler` (см. п.5.3).
		*   **CORS Конфигурация:** Через `http.cors(cors -> cors.configurationSource(corsConfigurationSource()))`.
	*   Определяет бин `PasswordEncoder` (например, `BCryptPasswordEncoder`).
	*   Определяет бин `AuthenticationManager` (через `AuthenticationConfiguration`), который будет использоваться `AuthService` для процесса логина.

2.  **Фильтр Аутентификации JWT (`JwtAuthenticationFilter`):**
	*   Кастомный фильтр, наследующий `org.springframework.web.filter.OncePerRequestFilter`.
	*   **Ответственность:**
		*   Проверка, не был ли пользователь уже аутентифицирован ранее в цепочке.
		*   Извлечение JWT из заголовка `Authorization` (с префиксом "Bearer ").
		*   Если токен найден, использование `JwtValidator` (см. п.3.4) для его валидации и парсинга `Claims`.
		*   Если токен валиден и `Claims` извлечены, использование `JwtAuthenticationConverter` (см. п.3.5) для преобразования `Claims` в объект `Authentication`.
		*   Установка полученного объекта `Authentication` в `SecurityContextHolder`.
		*   В случае ошибки валидации JWT (от `JwtValidator`) или ошибки конвертации `Claims` (от `JwtAuthenticationConverter`), создание кастомного исключения `BadJwtException` и делегирование его обработки сконфигурированному `AuthenticationEntryPoint` (см. п.5.2). В этом случае цепочка фильтров прерывается.
	*   **Зависимости:** `JwtValidator`, `JwtAuthenticationConverter`, `AuthenticationEntryPoint`.

3.  **Компоненты для Работы с JWT:**
	*   **3.1. `JwtProperties`:**
		*   `@ConfigurationProperties` класс для type-safe доступа к конфигурационным параметрам JWT из `application.yml` (секретный ключ в Base64, время жизни, имена кастомных claims, согласно ADR-0017 и ADR-0022). Аннотирован `@Validated` для проверки свойств при старте.
	*   **3.2. `JwtKeyService`:**
		*   Сервис (`@Service`), ответственный за декодирование Base64-кодированного секретного ключа (полученного из `JwtProperties`), проверку его минимальной длины (для HS256) и предоставление готового к использованию экземпляра `javax.crypto.SecretKey`.
		*   Реализует принцип "fail-fast": приложение не стартует, если ключ некорректно сконфигурирован (невалидный Base64, недостаточная длина). Вся логика выполняется в конструкторе.
	*   **3.3. `JwtIssuer`:**
		*   Сервис (`@Service`), ответственный исключительно за генерацию (выпуск) JWT Access Tokens.
		*   **Зависимости:** `JwtProperties` (для времени жизни токена), `JwtKeyService` (для получения `SecretKey`), `java.time.Clock` (для установки `iat` и `exp` claims).
		*   Метод `generateToken(Authentication authentication)` создает JWT на основе `AppUserDetails` из `Authentication` объекта, включая `sub` (userId), `email` и `authorities` claims (согласно ADR-0017).
	*   **3.4. `JwtValidator`:**
		*   Сервис (`@Service`), ответственный за валидацию подписи и срока действия JWT, а также за парсинг `io.jsonwebtoken.Claims` из валидного токена.
		*   **Зависимости:** `JwtKeyService` (для получения `SecretKey`), `java.time.Clock` (для корректной валидации временных claims (`exp`, `nbf`)).
		*   Предоставляет методы, например, `boolean isValid(String token)` и `Optional<JwtValidationResult> validateAndParseToken(String token)`. `JwtValidationResult` – это кастомный объект, содержащий либо `Jws<Claims>`, либо информацию о типе ошибки валидации (`JwtErrorType`).
		*   Логирует ошибки валидации, используя сокращенный (безопасный) вид токена.
	*   **3.5. `JwtAuthenticationConverter`:**
		*   Компонент (`@Component`), ответственный за преобразование `Claims` (полученных из `JwtValidator`) в объект `org.springframework.security.core.Authentication` (обычно `UsernamePasswordAuthenticationToken` с `AppUserDetails` в качестве principal).
		*   **Зависимости:** `JwtProperties` (для получения имен кастомных claims для `email` и `authorities`).
		*   Создает `AppUserDetails` на основе `userId` (из `sub` claim) и `email` claim, а также (в будущем) `authorities` claim.

4.  **Компоненты Пользовательских Данных и Аутентификации:**
	*   **`UserLoadingService` (реализация `org.springframework.security.core.userdetails.UserDetailsService`):**
		*   Загружает пользователя из `UserRepository` по `email` (используется `AuthenticationManager` в процессе логина).
		*   Создает и возвращает `AppUserDetails`.
	*   **`AppUserDetails` (реализация `org.springframework.security.core.userdetails.UserDetails`):**
		*   Хранит `id` пользователя (для `principal.id` в SpEL), `email` (используемый как username), хешированный пароль и коллекцию `GrantedAuthority` (на данном этапе пустую, согласно ADR-0017).
	*   **`AuthService`:**
		*   Сервис (`@Service`), инкапсулирующий бизнес-логику регистрации и логина.
		*   **Регистрация:** Валидирует `RegisterRequest`, проверяет совпадение паролей, проверяет уникальность email (`UserRepository`), хеширует пароль (`PasswordEncoder`), сохраняет нового `User` (`UserRepository`), создает `Authentication` объект для нового пользователя и вызывает `JwtIssuer` для генерации JWT (авто-логин). Выбрасывает кастомные исключения (`UserAlreadyExistsException`, `PasswordMismatchException`) при ошибках.
		*   **Логин:** Принимает `LoginRequest`. Делегирует проверку кредов `AuthenticationManager`. При успехе вызывает `JwtIssuer` для генерации JWT. Пробрасывает `AuthenticationException` от `AuthenticationManager` в случае неудачи.

5.  **Обработка Ошибок API (согласно RFC 9457 `application/problem+json`):**
	*   **5.1. Общий Стандарт:** Все HTTP-ответы об ошибках (статус-коды 4xx-5xx), генерируемые приложением в результате исключений, **ДОЛЖНЫ** использовать `Content-Type: application/problem+json` и тело ответа **ДОЛЖНО** соответствовать структуре `ProblemDetail`, определенной в RFC 9457.
	*   **5.2. Поля `ProblemDetail`:**
		*   **`type` (URI):** Обязательное. URI, идентифицирующий тип проблемы. Строится путем конкатенации базового
			URI (`ApiConstants.PROBLEM_TYPE_BASE_URI`) с суффиксом, отражающим категорию и специфику ошибки.
			Рекомендуемый формат суффикса: `<category>` или `<category>.<specific_error>`.
			Примеры:
			*   `https://task-tracker.example.com/probs/jwt.expired`
			*   `https://task-tracker.example.com/probs/validation.methodArgumentNotValid`
			*   `https://task-tracker.example.com/probs/user.alreadyExists`
			*   `https://task-tracker.example.com/probs/auth.invalidCredentials`
		*   **`title` (String):** Обязательное. Извлекается из `MessageSource` (ADR-0024).
		*   **`status` (Integer):** Обязательное. HTTP-статус код.
		*   **`detail` (String):** Рекомендуемое. Извлекается из `MessageSource` (ADR-0024), может содержать параметры из исключения.
		*   **`instance` (URI):** Опциональное. Путь запроса.
		*   **Кастомные Расширения:** Поле `invalid_params` для ошибок валидации DTO; поле `error_type` для `BadJwtException`.
	*   **5.3. `GlobalExceptionHandler` (`@RestControllerAdvice`):**
		*   Центральный компонент для преобразования исключений в `ProblemDetail` ответы. Наследует `ResponseEntityExceptionHandler` для кастомизации обработки стандартных MVC исключений.
		*   Содержит `@ExceptionHandler` методы для:
			*   `BadJwtException` (кастомное): Формирует `ProblemDetail` с HTTP 401, специфичным `type` URI (на основе `JwtErrorType`), `title` и `detail` из `MessageSource`, и кастомным свойством `error_type`.
			*   `AuthenticationException` (общее, например, `BadCredentialsException`): Формирует `ProblemDetail` с HTTP 401, `title` и `detail` из `MessageSource`.
			*   `AccessDeniedException`: Формирует `ProblemDetail` с HTTP 403 (или 404 согласно ADR-0019), `title` и `detail` из `MessageSource`.
			*   Кастомных бизнес-исключений (`UserAlreadyExistsException`, `PasswordMismatchException`): Формируют `ProblemDetail` с HTTP 409/400, `title` и `detail` из `MessageSource`.
			*   Ошибок валидации (`jakarta.validation.ConstraintViolationException`, `org.springframework.web.bind.MethodArgumentNotValidException`): Формируют `ProblemDetail` с HTTP 400, `title` и `detail` из `MessageSource`, и кастомным свойством `invalid_params` со списком ошибок полей.
		*   При отсутствии ключа для `title` или `detail` в `MessageSource`, выбрасывается `NoSuchMessageException`, что приводит к HTTP 500 (fail-fast для проблем с ресурсами локализации).
	*   **5.4. `BearerTokenProblemDetailsAuthenticationEntryPoint` (реализация `AuthenticationEntryPoint`):**
		*   Вызывается при неаутентифицированном доступе к защищенному ресурсу или при ошибке в `JwtAuthenticationFilter`.
		*   Устанавливает HTTP-заголовок `WWW-Authenticate: Bearer realm="task-tracker"`.
		*   Делегирует возникшее `AuthenticationException` (которое может быть `BadJwtException`) в `org.springframework.web.servlet.HandlerExceptionResolver` для обработки в `GlobalExceptionHandler`. **Не формирует тело ответа самостоятельно.**
	*   **5.5. `ProblemDetailsAccessDeniedHandler` (реализация `AccessDeniedHandler`):**
		*   Вызывается при отказе в доступе аутентифицированному пользователю.
		*   Делегирует `AccessDeniedException` в `HandlerExceptionResolver`. **Не формирует тело ответа самостоятельно.**
	*   **5.6. `BadJwtException` (кастомное исключение):**
		*   Наследуется от `org.springframework.security.core.AuthenticationException`.
		*   Хранит `JwtErrorType` и оригинальную причину (`Throwable`).

6.  **Компоненты Авторизации (согласно ADR-0019):**
	*   **`PermissionService`:** Spring Bean для инкапсуляции сложных/переиспользуемых правил авторизации, вызываемый из SpEL в `@PreAuthorize`.
	*   **Репозитории (например, `TaskRepository`):** Содержат методы с Security Expressions в `@Query` (`?#{ principal.id }`) для реализации авторизации по владению при чтении данных. Интерфейсы таких репозиториев не наследуют стандартные `JpaRepository` без необходимости, а определяют "безопасные по умолчанию" методы.

*   **Взаимодействие Компонентов (Общее описание):**
*   При запросе на публичные эндпоинты регистрации/логина, `UserController`/`AuthController` вызывают `AuthService`. `AuthService` использует `AuthenticationManager` для логина или напрямую `UserRepository`/`PasswordEncoder` для регистрации, а затем `JwtIssuer` для создания токена. Ошибки обрабатываются `GlobalExceptionHandler`.
*   При запросе к защищенному эндпоинту, `JwtAuthenticationFilter` перехватывает запрос. Он использует `JwtValidator` для проверки токена и извлечения `Claims`. Если токен валиден, `JwtAuthenticationConverter` создает объект `Authentication`, который устанавливается в `SecurityContextHolder`. Если токен невалиден или при конвертации `Claims` возникает ошибка, `JwtAuthenticationFilter` вызывает `BearerTokenProblemDetailsAuthenticationEntryPoint` с `BadJwtException`.
*   Дальнейшие проверки авторизации выполняются Spring Method Security (используя `Authentication` из `SecurityContextHolder` и, возможно, `PermissionService`) и/или через Security Expressions в запросах репозиториев.
*   Ошибки `AuthenticationException` (от `AuthenticationEntryPoint`) и `AccessDeniedException` (от механизмов авторизации) делегируются в `HandlerExceptionResolver` и обрабатываются `GlobalExceptionHandler` для формирования ответа `ProblemDetail`.
		
# ADR-0021: Стандарт Документирования Кода с Использованием Javadoc

*   **Принятое Решение:**
    1.  **Обязательность Javadoc:**
        *   Все публичные и защищенные (`protected`) классы, интерфейсы, перечисления (`enum`), записи (`record`) и аннотации **ДОЛЖНЫ** иметь Javadoc-комментарии.
        *   Все публичные и защищенные (`protected`) методы и конструкторы **ДОЛЖНЫ** иметь Javadoc-комментарии.
        *   Для приватных методов Javadoc **РЕКОМЕНДУЕТСЯ**, если их логика нетривиальна или требует пояснений.
        *   Для публичных полей (констант) Javadoc **ОБЯЗАТЕЛЕН**.

    2.  **Содержание Javadoc для Типов (Классы, Интерфейсы, Enum, Records, Annotations):**
        *   **Общее описание:** Четкое описание назначения и роли типа в системе.
        *   **Основные ответственности:** Краткое перечисление ключевых функций или данных, за которые отвечает тип.
        *   **Ключевые особенности:** Упоминание важных аспектов реализации, паттернов, ограничений или неявных предположений, если они есть.
        *   **Взаимодействие:** По возможности, кратко указать основные зависимости или компоненты, с которыми данный тип взаимодействует, используя тег `{@link ...}` или `@see` для ссылок.
        *   **Пример использования:** Если тип сложен или его использование неочевидно, **РЕКОМЕНДУЕТСЯ** предоставить краткий пример использования внутри тега `{@code ...}` или ссылку `@see` на демонстрационный тест.
        *   **Потокобезопасность:** Для классов, предназначенных для многопоточного использования, **ДОЛЖНО** быть явно указано, являются ли они потокобезопасными, и если да, то при каких условиях.

    3.  **Содержание Javadoc для Методов и Конструкторов:**
        *   **Описание:** Краткое, но исчерпывающее описание того, что делает метод или конструктор. Для методов, переопределяющих методы из суперкласса/интерфейса, можно использовать `{@inheritDoc}`, если стандартная документация достаточна, но при наличии специфики или уточнений **СЛЕДУЕТ** предоставить собственное описание.
        *   **Параметры (`@param`):**
            *   Описание каждого параметра с использованием тега `@param имя_параметра описание`.
            *   Указывать, если параметр может быть `null` (и как это обрабатывается) или если для него есть специфические требования (например, формат, диапазон значений, непустая коллекция). Использовать аннотации `@NonNull`, `@Nullable` (например, от Lombok или JetBrains) для явного указания контракта по `null`.
        *   **Возвращаемое значение (`@return`):**
            *   Описание возвращаемого значения (если метод не `void`) с использованием тега `@return описание`.
            *   Указывать, может ли возвращаемое значение быть `null`, или если это коллекция, может ли она быть пустой.
        *   **Исключения (`@throws`):**
            *   Описание каждого **проверяемого (`checked`) исключения**, которое метод может выбросить, с использованием тега `@throws ТипИсключения описание_условия_выбрасывания`.
            *   Описание **непроверяемых (`unchecked`) бизнес-специфичных `RuntimeException`**, которые являются частью контракта метода и которые клиент API или вызывающий код может ожидать и должен обрабатывать (например, `IllegalArgumentException` при невалидных аргументах, `UserAlreadyExistsException`, `BadJwtException`).
            *   Для общих `RuntimeException` (например, `NullPointerException` из-за внутренней ошибки, не связанной с контрактом) документирование через `@throws` обычно не требуется, если они не являются ожидаемым поведением API.

    4.  **Стиль и Ясность:**
        *   Javadoc **ДОЛЖЕН** быть написан на **русском языке**.
        *   Комментарии должны быть грамотными, четкими, лаконичными и однозначно трактуемыми.
        *   Избегать избыточных или очевидных комментариев (например, `@return возвращает значение`).
        *   Использовать HTML-теги (`<p>`, `<ul>`, `<li>`, `{@code ...}`, `{@link ...}`) для форматирования и улучшения читаемости, где это уместно. Тег `{@code ...}` предпочтителен для имен классов, методов, полей, параметров и литеральных значений.

    5.  **Актуальность:**
        *   Javadoc-комментарии **ДОЛЖНЫ** поддерживаться в актуальном состоянии и обновляться синхронно с изменениями в коде. Неактуальная документация хуже, чем ее отсутствие.

    6.  **Интеграция с Lombok:**
        *   При использовании Lombok для генерации методов (например, `@Getter`, `@Setter`, `@RequiredArgsConstructor`), Javadoc **РЕКОМЕНДУЕТСЯ** писать для соответствующих полей или класса. IDE и инструменты генерации документации часто могут подхватывать такой Javadoc для сгенерированных методов.
        *   Если для сгенерированного Lombok'ом метода требуется специфический Javadoc, отличный от документации поля, или если Lombok не переносит Javadoc с поля на метод должным образом, то Javadoc **ДОЛЖЕН** быть написан для самого метода (Lombok позволяет это для некоторых аннотаций или через delombok).

	
# ADR-0022: Управление Конфигурационными Свойствами и Безопасность Секретов

1.  **Type-Safe Конфигурация:**
        *   Использовать классы, аннотированные `@ConfigurationProperties`, для доступа к конфигурационным параметрам приложения. Это обеспечивает type-safety, интеграцию с IDE и возможность группировки связанных свойств.
        *   Префикс для свойств, относящихся к приложению `task-tracker`, должен быть осмысленным (например, `app.security.jwt.*`, `app.kafka.*`).

    2.  **Валидация Свойств:**
        *   Классы `@ConfigurationProperties` **ДОЛЖНЫ** быть аннотированы `@Validated` (из `org.springframework.validation.annotation.Validated`).
        *   Поля в этих классах **ДОЛЖНЫ** быть провалидированы при старте приложения с использованием аннотаций Jakarta Bean Validation (например, `@NotBlank`, `@Size`, `@Positive`, `@NotNull`, `@Pattern`).
        *   Сообщения для аннотаций валидации **ДОЛЖНЫ** извлекаться из Resource Bundle через ключи (согласно ADR-0024).

    3.  **Управление Секретными Значениями (JWT Secret Key, Пароли БД и т.д.):**
        *   **Запрет Хранения в VCS:** Секретные значения **НИКОГДА** не должны храниться в системе контроля версий в открытом виде в файлах конфигурации (`application.yml`, `application.properties` и их профильных вариантах, кроме случаев, описанных ниже для `dev`/`ci`).
        *   **Формат JWT Secret Key:** Секретный ключ для JWT (и другие бинарные секреты, если применимо) **ДОЛЖЕН** предоставляться и ожидаться приложением в **Base64-кодированном виде**, когда он поступает из внешних источников (переменные окружения, файлы конфигурации для `prod`). Приложение отвечает за его декодирование перед использованием.
        *   **Предоставление Секретов для Production (`prod` профиль):**
            *   Секреты **ОБЯЗАТЕЛЬНЫ** и **ДОЛЖНЫ** предоставляться приложению через безопасные внешние механизмы:
                *   Переменные окружения (предпочтительный и наиболее универсальный способ).
                *   Внешние системы управления секретами (например, HashiCorp Vault, AWS Secrets Manager, Kubernetes Secrets), если инфраструктура это поддерживает и настроена интеграция.
        *   **Управление Секретами для Локальной Разработки и CI (`dev`, `ci` профили):**
            *   **Локальная разработка (`dev`):** Допускается использование временных/тестовых секретов (в Base64-формате, если это стандарт для данного секрета), определенных в `application-dev.yml`. Этот файл **ДОЛЖЕН** быть добавлен в `.gitignore`.
            *   **CI (`ci`):** Секреты для CI **ДОЛЖНЫ** предоставляться через переменные окружения, управляемые CI-сервером (например, Jenkins Credentials). Не допускается использование дефолтных/вкомпилированных секретов для CI-сборки, которая может производить артефакты для развертывания.
            *   **Опциональные/Дефолтные Секреты (НЕ для `prod`):** Приложение **не должно** содержать встроенных "магических" или дефолтных значений для критичных секретов (таких как JWT `secret-key`) в коде. Даже для профилей `dev` и `ci` ожидается, что такие секреты будут явно сконфигурированы (например, через `application-dev.yml` или переменные окружения CI), хотя сами значения этих секретов могут быть тестовыми или менее стойкими, чем для `prod`. Отсутствие явно сконфигурированного критичного секрета приведет к ошибке при старте приложения (например, из-за срабатывания `@NotBlank` на соответствующем поле в `@ConfigurationProperties`).

    4.  **Принцип "Fail-Fast" для Критических Конфигураций:**
        *   Для критически важных для безопасности или функционирования конфигураций (например, JWT `secret-key` в `prod` профиле, URL для подключения к основной БД в `prod`) приложение **ДОЛЖНО** реализовывать логику "fail-fast":
            *   Приложение **НЕ ДОЛЖНО СТАРТОВАТЬ** (должно выбросить исключение и завершить работу) при отсутствии или невалидности таких критических конфигурационных параметров, особенно в `prod` профиле.
            *   Валидация `@ConfigurationProperties` (см. п.2) является основным механизмом для этого.
            *   Дополнительные проверки, специфичные для конкретных конфигурационных параметров (например, проверка минимальной длины декодированного JWT секрета после его загрузки из JwtProperties), ДОЛЖНЫ быть реализованы в компоненте, ответственном за инициализацию или первое использование этого параметра (например, в конструкторе или @PostConstruct методе сервиса, который напрямую работает с этим параметром, как JwtKeyService для секретного ключа JWT). Такие проверки ДОЛЖНЫ приводить к ошибке при старте приложения (например, выбрасыванием IllegalStateException), если проверка не пройдена, тем самым реализуя принцип "fail-fast".

# ADR-0023: Стандарт Применения Логгирования

1.  **Уровни Логгирования и Смысловое Назначение:**
    *   **`ERROR`:**
        *   **Назначение:** Критические ошибки, которые привели к сбою операции, невозможности обработать запрос, потенциальной потере данных или нарушению консистентности системы. Требуют немедленного внимания и расследования.
        *   **Примеры:** Непредвиденные исключения в ключевой бизнес-логике, ошибки при взаимодействии с критическими внешними системами (БД, Kafka – если это приводит к сбою), серьезные проблемы конфигурации при старте (например, невалидный JWT-ключ, как в `JwtTokenProvider`).
        *   **Действие:** Всегда логгировать полное исключение (стектрейс).
    *   **`WARN`:**
        *   **Назначение:** Потенциальные проблемы, ожидаемые, но нежелательные события, или ситуации, которые не прервали операцию, но могут привести к проблемам в будущем или указывают на некорректное использование API/системы.
        *   **Примеры:** Неудачная попытка аутентификации (неверный пароль), попытка регистрации с уже существующим email, использование устаревшего API (если применимо), некритичные ошибки конфигурации (например, JWT-ключ короче рекомендуемого, но система продолжает работу), превышение каких-либо ожидаемых лимитов (если это не ошибка). Неуспешная валидация входных данных от клиента (если это не результат злонамеренных действий, а просто ошибка пользователя).
        *   **Действие:** Логгировать достаточный контекст для понимания причины. Исключение (если есть) может быть залоггировано, если оно несет полезную информацию.
    *   **`INFO`:**
        *   **Назначение:** Значимые бизнес-события и этапы жизненного цикла приложения/компонентов. Позволяют отслеживать нормальное течение процессов.
        *   **Примеры:** Успешная аутентификация пользователя, успешная регистрация пользователя, создание/изменение/удаление ключевых бизнес-сущностей (например, задачи), старт и успешная инициализация ключевых сервисов, выполнение запланированных задач (Scheduler).
        *   **Действие:** Логгировать идентификаторы затронутых сущностей и ключевые параметры операции.
    *   **`DEBUG`:**
        *   **Назначение:** Детальная информация о ходе выполнения внутренних операций, полезная для разработчиков при отладке и трассировке конкретного запроса или процесса.
        *   **Примеры:** Вход/выход из важных методов, значения ключевых переменных внутри методов, детали шагов при обработке запроса, информация о процессе генерации/валидации JWT (без самого токена), детали взаимодействия с внешними системами (например, параметры запроса к БД, если это не логируется Hibernate).
        *   **Действие:** Не должен содержать избыточной информации, не "зашумлять" логи без необходимости.
    *   **`TRACE`:**
        *   **Назначение:** Очень низкоуровневая, максимально детализированная информация. Используется редко, для глубокой отладки сложных или проблемных участков кода.
        *   **Примеры:** Дамп состояния объектов, пошаговое выполнение циклов или сложных алгоритмов.
        *   **Действие:** Использовать с осторожностью, так как может генерировать очень большой объем логов.

2.  **Содержание Лог-сообщений:**
    *   **Информативность:** Сообщения должны быть понятными и содержать достаточно контекста, чтобы можно было однозначно идентифицировать событие и, при необходимости, воспроизвести ситуацию или найти связанные данные.
    *   **Идентификаторы:** Включать релевантные идентификаторы (например, `userId`, `taskId`, `email`, `jti` токена) для упрощения поиска и корреляции логов. Уровни DEBUG/TRACE могут содержать больше таких идентификаторов, чем INFO/WARN.
    *   **Безопасность (Недопустимое Содержимое):**
        *   **НИКОГДА** не логгировать пароли в открытом виде или их хеши (кроме как на уровне TRACE в специальном режиме отладки, если это абсолютно необходимо и контролируемо).
        *   **НИКОГДА** не логгировать полные JWT Access Tokens. Допускается логгирование JTI, `sub`, `iss`, `exp` или усеченной/замаскированной части токена на уровне DEBUG для диагностики.
        *   **НИКОГДА** не логгировать полные секретные ключи или другую высокочувствительную конфигурационную информацию.
        *   **Ограничивать логгирование Персональных Идентификационных Данных (PII):** Email и `userId` могут логгироваться на уровне DEBUG или INFO для отслеживания действий пользователя, но следует избегать логгирования другой PII без крайней необходимости и соответствующего уровня защиты логов.
    *   **Параметризация:** Использовать параметризованные лог-сообщения (`log.info("User {} processed task {}", userId, taskId);`) вместо конкатенации строк для лучшей производительности и читаемости.

3.  **Контекстная Информация и Корреляция:**
    *   **MDC (Mapped Diagnostic Context):** После успешной аутентификации пользователя, его `userId` (и, возможно, `email` или другой стабильный идентификатор) **ДОЛЖЕН** быть помещен в MDC. Это позволит автоматически добавлять `userId` ко всем лог-сообщениям, сгенерированным в рамках обработки запроса этого пользователя. Необходимо обеспечить очистку MDC после завершения обработки запроса.
        *   Пример реализации: в `JwtAuthenticationFilter` после успешной установки `Authentication`.
    *   **`trace_id` / `span_id`:** Эти идентификаторы автоматически добавляются в логи благодаря интеграции с OpenTelemetry (ADR-0009) и служат для корреляции логов с распределенными трассами. На уровне кода приложения для этого специальных действий не требуется, кроме как не мешать работе OTel агента/инструментации.

4.  **Логгирование Исключений:**
    *   При перехвате исключения, если оно не обрабатывается полностью и не "проглатывается" намеренно, оно **ДОЛЖНО** быть залоггировано, как правило, на уровне `ERROR` или `WARN` (в зависимости от серьезности).
    *   Логгирование исключения **ДОЛЖНО** включать полный стектрейс для облегчения диагностики.
        *   Пример: `log.error("Failed to process user registration for email: {}", request.getEmail(), e);`

5.  **Аудит Безопасности:**
    *   Ключевые события, связанные с безопасностью, **ДОЛЖНЫ** логгироваться как минимум на уровне `INFO` или `WARN`:
        *   Успешный логин (`INFO`).
        *   Неудачная попытка логина (`WARN`).
        *   Создание пользователя (`INFO`).
        *   Значимые изменения в профиле пользователя или его правах (если/когда появятся) (`INFO`).
        *   Срабатывание правил авторизации, приводящее к отказу в доступе (`WARN` или `INFO`, в зависимости от ожидаемости).
        *   Ошибки валидации JWT (`DEBUG` для `ExpiredJwtException`, `WARN` для других `JwtException`).
        * 
# ADR-0024: Централизация и Управление Текстовыми Ресурсами Приложения через Resource Bundle

1.  **Центральный Механизм Управления Текстами:**
        *   Все текстовые ресурсы приложения (сообщения об ошибках валидации, тексты для ответов API, тексты email-уведомлений и т.д.), которые не являются частью исполняемого кода, конфигурационных параметров (ADR-0022), или отладочных логов (ADR-0023), **ДОЛЖНЫ** управляться через механизм Java Resource Bundle.
        *   Доступ к этим ресурсам в коде приложения **ДОЛЖЕН** осуществляться через стандартный Spring Framework интерфейс `org.springframework.context.MessageSource`.

    2.  **Структура Файлов Resource Bundle и Определение Базовых Имен (`basename`):**
        *   Файлы сообщений (`.properties`) **ДОЛЖНЫ** размещаться в директории `src/main/resources/i18n/`.
        *   Внутри `i18n/` **РЕКОМЕНДУЕТСЯ** использовать доменную структуру поддиректорий (согласно ADR-0007), чтобы логически группировать сообщения. Например: `i18n/security/`, `i18n/user/`, `i18n/common/`.
        *   Имена файлов могут отражать их назначение (например, `validation_messages.properties`, `api_errors.properties`, `notifications.properties`) или более специфичный домен (например, `jwt_validation.properties`).
        *   Свойство `spring.messages.basename` в `application.yml` **ДОЛЖНО** содержать список базовых имен (путей от корня classpath без суффикса локали и `.properties`), разделенных запятыми.
            *   **Порядок в `basename` важен:** Более специфичные файлы (например, `i18n/security/jwt_validation`) **ДОЛЖНЫ** идти раньше более общих файлов того же домена (например, `i18n/security/validation`) или общих файлов приложения (например, `i18n/messages`), если предполагается возможность переопределения или детализации сообщений.
            *   Пример:
                ```yaml
                spring:
                  messages:
                    basename:
                      i18n/security/jwt_validation,  # Специфичные для JWT валидации
                      i18n/security/auth_errors,     # Ошибки аутентификации
                      i18n/security/messages,        # Общие сообщения безопасности
                      i18n/user/messages,
                      i18n/common_errors,
                      i18n/messages                  # Самые общие или фолбэки
                ```

    3.  **Конвенция Именования Ключей Сообщений:**
        *   Ключ, используемый в Java-коде (например, `{ключ}` в аннотациях валидации или `"ключ"` при вызове `messageSource.getMessage(...)`), **ДОЛЖЕН** быть **полным квалифицированным ключом**, отражающим его логическое местоположение или назначение.
        *   **Рекомендуемый Формат Ключа:** `<домен1>.<домен2_опционально>.<компонент_или_сущность>.<поле_или_аспект>.<описание_ошибки_или_сообщения>`
            *   Пример для валидации `@ConfigurationProperties` (префикс `app.security.jwt`): `{security.jwt.secretKey.notBlank}`. (Здесь `app.` опускается из ключа сообщения для краткости, но сохраняется в префиксе свойств).
            *   Пример для DTO пользователя: `{user.dto.registerRequest.email.invalidFormat}`.
            *   Пример для API ошибки: `{api.error.authentication.invalidToken.title}`.
        *   Эта конвенция обеспечивает глобальную уникальность ключей и упрощает навигацию к соответствующему сообщению. Ключ, как он указан в коде/аннотации, должен *точно так же* быть определен в одном из файлов, перечисленных в `spring.messages.basename`.

    4.  **Параметризация Сообщений:**
        *   Использовать стандартный механизм `java.text.MessageFormat` (`{0}`, `{1}`) для динамических значений и встроенные параметры аннотаций Bean Validation (`{min}`, `{max}`).

    5.  **Конфигурация `MessageSource` в Spring Boot (`application.yml`):**
        *   Помимо `spring.messages.basename`, **ДОЛЖНЫ** быть установлены следующие свойства для обеспечения надежности и предсказуемости:
            *   `spring.messages.encoding: UTF-8`.
            *   `spring.messages.fallback-to-system-locale: false`.
            *   `spring.messages.always-use-message-format: false` (или `true`, если необходимо обрабатывать одинарные кавычки во всех сообщениях).
            *   **Свойство `spring.messages.use-code-as-default-message` НЕ ДОЛЖНО быть установлено в `true`** для production-сборок или при выполнении тестов на CI. Если ключ сообщения не найден, `MessageSource` **ДОЛЖЕН** выбрасывать `NoSuchMessageException` (если не указано дефолтное сообщение в вызове `getMessage`). Это позволяет обнаруживать отсутствующие ключи на этапе тестирования или при старте.
                *   Для локальной разработки (профиль `dev`) *допускается* временная установка `use-code-as-default-message: true` для удобства, но это не должно попадать в основные конфигурации.

    6.  **Использование в Коде:**
        *   Внедрять Spring `MessageSource`.
        *   Получать сообщения через `messageSource.getMessage(...)`. При использовании версий без `defaultMessage` быть готовым обрабатывать `NoSuchMessageException`.
        *   Для аннотаций валидации: Spring автоматически использует `MessageSource`.
	
	7.  **Особенности Интерполяции Сообщений для Стандартных Аннотаций Jakarta Bean Validation:**
    *   При использовании ключей из Resource Bundle в атрибуте `message` стандартных аннотаций Jakarta Bean Validation (например, `@Size`, `@Pattern`, `@Min`, `@Max` и т.д.), и их последующей интерполяции через связку Spring `MessageSource` и нижележащего Bean Validation Provider (по умолчанию Hibernate Validator), необходимо учитывать следующий механизм:
        1.  Bean Validation Provider (Hibernate Validator) при обнаружении аннотации с `message = "{my.custom.key}"` сначала обращается к `jakarta.validation.MessageInterpolator`.
        2.  В Spring Boot, `MessageInterpolator` по умолчанию сконфигурирован для использования Spring `MessageSource`.
        3.  `MessageSource` извлекает строку-шаблон по ключу `my.custom.key` из соответствующего `.properties` файла.
        4.  **Эта строка-шаблон затем возвращается обратно Bean Validation Provider (Hibernate Validator) для финальной интерполяции.**
        5.  Hibernate Validator уже в этой строке-шаблоне ищет свои нативные плейсхолдеры, такие как `{min}`, `{max}`, `${validatedValue}`, атрибуты аннотации (например, `{regexp}` для `@Pattern`) и подставляет в них актуальные значения из атрибутов самой аннотации валидации.
    *   **Следствие для `messages.properties`:** Чтобы использовать атрибуты аннотаций (например, `min` и `max` из `@Size`) в сообщениях, хранящихся в Resource Bundle, строка для соответствующего ключа в `.properties` файле **ДОЛЖНА** содержать плейсхолдеры, понятные Bean Validation Provider (Hibernate Validator), а не плейсхолдеры `java.text.MessageFormat` (типа `{0}`, `{1}`).
        *   **Пример для `@Size(min=8, max=255, message="{user.password.size}")`:**
            В `messages.properties`:
            `user.password.size=Password must be between {min} and {max} characters long.`
            (Hibernate Validator подставит `8` вместо `{min}` и `255` вместо `{max}`).
    *   **Отличие от прямого использования `MessageSource`:** Этот механизм отличается от прямого вызова `messageSource.getMessage("key", new Object[]{arg0, arg1}, locale)`, где `MessageSource` ожидает плейсхолдеры `{0}`, `{1}` в строке из `.properties` файла. Для сообщений, не связанных со стандартными аннотациями Bean Validation, по-прежнему используется стандартная параметризация `MessageFormat`.
    *   **Цель:** Такой подход позволяет централизовать все шаблоны сообщений в Resource Bundle и одновременно использовать возможности Bean Validation Provider по интерполяции атрибутов аннотаций.

# ADR-0025: Стандарты Тестирования Компонентов

1.  **Разделение Ответственности между Юнит- и Интеграционными Тестами:**
	*   **1.1. Юнит-тесты (Unit Tests):**
		*   **Цель:** Проверка корректности работы **одного изолированного компонента** (класса или небольшого набора тесно связанных классов) без взаимодействия с его реальными внешними зависимостями (БД, другие сервисы, файловая система, сетевые вызовы и т.д.).
		*   **Изоляция:** Внешние зависимости **ДОЛЖНЫ** быть заменены тестовыми двойниками (stubs, mocks, spies – используя Mockito).
		*   **Скорость:** Должны быть **очень быстрыми** для частого запуска (локально и на CI).
		*   **Область Применения:** Сервисный слой (бизнес-логика), утилитарные классы, компоненты со сложной внутренней логикой (например, компоненты JWT, кастомные валидаторы), сложные методы в POJO/DTO. Простые POJO/DTO (только геттеры/сеттеры, `equals`/`hashCode`/`toString`, сгенерированные Lombok или IDE) обычно не требуют отдельных юнит-тестов.
		*   **Что НЕ тестируют:** Интеграцию с фреймворком (например, корректность DI Spring), взаимодействие с реальной БД, HTTP-запросы/ответы.
	*   **1.2. Интеграционные тесты (Integration Tests - IT):**
		*   **Цель:** Проверка взаимодействия **между несколькими компонентами** приложения или интеграции приложения с **реальными или тестовыми экземплярами внешних зависимостей** (например, база данных, брокер сообщений).
		*   **Изоляция и Мокирование:**
			*   Тестируется *интеграция*. Поэтому для зависимостей, являющихся объектом тестирования интеграции (например, БД при тестировании репозитория или полного API-потока с БД), **ДОЛЖНЫ** использоваться их реальные или тестовые экземпляры (например, БД через Testcontainers, согласно ADR-0008).
			*   **Использование моков в интеграционных тестах СЛЕДУЕТ МИНИМИЗИРОВАТЬ.** Моки могут применяться только для имитации *внешних систем, не являющихся частью текущей тестируемой интеграции и труднодоступных в тестовом окружении* (например, сторонний платежный шлюз, внешний почтовый сервис, если его имитация через Testcontainers нецелесообразна или невозможна).
			*   **ЗАПРЕЩАЕТСЯ** мокировать компоненты, которые являются частью проверяемого интеграционного сценария (например, мокирование `AuthService` в интеграционном тесте контроллера, который должен проверить полный флоу аутентификации).
		*   **Скорость:** Медленнее юнит-тестов. Запускаются на CI, локально – по необходимости.
		*   **Область Применения:**
			*   **Слой персистентности:** Взаимодействие JPA-репозиториев с БД (ADR-0016, `@DataJpaTest` + Testcontainers).
			*   **API/Контроллеры:** Полный HTTP-флоу от запроса до ответа, включая валидацию DTO, работу контроллера, вызов сервиса, взаимодействие с БД, сериализацию/десериализацию, формирование корректных HTTP-статусов и ответов (включая Problem Details). Используется `@SpringBootTest` (предпочтительно с `WebEnvironment.RANDOM_PORT` для проверки полного стека) + `TestRestTemplate`, или `WebEnvironment.MOCK` + `MockMvc` для более легковесных тестов веб-слоя.
			*   **Взаимодействие с брокерами сообщений (когда появится):** Отправка и получение сообщений с использованием Testcontainers для Kafka.
			*   Проверка корректности работы цепочки фильтров Spring Security, аутентификации и авторизации на уровне HTTP-запросов (через `@SpringBootTest` + `TestRestTemplate`/`MockMvc`).
		*   **Именование:** Использовать суффикс `IT.java` (согласно ADR-0016).

2.  **Требования к Качеству и Полноте Тестовых Сценариев:**
	*   **2.1. Покрытие Сценариев:**
		*   Тесты **ДОЛЖНЫ** покрывать как позитивные сценарии ("happy path"), так и негативные сценарии (обработка ошибок, выбрасывание ожидаемых исключений, невалидные входные данные).
		*   Необходимо тестировать граничные условия (например, пустые коллекции, нулевые значения там, где они допустимы или не допустимы, максимальные/минимальные значения).
	*   **2.2. Структура Тестового Метода (Arrange-Act-Assert - AAA):**
		*   Код внутри каждого тестового метода **ДОЛЖЕН** следовать паттерну AAA для ясности и читаемости:
			*   **Arrange (Подготовка):** Настройка начальных условий, создание объектов, мокирование (в юнит-тестах) или подготовка тестовых данных/состояния (в интеграционных).
			*   **Act (Действие):** Вызов тестируемого метода или выполнение тестируемого сценария.
			*   **Assert (Проверка):** Проверка результатов выполнения, состояния объектов, выброшенных исключений, вызовов моков (в юнит-тестах), состояния БД (в интеграционных).
	*   **2.3. Именование Тестовых Методов:**
		*   Имена тестовых методов **ДОЛЖНЫ** быть описательными и четко указывать на тестируемый сценарий и ожидаемое поведение.
		*   Рекомендуемый формат: `methodName_whenCondition_shouldExpectedBehavior()` или `shouldExpectedBehavior_whenCondition_forMethodName()`.
		*   Пример: `generateToken_whenPrincipalIsAppUserDetails_shouldReturnValidJwt()`
		*   Пример: `shouldThrowUsernameNotFoundException_whenUserEmailDoesNotExist_forLoadUserByUsername()`
		*   Для `@ParameterizedTest` рекомендуется использовать атрибут `name` аннотации для включения параметров теста в отображаемое имя (например, `name = "{displayName} - [{index}] {arguments}"`).
	*   **2.4. Изоляция Тестов:**
		*   Каждый тестовый метод **ДОЛЖЕН** быть независим от других. Результат выполнения одного теста не должен влиять на результат другого.
		*   Использовать аннотации `@BeforeEach` для настройки общего состояния перед каждым тестом и `@AfterEach` для очистки (если необходимо).
		*   Для ресурсов, инициализация которых занимает значительное время (например, Docker-контейнеры в Testcontainers), **ДОПУСКАЕТСЯ** использовать `@BeforeAll` и `@AfterAll` для управления их жизненным циклом на уровне тестового класса, при условии обеспечения очистки состояния между тестами.
	*   **2.5. Один Логический Assert на Тест (Рекомендация):**
		*   По возможности, каждый тестовый метод должен проверять одно конкретное логическое утверждение или аспект поведения.
		*   Допустимо иметь несколько физических вызовов `assert...()` в одном тесте, если они все относятся к проверке одного и того же логического результата или состояния (например, проверка нескольких полей одного DTO или корректности состояния объекта).
		*   Избегать перегруженных тестов, проверяющих множество несвязанных вещей.
	*   **2.6. Отсутствие Логики в Тестах:**
		*   Тестовые методы **НЕ ДОЛЖНЫ** содержать сложной бизнес-логики, условных операторов или циклов, влияющих на ход самого теста. Если требуется сложная подготовка данных или проверка, выносить ее во вспомогательные приватные методы тестового класса или статические фабричные методы.
	*   **2.7. Читаемость и Поддерживаемость Тестов:**
		*   Тестовый код является кодом первого класса и **ДОЛЖЕН** быть таким же чистым, читаемым и поддерживаемым, как и основной код приложения. Использовать осмысленные имена переменных, избегать "магических чисел" (использовать именованные константы).
		*   При проверке исключений использовать `org.junit.jupiter.api.Assertions.assertThrows` или аналогичные конструкции из AssertJ, которые явно указывают ожидаемый тип исключения.
		*   В ассертах **РЕКОМЕНДУЕТСЯ** использовать описательные сообщения (`as("...")` в AssertJ), чтобы при падении теста было сразу понятно, что пошло не так.
	*   **2.8. Тестирование Исключений:**
		*   Для проверки корректного выбрасывания ожидаемых исключений **СЛЕДУЕТ** использовать `org.junit.jupiter.api.Assertions.assertThrows` или аналогичные методы из библиотек утверждений (например, `assertThatExceptionOfType` из AssertJ).
		*   **ДОЛЖЕН** проверяться не только сам факт выбрасывания исключения, но и, по возможности, его тип, сообщение (если оно является частью контракта) и причина (`cause`), если это релевантно.

# ADR-0026: Требования к Применению Распределенной Трассировки

1.  **Приоритет Авто-Инструментации:**
    *   **Основа Трассировки:** Авто-инструментация, предоставляемая OpenTelemetry Java Agent или интегрированными средствами Spring Boot OTel Starter, является **основным и предпочтительным** способом получения трассировочных данных.
    *   **Ожидаемое Покрытие Авто-Инструментацией:** Предполагается, что авто-инструментация покроет большинство стандартных взаимодействий и точек интеграции в приложении, включая, но не ограничиваясь:
        *   Обработку входящих HTTP-запросов (например, в Spring MVC контроллерах).
        *   Выполнение исходящих HTTP-клиентских вызовов (например, через `RestTemplate`, `WebClient`).
        *   Взаимодействия с базой данных через JDBC (включая вызовы через Spring Data JPA).
        *   Обработку сообщений из/в системы очередей (например, Kafka, когда она будет интегрирована).
        *   Выполнение запланированных задач, аннотированных Spring `@Scheduled`.
        *   Другие распространенные фреймворки и библиотеки, для которых существуют официальные или общепринятые OTel-инструментации.
    *   **Проверка Необходимости Кастомной Инструментации:** Перед добавлением любой кастомной инструментации (создания спанов или атрибутов вручную) разработчик **ДОЛЖЕН** сначала проанализировать существующие трассы (например, в Tempo или Grafana), чтобы убедиться, что интересующий участок кода или специфическая операция действительно не покрывается авто-инструментацией с достаточной степенью детализации.

2.  **Применение Кастомной Инструментации (Спаны и Атрибуты) – для Обоснованных Случаев:**
    *   Кастомная инструментация (создание новых спанов или добавление атрибутов к существующим спанам) **ДОЛЖНА** применяться осмысленно и **только тогда, когда авто-инструментация не обеспечивает необходимой детализации или видимости** для ключевых бизнес-операций, сложных внутренних процессов, или для улучшения диагностики и понимания потока выполнения.
    *   **2.1. Критерии для Создания Кастомных Спанов:**
        Кастомный спан оправдан, если он обрамляет:
        *   **Значимые Бизнес-Логические Блоки:** Четко выделенные, последовательные и важные с точки зрения бизнеса шаги внутри одного автоматически созданного спана (например, внутри спана метода контроллера), которые сами по себе могут быть длительными, ресурсоемкими или критичными для анализа производительности или понимания бизнес-потока. *Пример: в методе обработки заказа шаги "Проверка наличия товара", "Обработка платежа", "Обновление статуса заказа" могут быть выделены в кастомные спаны.*
        *   **Операции, Невидимые для Авто-Инструментации:** Длительные или сложные вычисления, происходящие исключительно в памяти приложения; работа с локальным кэшем (если используемая библиотека кэширования не инструментируется автоматически); выполнение сложных алгоритмов, которые не включают инструментируемых внешних вызовов (JDBC, HTTP).
        *   **Улучшение Читаемости и Структурирования Трасс:** Для очень больших или логически сложных методов, выполнение которых не разбивается на внешние вызовы, создание внутренних под-спанов может существенно улучшить понимание трассы и локализацию узких мест.
        *   **Явное Определение Типа Спана (`SpanKind`):** В редких случаях, когда авто-инструментация не может корректно определить или установить `SpanKind` (например, для взаимодействия по нестандартному протоколу или с системой, для которой нет стандартной OTel-инструментации).
    *   **2.2. Критерии для Добавления Кастомных Атрибутов к Спанам (Автоматическим или Кастомным):**
        Кастомные атрибуты добавляются для обогащения спанов контекстом, полезным для анализа, фильтрации и корреляции трасс:
        *   **Ключевые Бизнес-Идентификаторы:** Идентификаторы, связывающие спан с конкретными бизнес-сущностями (например, `user.id`, `task.id`, `order.id`, `customer.email`). **Внимание:** При добавлении атрибутов, содержащих Персональные Идентификационные Данные (PII), необходимо строго соблюдать политики безопасности и конфиденциальности данных; PII должны добавляться только при крайней необходимости и с пониманием рисков.
        *   **Важные Параметры Операции:** Значения, которые существенно влияют на логику выполнения или результат операции (например, `request.type`, `item.count`, `payment.method`, `query.parameters.size`).
        *   **Результаты Операции (нечувствительные):** Информация о результате выполнения операции, если она не является ошибкой, но важна для контекста (например, `validation.result = "success"`, `cache.hit = "true"`, `items.processed.count = 10`).
        *   **Дополнительная Информация об Ошибках:** Хотя статус ошибки (`StatusCode.ERROR`) и исключение часто устанавливаются автоматически, кастомные атрибуты могут предоставить дополнительный контекст об ошибке, который не является частью стандартного сообщения исключения или стектрейса.
    *   **2.3. Предпочтительные Инструменты для Кастомной Инструментации:**
        *   **Декларативный Подход (Приоритетный):** Использовать аннотации, предоставляемые экосистемой OpenTelemetry или совместимыми библиотеками. Для проекта, использующего OTel Agent или Spring Boot OTel Starter, предпочтительны аннотации из пакета `io.opentelemetry.instrumentation.annotations`:
            *   **`@WithSpan`:** Для создания нового спана вокруг метода. Атрибут `value` используется для задания имени спана (например, `@WithSpan("user.registration.validation")`). Если `value` не указан, имя генерируется (например, `ClassName.methodName`). Атрибут `kind` используется для указания типа спана (`SpanKind.CLIENT`, `SpanKind.SERVER`, `SpanKind.PRODUCER`, `SpanKind.CONSUMER`, `SpanKind.INTERNAL` (по умолчанию)).
            *   **`@SpanAttribute`:** Для автоматического добавления значения параметра метода в качестве атрибута спана. Имя атрибута можно указать в аннотации (например, `@SpanAttribute("user.id") Long id`), если оно отличается от имени параметра метода.
        *   **Программный Подход (Для Сложных Случаев):** Использовать OpenTelemetry API напрямую (через `io.opentelemetry.api.trace.Tracer` для создания спанов и `io.opentelemetry.api.trace.Span.current()` для доступа к текущему спану и добавления атрибутов/событий). Этот подход применяется, когда жизненный цикл спана не совпадает с границами одного метода, или требуется очень сложное динамическое управление атрибутами/событиями, которое невозможно выразить декларативно.
    *   **2.4. Именование Кастомных Спанов и Атрибутов:**
        *   **Имена Спанов:** Должны быть осмысленными, лаконичными и следовать конвенции, позволяющей легко их идентифицировать и группировать. Рекомендуемый формат для программно создаваемых или явно именованных спанов: `<домен_или_компонент>.<операция_или_действие>` (например, `user.service.create`, `task.repository.findByOwner`, `email.kafka.sendWelcomeEmail`). Избегать слишком общих имен типа "process" или "handle".
        *   **Имена Атрибутов:** По возможности, использовать стандартные семантические конвенции OpenTelemetry для имен атрибутов (например, `http.method`, `db.statement`, `messaging.destination_name`). Для кастомных атрибутов использовать четкие, понятные имена, возможно, с префиксами, отражающими домен или контекст (например, `app.user.id`, `app.task.priority`).

3.  **Добавление Событий (Events) к Спанам:**
    *   Для фиксации значимых моментов времени или дискретных событий *внутри* одного существующего спана (автоматически или кастомно созданного) **МОЖНО** использовать `Span.current().addEvent("имя_события", Attributes.of(AttributeKey.stringKey("event.detail"), "доп. информация"))`.
    *   **Примеры:** "Начало валидации данных", "Данные провалидированы успешно", "Запрос к внешней системе отправлен", "Получен ответ от внешней системы".
    *   События особенно полезны для понимания внутренней структуры длительных спанов или для отслеживания последовательности шагов, которые нецелесообразно выделять в отдельные под-спаны.

4.  **Обработка Ошибок в Трассах:**
    *   Авто-инструментация и аннотация `@WithSpan` обычно автоматически помечают спан как ошибочный (`StatusCode.ERROR`), если из инструментируемого метода выбрасывается исключение. Запись самого исключения (стектрейс, сообщение) также часто происходит автоматически.
    *   При программном управлении спанами, если операция внутри спана завершилась ошибкой, разработчик **ОБЯЗАН** явно установить статус ошибки для спана (`span.setStatus(StatusCode.ERROR, "Краткое описание причины ошибки")`) и записать информацию об исключении (`span.recordException(exception)`).

5.  **Распространение Контекста Трассировки:**
    *   **Автоматическое Распространение:** Для стандартных протоколов и взаимодействий (HTTP, Kafka с соответствующими OTel-инструментациями) контекст трассировки (содержащий `trace_id` и `span_id`, обычно через W3C Trace Context headers) распространяется автоматически между процессами и компонентами.
    *   **Асинхронные Операции в Приложении:** При использовании механизмов асинхронного выполнения в Java (например, Spring `@Async`, кастомные `ExecutorService`, `CompletableFuture`) **НЕОБХОДИМО** обеспечить корректную передачу и восстановление контекста трассировки в новые потоки или при возобновлении выполнения. Spring Boot OTel Starter и инструментации OTel обычно предоставляют для этого поддержку (например, через инструментированные обертки для `Executor`'ов). Если используются полностью кастомные механизмы асинхронности, может потребоваться ручное управление контекстом с использованием OTel API (`Context.makeCurrent()`, `Context.current().wrap(...)`).

# ADR-0027: Использование `java.time.Clock` для Управления Временем

1.  **Внедрение `java.time.Clock`:**
	*   Все компоненты приложения, которым необходимо получать текущее время (например компоненты, использующие Spring Data JPA Auditing для установки временных меток `@CreatedDate`/`@LastModifiedDate`), **ДОЛЖНЫ** получать его через инъекцию зависимости бина `java.time.Clock`.
	*   **ЗАПРЕЩАЕТСЯ** прямое использование `System.currentTimeMillis()`, `new Date()`, `Instant.now()` (без аргумента `Clock`), `LocalDateTime.now()` (без аргумента `Clock`), `ZonedDateTime.now()` (без аргумента `Clock` или с системной зоной по умолчанию) и т.п. в коде сервисов, контроллеров и других управляемых Spring компонентов.

2.  **Конфигурация Бина `Clock`:**
	*   В основной конфигурации приложения (например, `AppConfig.java`) **ДОЛЖЕН** быть определен бин `Clock`, возвращающий `Clock.systemUTC()`. Это соответствует ADR-0012 (Обеспечение консистентности времени через UTC).
	*   Этот же бин `Clock` **ДОЛЖЕН** использоваться для конфигурации `DateTimeProvider` в `JpaAuditingConfig` (если JPA Auditing используется), чтобы обеспечить консистентность временных меток	 аудита.

3.  **Использование `Clock` в Компонентах:**
	*   Компоненты **ДОЛЖНЫ** получать `Clock` через конструктор и использовать его для получения текущего времени (например, `Instant.now(this.clock)`).

4.  **Тестирование Компонентов, Зависящих от Времени:**
	*   В юнит- и интеграционных тестах, где требуется контроль над временем, системный бин `Clock` **ДОЛЖЕН** быть заменен на экземпляр `Clock` с фиксированным временем.
	*   **Предпочтительный способ:** Использование `Clock.fixed(FIXED_INSTANT, ZoneOffset.UTC)`.
	*   **Альтернативный способ (для специфических сценариев):** Использование моков (например, `@MockBean Clock mockClock;` или `@Mock Clock mockClock;` с `@InjectMocks`). Этот подход может быть полезен, если требуется эмулировать изменение времени в ходе одного тестового метода или верифицировать специфические вызовы методов `Clock` (что обычно не требуется для `instant()` или `getZone()`). При мокировании `Clock` необходимо мокировать как минимум `clock.instant()` и `clock.getZone()`.

# ADR-0028: Обновленная Стратегия Обсервабилити и Выбор Технологического Стека

1.  **Стандарт и Протокол для Телеметрии:**
	*   **OpenTelemetry (OTel)** остается основным стандартом для генерации, сбора и экспорта всех трех сигналов обсервабилити: логов, метрик и распределенных трейсов.
	*   Протокол **OTLP (OpenTelemetry Protocol)** используется для передачи телеметрических данных.

2.  **Централизованный Сбор Телеметрии:**
	*   **OTel Collector** используется как центральный компонент для приема OTLP данных от приложений, их возможной обработки (например, батчинг) и экспорта в соответствующие бэкенды.

3.  **Бэкенды для Хранения и Анализа Сигналов:**
	*   **Метрики:** **Prometheus** для сбора, хранения и запроса метрик.
	*   **Трейсы:** **Tempo** для сбора, хранения и запроса распределенных трейсов.
	*   **Логи:** **Loki** для сбора, хранения и запроса логов.
	*   **Визуализация:** **Grafana** как единый интерфейс для визуализации метрик (из Prometheus), трейсов (из Tempo) и логов (из Loki).
	*   **SPAN-метрики и Графы Сервисов из Трейсов:** **Tempo** (с компонентом `metrics_generator`) анализирует входящие трейсы для генерации агрегированных метрик (RED-метрики: Rate, Errors, Duration) и данных для графа зависимостей сервисов. Эти метрики экспортируются из Tempo в **Prometheus** через `remote_write`.

4.  **Инструментация Бэкенд-Приложений (Java/Spring Boot - `task-tracker-backend` и аналогичные):**
	*   **Основной Интеграционный Компонент:** Зависимость `io.opentelemetry.instrumentation:opentelemetry-spring-boot-starter` является ключевой для интеграции Spring Boot приложений с OpenTelemetry.
	*   **Логирование:**
		*   **Фреймворк:** SLF4J с реализацией Logback.
		*   **Формат:** Структурированные логи в формате **JSON ECS (Elastic Common Schema)** для вывода в консоль и для экспорта.
		*   **Экспорт:** Логи захватываются и экспортируются в OTel Collector (и далее в Loki) через **OTel Logback Appender**, сконфигурированный в `logback-spring.xml` (или через автоконфигурацию, если `otel.instrumentation.logback-appender.enabled=true`).
		*   **Корреляция:** `trace_id` и `span_id` (из OpenTelemetry) автоматически включаются в экспортируемые логи, обеспечивая их связь с трассами (согласно ADR-0023).
	*   **Метрики:**
		*   **API и Сбор:** Используется **Micrometer API** (стандартный для Spring Boot). Собираются стандартные метрики Spring Boot Actuator, JVM, пула соединений DataSource и другие автоконфигурируемые Micrometer-метрики.
		*   **Кастомные Метрики:** Разработчики **ДОЛЖНЫ** создавать кастомные бизнес- и технические метрики с использованием Micrometer API.
		*   **Экспорт:** Метрики, собранные Micrometer, экспортируются в OTel Collector через мост `micrometer-registry-otlp` (требует `otel.instrumentation.micrometer.enabled=true` в конфигурации).
	*   **Трассировка:**
		*   **API и Авто-Инструментация:** Используется **OpenTelemetry SDK**, интегрированный через `opentelemetry-spring-boot-starter`. Этот стартер обеспечивает авто-инструментацию для стандартных компонентов (Spring WebMVC, JDBC, Kafka и т.д.).
		*   **Кастомная Инструментация:** Для добавления специфичных для приложения спанов и атрибутов **ДОЛЖЕН** использоваться **OpenTelemetry API** напрямую или через декларативные аннотации из пакета `io.opentelemetry.instrumentation.annotations` (например, `@WithSpan`, `@SpanAttribute`). Это требует добавления зависимости `spring-boot-starter-aop`. Детали и критерии применения кастомной инструментации описаны в **ADR-0026**.
		*   **Распространение Контекста:** Контекст трассировки распространяется автоматически для поддерживаемых протоколов. Особое внимание уделяется корректному распространению контекста при асинхронных операциях (см. ADR-0026).

5.  **Инфраструктура для Локальной Разработки (`dev`):**
	*   Полный стек обсервабилити (OTel Collector, Prometheus, Tempo, Grafana, Loki) разворачивается через `docker-compose.yml`.

6.  **Конфигурация Обсервабилити по Профилям Spring Boot:**
	*   **`dev`:** Максимальная детализация. Все экспортеры OTel включены, 100% сэмплирование трейсов, подробные логи. `otel.instrumentation.micrometer.enabled=true`.
	*   **`ci`:** Фокус на диагностике тестов. **OTel SDK и экспорт OTLP для трейсов и метрик ОТКЛЮЧЕНЫ** (`otel.sdk.disabled=true`) для экономии ресурсов и ускорения CI-сборок. Логирование подробное (DEBUG для приложения и SQL), формат JSON ECS, но без автоматической корреляции `trace_id`/`span_id` из-за отключенного OTel SDK.
	*   **`prod` (видение):** Фокус на мониторинге здоровья, SLI/SLO, алертинге. Сэмплирование трейсов (например, вероятностное или хвостовое), уровни логирования INFO/WARN, экспорт всех сигналов в выделенный, отказоустойчивый стек. `otel.instrumentation.micrometer.enabled=true`.
	
# ADR-0029: Определение Архитектуры Слоя Персистентности для Backend Сервисов

1.  **ORM и Стандарт:** Использовать **Jakarta Persistence API (JPA)** как стандарт для объектно-реляционного отображения. В качестве реализации JPA использовать **Hibernate**.
2.  **Доступ к данным:** Использовать **Spring Data JPA** для упрощения создания слоя доступа к данным (репозиториев).
3.  **Управление транзакциями:** Использовать декларативное управление транзакциями Spring (`@Transactional`).
4.  **Валидация сущностей:** Использовать аннотации **Jakarta Bean Validation** на полях JPA-сущностей. Сообщения валидации должны извлекаться из Resource Bundle (согласно ADR-0024).
5.  **Аудит временных меток:** Для полей, отслеживающих время создания и последнего обновления сущностей (например, `createdAt`, `updatedAt`):
    *   Тип данных `java.time.Instant` в Java-сущностях (соответствует `TIMESTAMPTZ` в PostgreSQL, согласно ADR-0012).
    *   Использовать аннотации **Spring Data JPA Auditing (`@CreatedDate`, `@LastModifiedDate`)**.
    *   Активировать JPA Auditing с помощью `@EnableJpaAuditing(dateTimeProviderRef = "auditingDateTimeProvider")` в конфигурационном классе (например, `AppConfig`).
    *   Предоставить кастомный бин `DateTimeProvider` с именем `auditingDateTimeProvider`, который использует инжектированный бин `java.time.Clock` (сконфигурированный на UTC, согласно ADR-0027) для получения текущего времени. Это обеспечивает консистентность времени и улучшает тестируемость.
    *   Сущности, подлежащие аудиту, должны быть аннотированы `@EntityListeners(AuditingEntityListener.class)`.
6.  **Генерация первичных ключей:** По умолчанию для автоинкрементных первичных ключей использовать стратегию JPA **`@GeneratedValue(strategy = GenerationType.SEQUENCE)`** в сочетании с аннотацией **`@SequenceGenerator`**.
    *   Это обеспечивает получение ID до фактической вставки (`INSERT`) в базу данных, что полезно для снижения нагрузки на базу и/или для пакетных операций, где ID могут быть нужны заранее.
    *   Каждая сущность, требующая автогенерируемого ID, будет иметь свой собственный именованный sequence в базе данных (например, `users_id_seq`, `tasks_id_seq`), который будет создаваться через миграции Liquibase.
    *   Стратегия `GenerationType.IDENTITY` будет рассматриваться только в исключительных случаях, если для конкретной сущности она будет явно более подходящей и не будет ожидаться пакетных операций с предварительным получением ID.
7.  **Проверка соответствия схемы:** Настроить Hibernate на проверку соответствия JPA-сущностей схеме БД, созданной Liquibase, используя свойство `spring.jpa.hibernate.ddl-auto: validate`.
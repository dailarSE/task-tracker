## ADR-0001: Выбор Java/Spring Boot для бэкенда и ориентация на микросервисный подход

Использовать Java и Spring Boot для разработки бэкенд-сервисов. Проект будет развиваться с прицелом на микросервисную архитектуру. Использовать Maven для сборки.

## ADR-0002: Использование PostgreSQL в качестве основной реляционной СУБД

Использовать PostgreSQL

## ADR-0003: Внедрение комплексного стека обсервабилити (OTel, Prometheus, Grafana, Loki, Tempo)

Использовать OpenTelemetry (OTel) как стандарт для сбора телеметрии. Интегрировать стек: Prometheus для метрик, Loki для логов, Tempo для трейсов, Grafana для визуализации, OTel Collector для сбора и процессинга.

## ADR-0004: Использование Liquibase для управления миграциями базы данных

Использовать **Liquibase** в качестве инструмента для управления миграциями схемы базы данных. Миграции будут писаться в формате YAML и интегрироваться с жизненным циклом Spring Boot приложения, так что они будут автоматически применяться при старте приложения.

## ADR-0005: Определение Архитектуры Слоя Персистентности для Backend Сервисов

1.  **ORM и Стандарт:** Использовать **Jakarta Persistence API (JPA)** как стандарт для объектно-реляционного отображения. В качестве реализации JPA использовать **Hibernate**.
2.  **Доступ к данным:** Использовать **Spring Data JPA** для упрощения создания слоя доступа к данным (репозиториев).
3.  **Управление транзакциями:** Использовать декларативное управление транзакциями Spring (`@Transactional`).
4.  **Валидация сущностей:** Использовать аннотации **Jakarta Bean Validation** на полях JPA-сущностей.
5.  **Аудит временных меток:** Для полей, отслеживающих время создания и последнего обновления сущностей (например, `createdAt`, `updatedAt`):
    *   Тип данных `java.time.Instant` в Java-сущностях (соответствует `TIMESTAMPTZ` в PostgreSQL, согласно ADR-0011).
    *   Использовать аннотации **Hibernate (`@CreationTimestamp`, `@UpdateTimestamp`)**. Выбор в пользу аннотаций Hibernate сделан из-за их простоты и отсутствия необходимости в дополнительной конфигурации Spring Data JPA Auditing (`@EnableJpaAuditing`, `AuditorAware`), которая была бы избыточна для текущих требований простого аудита времени. Если в будущем потребуется аудит по пользователю (`@CreatedBy`, `@LastModifiedBy`), будет рассмотрен переход на полное решение Spring Data JPA Auditing.
6.  **Генерация первичных ключей:** По умолчанию для автоинкрементных первичных ключей использовать стратегию JPA **`@GeneratedValue(strategy = GenerationType.SEQUENCE)`** в сочетании с аннотацией **`@SequenceGenerator`**.
    *   Это обеспечивает получение ID до фактической вставки (`INSERT`) в базу данных, что полезно для снижения нагрузки на базу и/или для пакетных операций, где ID могут быть нужны заранее.
    *   Каждая сущность, требующая автогенерируемого ID, будет иметь свой собственный именованный sequence в базе данных (например, `users_id_seq`, `tasks_id_seq`), который будет создаваться через миграции Liquibase.
    *   Стратегия `GenerationType.IDENTITY` будет рассматриваться только в исключительных случаях, если для конкретной сущности она будет явно более подходящей и не будет ожидаться пакетных операций с предварительным получением ID.
7.  **Проверка соответствия схемы:** Настроить Hibernate на проверку соответствия JPA-сущностей схеме БД, созданной Liquibase, используя свойство `spring.jpa.hibernate.ddl-auto: validate`.

## ADR-0006: Использование Timestamp-based именования для файлов миграций Liquibase

Использовать **именование файлов миграций Liquibase на основе временной метки (timestamp-based naming)**.
Формат имени файла будет следующим: `YYYY-MM-DD-HH-MM-SS-краткое-описательное-имя.yaml`.
Например: `2025-05-09-10-30-00-create-users-table.yaml`.
Временная метка соответствует моменту создания (или коммита) файла миграции.

## ADR-0007: Использование структуры пакетов по доменам (фичам) в Backend сервисе

Использовать **организацию пакетов по доменам (фичам)** для бэкенд-сервиса `task-tracker-backend`.
Это означает, что пакеты верхнего уровня будут соответствовать основным бизнес-областям или функциональным возможностям системы. Например:
- `com.example.tasktracker.backend.user` (для всего, что связано с пользователями и аутентификацией)
- `com.example.tasktracker.backend.task` (для управления задачами)
- `com.example.tasktracker.backend.notification` (для отправки уведомлений)
Внутри каждого пакета домена компоненты могут быть сгруппированы по техническим слоям (например, `controller`, `service`, `entity`, `repository`, `dto`), но основной принцип группировки — принадлежность к фиче.
Также будут существовать общие пакеты на верхнем уровне для конфигураций и переиспользуемых компонентов, не относящихся к конкретному домену, например:
- `com.example.tasktracker.backend.config` (общие конфигурации Spring)
- `com.example.tasktracker.backend.common` (общие утилиты, исключения, модели)

## ADR-0008: Использование Testcontainers для интеграционных тестов базы данных

Использовать **Testcontainers** для проведения интеграционных тестов слоя персистентности (в частности, для тестирования Spring Data JPA репозиториев).
Testcontainers будут использоваться для запуска Docker-контейнера с PostgreSQL непосредственно из кода тестов. Каждый тестовый класс (или тестовый набор) будет работать с чистым, изолированным экземпляром базы данных. Интеграция со Spring Boot будет осуществляться с помощью `spring-boot-testcontainers` и аннотации `@ServiceConnection` для автоматической настройки `DataSource`.

## ADR-0009: Определение стратегии обсервабилити и выбор технологического стека

1.  **Стандарт и Протокол:** Принять **OpenTelemetry (OTel)** как основной стандарт для генерации, сбора и экспорта телеметрии (логов, метрик, трейсов). Использовать протокол OTLP для передачи данных.
2.  **Централизованный Сбор:** Использовать **OTel Collector** как центральный компонент для приема OTLP данных от приложений, их возможной обработки и экспорта в соответствующие бэкенды.
3.  **Бэкенды для Сигналов:**
    *   **Метрики:** **Prometheus** для сбора, хранения и запроса метрик.
    *   **Трейсы:** **Tempo** для сбора, хранения и запроса распределенных трейсов.
    *   **Логи:** **Loki** для сбора, хранения и запроса логов.
    *   **Визуализация:** **Grafana** для единого интерфейса визуализации метрик (из Prometheus), трейсов (из Tempo) и логов (из Loki).
	*   **Генерация Метрик из Трейсов (SPAN-метрики и Графы Сервисов):**
    *   **Tempo** (с использованием компонента `metrics_generator`) будет анализировать входящие трейсы для генерации агрегированных метрик (например, количество запросов, задержки, ошибки на уровне отдельных SPAN'ов или сервисов) и данных для построения графа зависимостей сервисов. Эти сгенерированные метрики будут отправляться из Tempo в **Prometheus** через механизм `remote_write`. Это позволяет получать RED-метрики (Rate, Errors, Duration) и строить карты сервисов автоматически на основе данных трассировки, дополняя метрики, собираемые непосредственно из приложений.
4.  **Инструментация Бэкенд-Приложений (Java/Spring Boot):**
    *   **Логирование:** SLF4J/Logback, настроенный на вывод структурированных логов в формате **JSON ECS**. Обеспечить включение `trace_id` и `span_id` (из OTel/Micrometer Tracing) в логи для корреляции. Логи будут собираться OTel Collector (либо через stdout, либо через OTel Logback Appender).
    *   **Метрики:** Micrometer API в приложении. Экспорт метрик через `micrometer-registry-otlp` в OTel Collector. Включение стандартных метрик Spring Boot Actuator и JVM, а также метрик пула соединений DataSource. Поощряется создание кастомных бизнес- и технических метрик.
    *   **Трассировка:** Micrometer Tracing с мостом к OpenTelemetry (`micrometer-tracing-bridge-otel`). Авто-инструментация для HTTP, JDBC. Обеспечение распространения контекста трассировки.
5.  **Инфраструктура для Локальной Разработки (`dev`):** Полный стек (OTel Collector, Prometheus, Tempo, Grafana, Loki) разворачивается через `docker-compose.yml` для максимальной детализации и отладки.
6.  **Конфигурация по Стендам (Профили Spring Boot):** Использовать профили (`dev`, `ci`, `prod`) для дифференцированной настройки обсервабилити:
    *   **`dev`:** Максимальная детализация. Все экспортеры OTel включены, 100% сэмплирование трейсов, подробные логи.
    *   **`ci`:** Фокус на диагностике тестов. OTel SDK и экспорт OTLP для метрик и трейсов **отключены** для экономии ресурсов и ускорения (`otel.sdk.disabled: true`). Логирование подробное (DEBUG уровни для приложения и SQL), формат JSON ECS, но без `trace_id`/`span_id` из-за отключенного OTel SDK.
    *   **`prod` (видение):** Фокус на мониторинге здоровья, SLI/SLO, алертинге. Сэмплирование трейсов, уровни логирования INFO/WARN, экспорт всех сигналов в выделенный, отказоустойчивый стек.
	
## ADR-0010: Выбор и конфигурация CI-сервера и агента для сборки и тестирования

1.  **CI-сервер:** Использовать **Jenkins**, развернутый в Docker-контейнере на основной VPS. Образ `jenkins/jenkins:lts-jdk21` (или аналогичный с нужной версией JDK).
2.  **Jenkins Агент:** Использовать **внешний Jenkins агент**, установленный и работающий непосредственно на **хост-машине VPS Ubuntu 22**.
    *   **Подключение к Master:** Агент подключается к Jenkins Master (в Docker) через JNLP (или WebSocket).
    *   **Метка Агента:** Агенту присвоена метка (label) `ubuntu-docker` для использования в `Jenkinsfile`.
    *   **Доступ к Docker:** Пользователь, от имени которого работает агент на VPS, добавлен в группу `docker`, что обеспечивает агенту прямой доступ к Docker-демону хост-машины. Это необходимо для запуска Testcontainers.
    *   **Управление:** Агент настроен как systemd сервис для автоматического запуска при старте VPS.
3.  **`Jenkinsfile`:** Пайплайн Jenkins определяется в `Jenkinsfile` в корне репозитория, используется декларативный синтаксис.
4.  **Профиль для CI:** В приложении Spring Boot используется профиль `ci` (`application-ci.yml`) для специфичных настроек во время выполнения на CI-агенте (например, уровни логирования, отключение OTel SDK).

## ADR-0011: Стратегия конфигурации локального dev-окружения с использованием Docker Compose и Spring Boot профилей

1.  **Инфраструктура через `docker-compose.yml`:** Все внешние зависимости для локальной разработки (PostgreSQL, Kafka, OTel Collector, Prometheus, Grafana, Loki, Tempo) определяются и запускаются через единый `docker-compose.yml` файл в корне проекта.
2.  **Spring Boot профиль `dev`:**
    *   Приложение `task-tracker-backend`, запущенное из IDE, использует профиль `dev` (активируется через VM Option `-Dspring.profiles.active=dev`).
    *   **`application-dev.yml`:**
        *   URL для подключения к PostgreSQL: `jdbc:postgresql://postgres:5432/task_tracker_db` (при наличии соответствующей записи в `hosts` файле, указывающей на `127.0.0.1`).
        *   Учетные данные для PostgreSQL (`spring.datasource.username`, `spring.datasource.password`): **Жестко прописаны** как `devuser` и `devpass`, чтобы соответствовать конфигурации PostgreSQL в `docker-compose.yml`.
        *   Включено детальное логирование SQL (`show-sql: true`, `format-sql: true`, уровни DEBUG/TRACE для Hibernate).
        *   OTel SDK включен, сэмплирование трейсов 100%.
        *   Эндпоинт OTel Collector для отправки телеметрии: `http://otel-collector:4318` (предполагая, что порт OTel Collector проброшен на хост).
3.  **Разрешение имен сервисов:** Для удобства подключения к сервисам, запущенным в Docker, из приложения на хосте (если используется имя сервиса, а не `localhost`), разработчики могут добавить соответствующие записи в свой локальный `hosts` файл (например, `127.0.0.1 postgres`, `127.0.0.1 otel-collector`).

## ADR-0012: Обеспечение консистентности времени через использование UTC во всех компонентах системы

1.  **Стандартный Часовой Пояс для Серверной Логики и Хранения:** Все серверные компоненты (приложение `task-tracker-backend`, база данных PostgreSQL, в будущем другие микросервисы) должны работать и хранить все временные метки в **UTC (Coordinated Universal Time)**.
2.  **Конфигурация JVM:** Для приложения `task-tracker-backend` при запуске из IDE (в `dev` профиле) и при выполнении тестов на CI-агенте (через Maven Surefire Plugin) будет установлена системная переменная JVM `-Duser.timezone=UTC`. *Примечание: Настройка для Docker-контейнера приложения отложена до этапа контейнеризации.*
3.  **Конфигурация Базы Данных (PostgreSQL):**
    *   Сервер PostgreSQL (запускаемый в Docker) по умолчанию инициализируется и работает в часовом поясе UTC. Это поведение будет сохранено.
    *   Для колонок, хранящих временные метки (например, `created_at`, `updated_at` в таблице `users`), используется тип данных **`TIMESTAMP WITH TIME ZONE` (TIMESTAMPTZ)**. В PostgreSQL этот тип данных хранит значение как момент времени в UTC, а при извлечении конвертирует его в часовой пояс сессии клиента (если он отличается).
4.  **Обработка времени в Java-коде:**
    *   Для представления моментов времени в Java-сущностях и DTO используется тип `java.time.Instant`, который всегда представляет собой точку на временной шкале UTC.
    *   Любые операции с датой/временем на сервере, требующие знания текущего момента, должны получать его как момент в UTC (например, через `@CreationTimestamp`, `@UpdateTimestamp` от Hibernate, которые работают с учетом часового пояса JVM, или `Instant.now()`).
5.  **Ответственность Фронтенда за Локальное Время Пользователя:**
    *   **Фронтенд-приложение несет ответственность за определение локального часового пояса пользователя.**
    *   При отправке любых данных, содержащих время, на бэкенд (например, дедлайн задачи), фронтенд должен **конвертировать это локальное время пользователя в UTC** и отправлять на бэкенд уже в UTC (например, в формате ISO 8601 с указанием `Z` или смещения +00:00).
    *   При получении данных от бэкенда (которые всегда будут в UTC), фронтенд несет ответственность за их конвертацию в локальный часовой пояс пользователя для корректного отображения.
	
## ADR-0013: Стандарты и подходы к документированию архитектурных решений и диаграмм

1.  **Architecture Decision Records (ADR):**
    *   **Назначение:** Для фиксации всех архитектурно значимых решений, их контекста, рассмотренных альтернатив и последствий.
    *   **Формат:** Markdown (`.md`).
    *   **Хранение:** В Git-репозитории, в директории `docs/adr/`.
    *   **Структура директорий ADR:** ADR группируются по тематическим поддиректориям (например, `common`, `backend-service`, `database`, `observability`, `ci-cd`, etc.) внутри `docs/adr/` для лучшей организации.
    *   **Именование файлов ADR:** Используется формат `YYYY-MM-DD-HH-MM-краткое-описательное-имя.md` (например, `2025-05-10-10-00-пример-решения.md`). Временная метка обеспечивает глобальную хронологию и уникальность.
    *   **Шаблон ADR:** Используется стандартный шаблон, включающий как минимум: Заголовок (с номером ADR), Статус, Дату, Контекст, Принятое Решение, Рассмотренные Альтернативы, Последствия. Номер ADR присваивается последовательно (например, ADR-0001, ADR-0002).
    *   **Процесс:** Решения обсуждаются командой; ответственный (обычно архитектор или тимлид) формулирует ADR; ADR может проходить неформальное ревью командой.
2.  **Архитектурные Диаграммы (C4 Model):**
    *   **Назначение:** Для визуализации архитектуры на различных уровнях абстракции (Контекст, Контейнеры, Компоненты).
    *   **Инструмент:** `draw.io` для создания и редактирования диаграмм.
    *   **Исходный формат:** Файлы `.drawio` (XML) сохраняются в Git.
    *   **Формат для публикации/документации:** Диаграммы экспортируются в формат **WebP (lossless)** для вставки в Markdown-документы (ADR, README).
    *   **Хранение:** Исходники (`.drawio`) и экспортированные изображения (`.webp`) хранятся в Git-репозитории в директории `docs/diagrams/`. Для детализирующих диаграмм используются поддиректории, соответствующие элементу верхнего уровня (например, `docs/diagrams/task-tracker-system/backend-api/`).
    *   **Именование файлов диаграмм:** `c4-L[Уровень]-описание.drawio` и `c4-L[Уровень]-описание.webp` (например, `c4-L1-system-context.webp`, `c4-L2-containers-task-tracker-system.webp`).
3.  **Файлы `README.md`:**
    *   **Корневой `README.md`:** Содержит общее описание проекта, инструкции по запуску, ссылки на ключевые разделы документации (включая ADR и диаграммы).
    *   **`README.md` на уровне модулей/сервисов:** Содержат специфичную информацию для данного модуля.
4.  **Confluence (или аналогичная Wiki):**
    *   Используется для хранения "живой" информации, не подходящей для Git: практические гайды, протоколы встреч (если не формализованы в ADR), информация о команде, общие процессы.
    *   Не используется для дублирования ADR или диаграмм, которые хранятся в Git. Может содержать обзорные страницы со ссылками на документацию в Git.

## ADR-0014: Процессы принятия архитектурных решений, управления задачами и работы с системой контроля версий

**2.1. Процесс Принятия и Документирования Архитектурных Решений (ADR):**
    *   **Идентификация:** Любой член команды может инициировать обсуждение архитектурно значимого вопроса. Тимлид или архитектор определяет, требует ли вопрос формализации в виде ADR.
    *   **Обсуждение:** Решение обсуждается командой (на встречах, в чате, в комментариях к задаче). Рассматриваются различные варианты.
    *   **Формулирование ADR:** Ответственный (обычно тимлид, архитектор или разработчик, глубоко вовлеченный в проблему) создает черновик ADR в соответствии с принятым шаблоном (см. ADR-0013).
    *   **Ревью ADR (неформальное):** Черновик ADR может быть рассмотрен другими членами команды для получения обратной связи.
    *   **Утверждение:** Решение и ADR считаются принятыми после согласования с тимлидом/архитектором. Статус ADR меняется на "Accepted".
    *   **Хранение:** ADR хранится в Git-репозитории в `docs/adr/` и версионируется вместе с кодом.
    *   **Обновление:** Принятые ADR не изменяются. Если решение пересматривается, создается новый ADR, который ссылается на старый и указывает его новый статус (Deprecated, Superseded).

**2.2. Формализация и Выделение Фич/Задач:**
    *   **Источник:** Требования (ТЗ, User Stories), технический долг, предложения по улучшению.
    *   **Декомпозиция:** Крупные фичи разбиваются на более мелкие, управляемые задачи (например, в Jira).
    *   **Приоритезация:** Задачи приоритезируются в рамках бэклога спринта/проекта.
    *   **Связь с ADR:** Если реализация задачи требует принятия архитектурно значимого решения, создается или обновляется соответствующий ADR.

**2.3. Правила Работы с Ветками (GitHub Flow - адаптированный):**
    *   **`main`:** Основная стабильная ветка. Всегда должна быть в состоянии, готовом к деплою (или отражать последний деплой). Прямые коммиты в `main` запрещены. Слияние только через Pull Request (PR) / Merge Request (MR).
    *   **Feature-ветки (`feature/название-фичи` или `feature/TTN-описание`):** Для каждой новой фичи, улучшения или значимой задачи создается отдельная ветка от актуального состояния `main`.
        *   Именование: `feature/TTN-kratkoe-opisanie` (где TTN - номер задачи в Jira, если используется) или `feature/kratkoe-opisanie-logicheskoy-celi`.
    *   **Bugfix-ветки (`bugfix/название-бага` или `bugfix/TTN-описание`):** Для исправления багов. Создаются от `main` (если баг в текущем релизе) или от соответствующей feature-ветки (если баг найден в ходе разработки фичи).
    *   **Hotfix-ветки (`hotfix/название-хотфикса`):** (Если потребуется для "боевых" ситуаций) Для срочных исправлений в продакшене. Создаются от тега релиза на `main`, мержуются обратно в `main` и в активные feature-ветки.
    *   **Регулярное обновление feature-веток:** Разработчики должны регулярно обновлять свои feature-ветки последними изменениями из `main`. Предпочтительно использовать `git rebase origin/main` для поддержания чистой и линейной истории коммитов в feature-ветке перед созданием PR. В случае сложных или длительных конфликтов при rebase, допустимо использовать `git merge origin/main` в feature-ветку.

**2.4. Правила для Коммитов:**
    *   **Атомарность:** Коммит должен представлять одно логическое изменение.
    *   **Сообщения коммитов:** Использовать стандарт Conventional Commits (например, `feat: ...`, `fix: ...`, `docs: ...`, `refactor: ...`, `test: ...`, `chore: ...`).
        *   Заголовок должен быть кратким и информативным.
        *   Тело коммита (если нужно) должно объяснять "что" и "почему", а не "как".
    *   **Частота:** Коммитить часто, небольшими порциями.

**2.5. Правила Слияния (Pull Request / Merge Request Workflow):**
    *   **Создание PR:** После завершения работы в feature/bugfix-ветке и локального тестирования, разработчик создает PR в `main`.
    *   **Описание PR:** PR должен иметь четкое описание проделанной работы, ссылки на задачи в Jira (если используются), инструкции по тестированию (если нужны).
    *   **CI-проверка:** Автоматический CI-пайплайн (Jenkins) должен успешно пройти для PR (сборка, все тесты).
    *   **Код-ревью:** Обязательное код-ревью как минимум одним другим членом команды (предпочтительно тимлид или другой senior-разработчик). Все замечания должны быть устранены.
    *   **Слияние:** После успешного CI и одобрения ревью, PR может быть смержен.
        *   **Метод слияния:** Предпочтительным методом является **"Rebase and merge"**. Это обеспечивает линейную историю коммитов в ветке `main`. Если `rebase` feature-ветки на `main` вызывает значительные или трудноразрешимые конфликты (например, из-за длительного существования ветки или большого количества пересекающихся изменений), в качестве альтернативы допустимо использовать **"Merge commit"** (со стандартным merge-коммитом, без squash).
    *   **Удаление ветки:** После мержа feature/bugfix-ветка удаляется из удаленного репозитория.

## ADR-0015: Стратегия и подходы к тестированию в проекте "Task Tracker"

**2.1. Юнит-тесты (Unit Tests):**
    *   **Цель:** Тестирование отдельных, изолированных компонентов (классов, методов) на корректность их логики.
    *   **Инструменты:** JUnit 5, Mockito.
    *   **Область применения:** Сервисный слой (бизнес-логика), утилитарные классы, отдельные сложные методы в контроллерах или других компонентах.
    *   **Изоляция:** Зависимости должны быть замоканы для обеспечения изоляции тестируемого юнита.
    *   **Скорость:** Должны быть очень быстрыми.
    *   **Запуск:** Выполняются на фазе `test` Maven плагином Surefire. Запускаются часто локально и всегда на CI.

**2.2. Интеграционные тесты (Integration Tests):**
    *   **Цель:** Тестирование взаимодействия между несколькими компонентами системы или интеграции с внешними зависимостями (база данных, брокеры сообщений, внешние API).
    *   **Типы интеграционных тестов (на текущем этапе и в ближайшем будущем):**
        *   **Тесты слоя персистентности:** Проверка корректности работы Spring Data JPA репозиториев и их взаимодействия с реальной базой данных.
            *   **Инструменты:** Spring Boot Test (`@SpringBootTest` или `@DataJpaTest`), Testcontainers (для PostgreSQL).
        *   **Тесты API/Контроллеров (когда появятся контроллеры):** Проверка работы REST API эндпоинтов, включая валидацию запросов, корректность ответов, обработку ошибок, интеграцию с сервисным слоем.
            *   **Инструменты:** Spring Boot Test (`@SpringBootTest` с `WebEnvironment.MOCK` или `RANDOM_PORT`), MockMvc или RestAssured. Testcontainers могут использоваться, если эндпоинты зависят от БД.
        *   **Тесты взаимодействия с Kafka (когда появится Kafka):** Проверка отправки и получения сообщений.
            *   **Инструменты:** Spring Boot Test, Embedded Kafka (для Spring Kafka) или Testcontainers для Kafka.
    *   **Скорость:** Медленнее юнит-тестов, так как требуют поднятия контекста Spring и/или внешних зависимостей.
    *   **Запуск:**
        *   **Локально:** Могут запускаться разработчиком по необходимости.
        *   **CI:** Обязательно выполняются на CI-сервере.
        *   **Maven:** Будут настроены для запуска плагином Failsafe на фазах `integration-test` и `verify`. Пока запускаются Surefire вместе с юнит-тестами.

**2.3. Контрактные тесты (Contract Tests - видение на будущее):**
    *   **Цель:** (Когда появятся несколько взаимодействующих микросервисов) Проверка соблюдения контрактов (API) между сервисами-провайдерами и сервисами-консьюмерами.
    *   **Инструменты:** Например, Spring Cloud Contract.
    *   **Статус:** На данном этапе не реализуются, но учитываются как возможный следующий шаг при развитии микросервисной архитектуры.

**2.4. End-to-End (E2E) тесты (видение на будущее):**
    *   **Цель:** Тестирование всей системы как "черного ящика" через пользовательский интерфейс (если он будет сложным) или через публичные API, имитируя реальные пользовательские сценарии.
    *   **Инструменты:** Selenium, Cypress, Playwright (для UI); Postman/Newman, Karate DSL (для API E2E).
    *   **Статус:** На данном этапе не реализуются.

**2.5. Покрытие Кода (Code Coverage):**
    *   **Цель:** Измерение процента кода, покрытого автоматическими тестами. Служит индикатором, но не самоцелью.
    *   **Инструменты:** JaCoCo (для Java).
    *   **Процесс:** Отчеты о покрытии будут генерироваться на CI и могут быть интегрированы в Jenkins для визуализации.
	
## ADR-0016: Конвенции и инструменты для интеграционного тестирования JPA и CI-отчетности

1.  **Именование интеграционных тестов:**
    *   Интеграционные тесты, предназначенные для выполнения Maven Failsafe Plugin, должны именоваться с использованием суффикса `IT`. Например: `UserRepositoryIT.java`. Это соответствует стандартным паттернам Failsafe и упрощает конфигурацию.

2.  **Тестирование слоя JPA (Репозитории):**
    *   Для интеграционных тестов компонентов слоя JPA (например, Spring Data JPA репозиториев) рекомендуется использовать аннотацию `@DataJpaTest`.
    *   Эта аннотация загружает сфокусированный срез контекста Spring, необходимый для JPA, автоматически настраивает транзакционность для тестовых методов (с откатом по умолчанию) и может использоваться совместно с Testcontainers (через `@ServiceConnection`) для тестирования на реальной СУБД.

3.  **Отчетность по результатам тестов в CI (Jenkins):**
    *   Jenkins пайплайн настроен на сбор и публикацию результатов юнит-тестов (выполняемых Surefire) и интеграционных тестов (выполняемых Failsafe).
    *   Для этого используется стандартный шаг `junit` в `Jenkinsfile`, который обрабатывает XML-отчеты, генерируемые Maven-плагинами.

4.  **Отчетность по покрытию кода в CI (Jenkins):**
    *   Для сбора данных о покрытии кода используется JaCoCo Maven Plugin, настроенный на сбор данных как от юнит-, так и от интеграционных тестов в единый файл `jacoco.exec`.
    *   Для публикации и визуализации отчетов о покрытии в Jenkins используется "coverage plugin" через шаг `recordCoverage` в `Jenkinsfile`. Пайплайн настроен на обработку XML-отчета `jacoco.xml`.
	
## ADR-0017: Спецификация JWT и Обоснование Выбора

Использовать JSON Web Tokens (JWT)**

    1.  **Обоснование выбора JWT:**
        *   **Stateless:** Серверу не нужно хранить состояние сессии пользователя, что упрощает масштабирование и подходит для распределенных систем.
        *   **Self-contained:** Токен содержит всю необходимую информацию (claims) для идентификации пользователя и базовой авторизации, уменьшая необходимость частых обращений к БД или серверу аутентификации для валидации.
        *   **Стандарт (RFC 7519):** Широко распространенный и поддерживаемый стандарт с множеством библиотек.
        *   **Гибкость:** Подходит для различных типов клиентов (веб, мобильные).
        *   **Безопасность (при правильном использовании):** Подписанные токены защищены от подделки. Использование HTTPS для передачи токенов защищает от их перехвата.

    2.  **Тип используемого токена:**
        *   Будет использоваться только **Access Token**.
        *   **Refresh Token:** На данном этапе **не используется** для упрощения архитектуры. Пользователю потребуется пройти повторную аутентификацию (логин) после истечения срока действия Access Token.

    3.  **Спецификация Access Token:**
        *   **3.1. Алгоритм Подписи:**
            *   **Текущая реализация:** Симметричный алгоритм **HS256 (HMAC with SHA-256)**. Секретный ключ для подписи будет генерироваться и управляться через переменные окружения.
            *   **Перспектива:** Архитектура должна предусматривать возможность конфигурации для поддержки асимметричных алгоритмов (например, RS256) при будущей интеграции с внешними Identity Provider (IdP).
        *   **3.2. Состав (Claims):**
            *   `iss` (Issuer): Идентификатор сервиса, выдавшего токен (например, URI или имя сервиса `task-tracker-backend`).
            *   `sub` (Subject): **Уникальный числовой идентификатор пользователя (`Long id`)** из базы данных. Является основным идентификатором пользователя в контексте токена.
            *   `exp` (Expiration Time): Unix timestamp, определяющий время истечения срока действия токена.
            *   `iat` (Issued At): Unix timestamp, определяющий время выдачи токена.
            *   `jti` (JWT ID): Уникальный идентификатор токена (рекомендуется для обеспечения уникальности и возможности отслеживания).
            *   `email` (Кастомный claim): Email адрес пользователя, связанного с `sub`. Предназначен для удобства использования на клиенте или в других сервисах.
            *   `roles` (Кастомный claim): *Массив строк. Зарезервировано для будущего использования* (например, для передачи ролей пользователя, таких как `"ROLE_ADMIN"`).
        *   **3.3. Время Жизни:**
            *   **15-60 минут.** Конкретное значение настраивается через конфигурацию приложения. Короткое время жизни повышает безопасность, уменьшая окно для использования потенциально скомпрометированного токена.
        *   **3.4. Передача Клиентом:**
            *   Токен должен передаваться клиентом в HTTP-заголовке `Authorization` со схемой `Bearer`:
                `Authorization: Bearer <token>`
        *   **3.5. Отзыв Токенов (Revocation):**
            *   На данном этапе **не реализуется**, так как JWT по своей природе stateless. Операция Logout на стороне клиента будет заключаться в удалении токена из хранилища клиента.
			
## ADR-0018: Требования и Процесс Аутентификации Пользователя

1.  **Регистрация Нового Пользователя:**
        *   **Эндпоинт:** `POST /user` (публично доступен).
        *   **Входные данные (Request Body):** JSON-объект, содержащий `email`, `password`, `repeatPassword`.
        *   **Проверки (Валидация):**
            *   Валидность формата email.
            *   Совпадение `password` и `repeatPassword`.
            *   Уникальность email в системе.
            *   *Требования к сложности и минимальной длине пароля на данном этапе не определены. При необходимости будут введены и задокументированы позже; может потребоваться механизм для обновления существующих паролей пользователей.*
        *   **Действия при успехе (HTTP 201 Created):**
            *   Создание новой записи пользователя в базе данных. Пароль должен храниться в хешированном виде с использованием сильного, общепринятого алгоритма (например, BCrypt, предоставляемый стандартными реализациями `PasswordEncoder` из Spring Security).
            *   **Автоматическая аутентификация:** Пользователь считается аутентифицированным немедленно после успешной регистрации.
            *   Генерация Access Token (согласно ADR-0017).
            *   Возврат JSON-ответа, содержащего Access Token. Рекомендуемая структура ответа:
                ```json
                {
                  "access_token": "your_jwt_token_here",
                  "token_type": "Bearer",
                  "expires_in": 3600 // Время жизни токена в секундах, информационно
                }
                ```
            *   В HTTP-ответе также **ДОЛЖЕН** присутствовать заголовок `Location` с URI созданного ресурса пользователя (например, `/user/me` или `/users/{userId}`).
            *   Отправка приветственного email пользователю (асинхронно, например, через Kafka).
        *   **Действия при ошибке:**
            *   При ошибках валидации входных данных (неверный формат email, несовпадение паролей): HTTP **400 Bad Request**.
            *   Если email уже занят: HTTP **409 Conflict**.
            *   Тело ответа во всех случаях ошибки должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
                *   `type`: URI, идентифицирующий тип проблемы (например, `https://task-tracker.example.com/probs/validation-error`, `https://task-tracker.example.com/probs/email-already-taken`). Эти URI должны быть определены и задокументированы.
                *   `title`: Краткое, человекочитаемое описание типа проблемы.
                *   `status`: HTTP-статус код ответа (400 или 409).
                *   `detail`: Человекочитаемое описание конкретной ошибки.
                *   (Для ошибок валидации 400) Рекомендуется использовать расширение `errors` (массив объектов), детализирующее ошибки по конкретным полям запроса, если это применимо.

    2.  **Аутентификация (Логин) Существующего Пользователя:**
        *   **Эндпоинт:** `POST /auth/login` (публично доступен).
        *   **Входные данные (Request Body):** JSON-объект, содержащий `email` и `password`.
        *   **Проверки:**
            *   Наличие пользователя с указанным email.
            *   Совпадение предоставленного пароля с сохраненным хешем.
        *   **Действия при успехе (HTTP 200 OK):**
            *   Генерация Access Token (согласно ADR-0017).
            *   Возврат JSON-ответа с Access Token, аналогично структуре при регистрации:
                ```json
                {
                  "access_token": "your_jwt_token_here",
                  "token_type": "Bearer",
                  "expires_in": 3600
                }
                ```
        *   **Действия при ошибке (HTTP 401 Unauthorized):**
            *   Возврат HTTP-ответа со статус-кодом `401 Unauthorized`.
            *   Заголовок `WWW-Authenticate: Bearer realm="task-tracker"` (или иной согласованный `realm`) **ДОЛЖЕН** быть включен. Дополнительно **МОГУТ** быть включены параметры `error` (например, `"invalid_grant"`) и `error_description` (например, `"Invalid credentials"`), согласно RFC 6750.
            *   Тело ответа должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
                *   `type`: URI (например, `https://task-tracker.example.com/probs/invalid-credentials`).
                *   `title`: "Invalid Credentials" или аналогичное.
                *   `status`: 401.
                *   `detail`: "The email or password provided is incorrect."

    3.  **Logout Пользователя:**
        *   Так как используются stateless JWT без серверного механизма отзыва (согласно ADR-0017), операция Logout является ответственностью **клиентской стороны** и заключается в безопасном удалении сохраненного Access Token.
        *   Серверный эндпоинт `/logout` на данном этапе **не реализуется**, так как он не предоставляет дополнительной функциональности по аннулированию JWT на стороне сервера.

# ADR-0019: Требования и Механизмы Авторизации Доступа к Ресурсам

    1.  **Основной Принцип Авторизации:**
        *   **Авторизация на основе владения ресурсом (Resource-based ownership):** Пользователь, идентифицированный по `userId` (из `sub` claim JWT, согласно ADR-0017), может выполнять операции только над ресурсами, которые ему принадлежат (т.е., связаны с его `userId`).
        *   **"Безопасные по умолчанию" репозитории:** Логика проверки владения должна быть максимально приближена к слою доступа к данным.

    2.  **Реализация Авторизации в Слоях:**

        *   **2.1. Слой Репозиториев (`TaskRepository` и аналогичные):**
            *   Является **основным местом** для реализации авторизации по владению ресурсом при операциях чтения.
            *   **Ограничение интерфейсов:** Интерфейсы репозиториев **не должны наследовать стандартные "всеобъемлющие" интерфейсы Spring Data JPA** (типа `JpaRepository`, `CrudRepository`) без явной и обоснованной необходимости. Вместо этого, они должны определять кастомный набор методов. Каждый такой метод, предназначенный для общего пользовательского доступа, по умолчанию должен быть "безопасным" (т.е., учитывать `userId` текущего пользователя).
            *   **Чтение данных (списки, одиночные сущности):** Авторизация встраивается непосредственно в JPQL/SQL запросы с использованием **Security Expressions в аннотации `@Query`**, ссылающихся на `principal.id`.
                *   Пример для получения списка задач текущего пользователя:
                    `@Query("SELECT t FROM Task t WHERE t.user.id = ?#{ principal.id }")`
                *   Пример для получения конкретной задачи текущего пользователя по ее ID:
                    `@Query("SELECT t FROM Task t WHERE t.id = :taskId AND t.user.id = ?#{ principal.id }")`
                *   Если ресурс не принадлежит пользователю или не существует, такие запросы вернут пустой результат (например, пустой список или `Optional.empty()`), что соответствует стратегии сокрытия информации.
            *   **Создание данных (`save` для новых сущностей):**
                *   Репозиторий предоставляет метод `save(S entity)`.
                *   Ответственность **сервисного слоя:** Установить корректный `userId` (полученный из `SecurityContext`) на новой сущности *перед* вызовом `save`.
                *   Поле `userId` в сущности `Task` (и аналогичных сущностях, принадлежащих пользователю) **ДОЛЖНО** быть сконфигурировано как неизменяемое после первоначальной установки (JPA аннотация `@Column(name = "user_id", nullable = false, updatable = false)`). Это предотвращает случайное или намеренное изменение владельца ресурса через стандартные операции обновления.
            *   **Обновление данных (`save` для существующих сущностей):**
                *   Сервисный слой **ОБЯЗАН** сначала загрузить существующую сущность через "безопасный" метод репозитория (например, `findByIdAndCurrentUser`). Это неявно подтверждает право пользователя на модификацию (т.к. он смог ее прочитать).
                *   После модификации полей сущности в сервисном слое, вызывается тот же метод `save(S entity)`. Неизменяемость поля `userId` гарантирует, что владелец не будет изменен.
            *   **Удаление данных:**
                *   Репозиторий **ДОЛЖЕН** предоставлять "безопасный" метод удаления, который включает проверку `userId` непосредственно в запросе.
                *   Пример: `@Modifying @Query("DELETE FROM Task t WHERE t.id = :taskId AND t.user.id = ?#{ principal.id }") int deleteByIdAndCurrentUser(@Param("taskId") Long taskId);`
                *   Сервисный слой вызывает этот метод. Возвращаемое значение (количество удаленных записей) может использоваться для определения, была ли операция успешной и принадлежал ли ресурс пользователю.

        *   **2.2. Сервисный Слой (`TaskService` и аналогичные):**
            *   Использует **исключительно "безопасные" методы репозиториев** для всех операций, где важна принадлежность ресурса пользователю.
            *   Отвечает за установку `userId` для новых сущностей перед их сохранением.
            *   Для более сложных бизнес-правил авторизации, которые не могут быть полностью выражены на уровне запросов репозитория, или для защиты методов, не связанных напрямую с CRUD одной сущности, может использоваться **Spring Method Security (`@PreAuthorize`, `@PostAuthorize`, `@PostFilter`)**.
            *   Логика таких проверок, если она сложная или переиспользуемая, инкапсулируется в отдельном Spring бине (например, `PermissionService`), методы которого вызываются из SpEL-выражений.
                Пример: `@PreAuthorize("@permissionService.canUserPerformComplexAction(authentication, #resourceId)")`.

        *   **2.3. `PermissionService` (или аналогичный бин):**
            *   Служит для централизации и инкапсуляции сложных или переиспользуемых правил авторизации, которые не являются простым сопоставлением `userId`.
            *   Не должен дублировать базовую проверку владения, если она эффективно реализована на уровне репозитория.

    3.  **Конфигурация Spring Security для Авторизации:**
        *   Использовать `@EnableMethodSecurity` для активации Method Security.
        *   Убедиться, что Java-код компилируется с флагом `-parameters` для корректной работы SpEL.
        *   Кастомная реализация `UserDetails` (из ADR-0018) должна предоставлять `id` пользователя для использования в `?#{ principal.id }`.

    4.  **Административный Доступ:**
        *   На данном этапе не реализуется в основном пользовательском API.
        *   Если в будущем потребуется административный доступ к ресурсам всех пользователей, он будет реализован через:
            *   Специальную роль (например, `ROLE_ADMIN`), включаемую в JWT администратора (см. ADR-0017).
            *   Проверки этой роли в `@PreAuthorize` (например, `@PreAuthorize("hasRole('ADMIN')")`).
            *   Отдельные "админские" методы в сервисах и/или репозиториях, которые не применяют стандартную фильтрацию по `userId` текущего пользователя, или используют для этого специальный параметр. Рассмотреть выделение таких операций в отдельные компоненты или даже сервисы.

    5.  **Обработка Ошибок Авторизации:**
        *   При попытке доступа к чужому ресурсу или выполнения неразрешенного действия, API **ДОЛЖЕН** вернуть:
            *   Предпочтительно **HTTP 404 Not Found**, если операция касается конкретного ресурса по ID (например, `GET /tasks/{taskId}`, `PUT /tasks/{taskId}`, `DELETE /tasks/{taskId}`). Это скрывает факт существования ресурса от неавторизованного пользователя.
            *   **HTTP 403 Forbidden** в других случаях отказа авторизации (например, если пользователь аутентифицирован, но не имеет нужной роли для выполнения общего действия).
        *   Тело ответа во всех случаях ошибки должно быть в формате `application/problem+json` (RFC 9457), содержащим как минимум:
            *   `type`: URI, идентифицирующий тип проблемы (например, `https://task-tracker.example.com/probs/access-denied`, `https://task-tracker.example.com/probs/resource-not-found`).
            *   `title`: Краткое описание типа проблемы.
            *   `status`: HTTP-статус код ответа (403 или 404).
            *   `detail`: Описание конкретной ошибки.

# ADR-0020: Архитектура Компонентов Безопасности в Backend Сервисе (`task-tracker-backend`)

1.  **Основная Конфигурация Spring Security (`SecurityConfig`):**
        *   Класс, аннотированный `@Configuration` и `@EnableWebSecurity`.
        *   Использует `@EnableMethodSecurity(prePostEnabled = true)` для активации Method Security (поддержка `@PreAuthorize` и др.).
        *   Определяет бин `SecurityFilterChain`. В этом бине конфигурируется:
            *   Отключение CSRF: `http.csrf(AbstractHttpConfigurer::disable)`.
            *   Управление сессиями: `http.sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`.
            *   Правила доступа к эндпоинтам (`http.authorizeHttpRequests`):
                *   Разрешение публичного доступа (`.permitAll()`) к `POST /user` (регистрация) и `POST /auth/login` (логин).
                *   Требование аутентификации (`.authenticated()`) для всех остальных запросов (например, `/tasks/**`, `GET /user`).
            *   Добавление кастомного `JwtAuthenticationFilter` (см. п.2) перед стандартным фильтром `UsernamePasswordAuthenticationFilter` Spring Security.
            *   Настройка `AuthenticationEntryPoint` (см. п.5) для обработки ошибок при попытке доступа неаутентифицированного пользователя к защищенным ресурсам.
            *   Настройка `AccessDeniedHandler` (см. п.5) для обработки ошибок авторизации аутентифицированного пользователя.
            *   Конфигурация CORS.
        *   Определяет бин `PasswordEncoder` (например, `BCryptPasswordEncoder`).
        *   Определяет бин `AuthenticationManager` (через `AuthenticationConfiguration`).

    2.  **Фильтр Аутентификации JWT (`JwtAuthenticationFilter`):**
        *   Кастомный фильтр (`OncePerRequestFilter`). Извлекает JWT из запроса, валидирует его через `JwtTokenProvider` (см. п.3) и, при успехе, устанавливает `Authentication` в `SecurityContextHolder`.

    3.  **Компоненты для Работы с JWT (`JwtTokenProvider`):**
        *   Сервисный класс, ответственный за генерацию JWT (на основе `UserDetails` или `userId`/`email`), валидацию JWT (подпись, срок действия), извлечение claims (включая `userId`), а также за формирование объекта `Authentication` на основе валидного JWT. Использует секретный ключ и время жизни токена из конфигурации.

    4.  **Компоненты Пользовательских Данных и Аутентификации:**
    *   **`UserDetailsServiceImpl`:** Реализация `UserDetailsService`. Загружает пользователя из `UserRepository` по `email` (для процесса логина, вызывается `AuthenticationManager`). Создает и возвращает `AppUserDetails`.
    *   **`AppUserDetails`:** Кастомная реализация `UserDetails`. Хранит `id` пользователя (для `principal.id` в SpEL), `email` (используемый как username), хешированный пароль, authorities/roles (если/когда они появятся).
    *   **`AuthService`:** Сервисный класс, инкапсулирующий логику:
        *   **Регистрации:** Принимает DTO с данными регистрации, выполняет валидацию, вызывает `PasswordEncoder` для хеширования пароля, сохраняет пользователя через `UserRepository`, вызывает `JwtTokenProvider` для генерации токена (для авто-логина). В случае ошибок валидации (например, неверный формат email, несовпадение паролей) или бизнес-логики (например, email уже занят) **выбрасывает специфичные кастомные исключения** (например, `UserRegistrationValidationException`, `EmailAlreadyExistsException`).
        *   **Логина:** Принимает DTO с кредам. Делегирует фактическую проверку кредов `AuthenticationManager`. `AuthenticationManager` (используя `UserDetailsServiceImpl` и `PasswordEncoder`) в случае неверных кредов **выбрасывает исключения типа `AuthenticationException`** (например, `BadCredentialsException`). `AuthService` обрабатывает результат от `AuthenticationManager` и, при успехе, вызывает `JwtTokenProvider` для генерации токена.

    5.  **Обработка Ошибок API (согласно RFC 9457 `application/problem+json`):**
        *   **Ошибки на публичных эндпоинтах (регистрация, логин):**
            *   Обрабатываются через механизм `@ControllerAdvice` и `@ExceptionHandler`, который ловит кастомные исключения, выброшенные `AuthService` (например, `EmailAlreadyExistsException`, `ValidationException`) или стандартные исключения Spring Security (например, `BadCredentialsException`).
            *   Формируют HTTP-ответы с соответствующими статус-кодами (400, 401, 409) и телом `application/problem+json`.
        *   **Ошибки доступа к защищенным ресурсам:**
            *   **`CustomAuthenticationEntryPoint`:** Реализует `AuthenticationEntryPoint`. Вызывается, когда неаутентифицированный пользователь пытается получить доступ к защищенному ресурсу. Формирует HTTP-ответ `401 Unauthorized` с заголовком `WWW-Authenticate: Bearer realm="task-tracker"` и телом `application/problem+json`.
            *   **`CustomAccessDeniedHandler`:** Реализует `AccessDeniedHandler`. Вызывается, когда аутентифицированный пользователь пытается получить доступ к ресурсу, на который у него нет прав. Формирует HTTP-ответ `403 Forbidden` или `404 Not Found` (в зависимости от стратегии, см. ADR-0019) с телом `application/problem+json`.

    6.  **Компоненты Авторизации:**
        *   **`PermissionService`:** Spring Bean для инкапсуляции сложных/переиспользуемых правил авторизации, вызываемый из SpEL в аннотациях `@PreAuthorize`.
        *   **Репозитории (например, `TaskRepository`):** Содержат методы с Security Expressions в `@Query` (`?#{ principal.id }`) для реализации авторизации по владению при чтении данных (согласно ADR-0019).
# ADR-0040: Архитектура Сервиса-Планировщика

*   **Статус:** Принят
*   **Дата:** 2025-06-18
*   **Контекст:** Проекту требуется сервис для периодического выполнения фоновых задач. Этот сервис должен быть производительным для обработки больших объемов данных и надежным, чтобы гарантировать выполнение бизнес-требований. Простая последовательная обработка не масштабируется и не является отказоустойчивой.
*   **Принятое Решение:**
    1.  **Разделение Ответственности:** Сервис-планировщик будет реализован с четким разделением логики на три слоя:
        *   **Триггер (Trigger):** Легковесный компонент, отвечающий исключительно за запуск процесса по расписанию.
        *   **Управление Жизненным Циклом Запуска (Run Lifecycle Management):** Абстрактный слой, ответственный за обеспечение уникальности выполнения, отслеживание прогресса и восстановление после сбоев.
        *   **Исполнение (Execution):** Компонент, выполняющий реальную бизнес-логику.
    2.  **Параллельная Обработка:** Слой исполнения (`Execution`) будет реализован с использованием внутреннего паттерна **"Производитель-Потребитель"** для параллельной обработки данных.
    3.  **Абстракция Управления Запуском:** Вводится интерфейс `TaskRunManager` как **полный и неизменный контракт** для управления жизненным циклом запуска задачи.
        *   **Интерфейс `TaskRunManager` включает:**
            *   `Optional<String> tryStartNewRun(...)`: Пытается начать новый запуск, обеспечивая уникальность.
            *   `void completeRun(...)`: Отмечает запуск как успешно завершенный.
            *   `void failRun(...)`: Отмечает запуск как провалившийся.
            *   `void claimBatch(runId, batchId, userIds)`: **Регистрирует пачку задач как взятую в обработку.**
            *   `void releaseBatch(runId, batchId)`: **Подтверждает успешную обработку пачки задач.**
            *   `List<Long> recoverStaleIds(runId)`: **Собирает ID из "зависших" пачек для повторной обработки.**
        *   **Цель этого полного контракта** — обеспечить будущую расширяемость до персистентной реализации (Redis/JDBC) **без изменения самого интерфейса** или кода, который его использует.
    4.  **Отказоустойчивость и Идемпотентность:** Архитектура предусматривает восстановление после сбоев через отслеживание "зависших" пачек. Ответственность за обработку возможных дубликатов, возникающих при повторной обработке, возлагается на конечные сервисы-потребители (например, `email-sender`), которые должны быть идемпотентными.
*   **Рассмотренные Альтернативы:**
    *   **Монолитный `@Scheduled` метод:** Отвергнуто из-за низкой производительности и проблем с "двойным запуском".
    *   **Архитектура без отслеживания пачек:** Отвергнуто, так как не решает проблему восстановления после сбоя на середине обработки.
*   **Последствия:**
    *   Архитектура планировщика становится масштабируемой, производительной и отказоустойчивой.
    *   **Создается полностью готовый к эволюции контракт (`TaskRunManager`), который не потребует изменений** при переходе от in-memory реализации к персистентной.
    *   Требуется реализация самого интерфейса, его in-memory версии и соответствующей бизнес-логики в сервисах.